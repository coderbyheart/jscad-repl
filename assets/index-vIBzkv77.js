(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const a of o.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function r(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function n(s){if(s.ep)return;s.ep=!0;const o=r(s);fetch(s.href,o)}})();var Ag=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};const kd=e=>e.reduce((t,r)=>Array.isArray(r)?t.concat(kd(r)):t.concat(r),[]);var We=kd;const Tg=e=>Object.assign({},e);var Sg=Tg;const Pg=(e,t,r)=>(e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e[3]=t[3]+r[3],e[4]=t[4]+r[4],e[5]=t[5]+r[5],e[6]=t[6]+r[6],e[7]=t[7]+r[7],e[8]=t[8]+r[8],e[9]=t[9]+r[9],e[10]=t[10]+r[10],e[11]=t[11]+r[11],e[12]=t[12]+r[12],e[13]=t[13]+r[13],e[14]=t[14]+r[14],e[15]=t[15]+r[15],e);var Cg=Pg;const Og=()=>[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];var tl=Og;const Mg=tl,Rg=e=>{const t=Mg();return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t};var Lg=Rg;const Fg=(e,t)=>(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e);var Bd=Fg;const Gg=(e,t)=>{const r=t[0],n=t[1],s=t[2],o=t[3],a=t[4],i=t[5],c=t[6],l=t[7],u=t[8],d=t[9],h=t[10],p=t[11],E=t[12],g=t[13],b=t[14],S=t[15],G=r*i-n*a,R=r*c-s*a,M=r*l-o*a,F=n*c-s*i,L=n*l-o*i,U=s*l-o*c,ee=u*g-d*E,oe=u*b-h*E,pe=u*S-p*E,Q=d*b-h*g,Se=d*S-p*g,qe=h*S-p*b;let $e=G*qe-R*Se+M*Q+F*pe-L*oe+U*ee;return $e?($e=1/$e,e[0]=(i*qe-c*Se+l*Q)*$e,e[1]=(s*Se-n*qe-o*Q)*$e,e[2]=(g*U-b*L+S*F)*$e,e[3]=(h*L-d*U-p*F)*$e,e[4]=(c*pe-a*qe-l*oe)*$e,e[5]=(r*qe-s*pe+o*oe)*$e,e[6]=(b*M-E*U-S*R)*$e,e[7]=(u*U-h*M+p*R)*$e,e[8]=(a*Se-i*pe+l*ee)*$e,e[9]=(n*pe-r*Se-o*ee)*$e,e[10]=(E*L-g*M+S*G)*$e,e[11]=(d*M-u*L-p*G)*$e,e[12]=(i*oe-a*Q-c*ee)*$e,e[13]=(r*Q-n*oe+s*ee)*$e,e[14]=(g*R-E*F-b*G)*$e,e[15]=(u*F-d*R+h*G)*$e,e):null};var Ng=Gg;const Dg=(e,t)=>e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15];var kg=Dg;const Bg=1e5,Ig=1e-5,Vg=1e-13,zg=Math.PI*2;var st={EPS:Ig,NEPS:Vg,TAU:zg,spatialResolution:Bg};const{NEPS:Ug}=st,Id=e=>Math.abs(e)<Ug?0:e,qg=e=>Id(Math.sin(e)),Xg=e=>Id(Math.cos(e));var Bt={sin:qg,cos:Xg};const jg=e=>(e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e);var Vd=jg;const{EPS:Hg}=st,{sin:Yg,cos:Wg}=Bt,Zg=Vd,Qg=(e,t,r)=>{let[n,s,o]=r;const a=n*n+s*s+o*o;if(Math.abs(a)<Hg)return Zg(e);const i=1/Math.sqrt(a);n*=i,s*=i,o*=i;const c=Yg(t),l=Wg(t),u=1-l;return e[0]=n*n*u+l,e[1]=s*n*u+o*c,e[2]=o*n*u-s*c,e[3]=0,e[4]=n*s*u-o*c,e[5]=s*s*u+l,e[6]=o*s*u+n*c,e[7]=0,e[8]=n*o*u+s*c,e[9]=s*o*u-n*c,e[10]=o*o*u+l,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e};var zd=Qg;const Kg=(e,t)=>(e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e);var Jg=Kg;const{sin:Ni,cos:Di}=Bt,e5=(e,t,r,n)=>{const s=Ni(t),o=Di(t),a=Ni(r),i=Di(r),c=Ni(n),l=Di(n);return e[0]=i*o,e[1]=i*s,e[2]=-a,e[3]=0,e[4]=c*a*o-l*s,e[5]=l*o+c*a*s,e[6]=c*i,e[7]=0,e[8]=c*s+l*a*o,e[9]=l*a*s-c*o,e[10]=l*i,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e};var t5=e5;const r5=(e,t)=>(e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e);var n5=r5;const s5=tl,o5=(e,t,r,n,s,o,a,i,c,l,u,d,h,p,E,g)=>{const b=s5();return b[0]=e,b[1]=t,b[2]=r,b[3]=n,b[4]=s,b[5]=o,b[6]=a,b[7]=i,b[8]=c,b[9]=l,b[10]=u,b[11]=d,b[12]=h,b[13]=p,b[14]=E,b[15]=g,b};var a5=o5;const i5=(e,t)=>(e[0]=Math.abs(t[0]),e[1]=Math.abs(t[1]),e[2]=Math.abs(t[2]),e);var Ud=i5;const c5=(e,t,r)=>(e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e);var qd=c5;const l5=(e,t)=>e[0]*t[0]+e[1]*t[1]+e[2]*t[2];var ya=l5;const f5=ya,u5=(e,t)=>{const r=e[0],n=e[1],s=e[2],o=t[0],a=t[1],i=t[2],c=Math.sqrt(r*r+n*n+s*s),l=Math.sqrt(o*o+a*a+i*i),u=c*l,d=u&&f5(e,t)/u;return Math.acos(Math.min(Math.max(d,-1),1))};var d5=u5;const h5=()=>[0,0,0];var ba=h5;const m5=ba,p5=e=>{const t=m5();return t[0]=e[0],t[1]=e[1],t[2]=e[2],t};var v5=p5;const g5=(e,t)=>(e[0]=t[0],e[1]=t[1],e[2]=t[2],e);var Xd=g5;const y5=(e,t,r)=>{const n=t[0],s=t[1],o=t[2],a=r[0],i=r[1],c=r[2];return e[0]=s*c-o*i,e[1]=o*a-n*c,e[2]=n*i-s*a,e};var Ys=y5;const b5=(e,t)=>{const r=t[0]-e[0],n=t[1]-e[1],s=t[2]-e[2];return Math.sqrt(r*r+n*n+s*s)};var jd=b5;const w5=(e,t,r)=>(e[0]=t[0]/r[0],e[1]=t[1]/r[1],e[2]=t[2]/r[2],e);var _5=w5;const x5=(e,t)=>e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2];var E5=x5;const $5=(e,t)=>(e[0]=t,e[1]=t,e[2]=t,e);var A5=$5;const T5=ba,S5=(e,t,r)=>{const n=T5();return n[0]=e,n[1]=t,n[2]=r,n};var P5=S5;const C5=(e,t,r=0)=>(e[0]=t[0],e[1]=t[1],e[2]=r,e);var O5=C5;const M5=e=>{const t=e[0],r=e[1],n=e[2];return Math.sqrt(t*t+r*r+n*n)};var Hd=M5;const R5=(e,t,r,n)=>(e[0]=t[0]+n*(r[0]-t[0]),e[1]=t[1]+n*(r[1]-t[1]),e[2]=t[2]+n*(r[2]-t[2]),e);var L5=R5;const F5=(e,t,r)=>(e[0]=Math.max(t[0],r[0]),e[1]=Math.max(t[1],r[1]),e[2]=Math.max(t[2],r[2]),e);var Yd=F5;const G5=(e,t,r)=>(e[0]=Math.min(t[0],r[0]),e[1]=Math.min(t[1],r[1]),e[2]=Math.min(t[2],r[2]),e);var Wd=G5;const N5=(e,t,r)=>(e[0]=t[0]*r[0],e[1]=t[1]*r[1],e[2]=t[2]*r[2],e);var D5=N5;const k5=(e,t)=>(e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e);var B5=k5;const I5=(e,t)=>{const r=t[0],n=t[1],s=t[2];let o=r*r+n*n+s*s;return o>0&&(o=1/Math.sqrt(o)),e[0]=r*o,e[1]=n*o,e[2]=s*o,e};var rl=I5;const V5=Ud,z5=ba,U5=Ys,q5=(e,t)=>{const r=V5(z5(),t),n=0+(r[0]<r[1]&&r[0]<r[2]),s=0+(r[1]<=r[0]&&r[1]<r[2]),o=0+(r[2]<=r[0]&&r[2]<=r[1]);return U5(e,t,[n,s,o])};var X5=q5;const j5=(e,t,r,n)=>{const s=[],o=[];return s[0]=t[0]-r[0],s[1]=t[1]-r[1],s[2]=t[2]-r[2],o[0]=s[0],o[1]=s[1]*Math.cos(n)-s[2]*Math.sin(n),o[2]=s[1]*Math.sin(n)+s[2]*Math.cos(n),e[0]=o[0]+r[0],e[1]=o[1]+r[1],e[2]=o[2]+r[2],e};var H5=j5;const Y5=(e,t,r,n)=>{const s=[],o=[];return s[0]=t[0]-r[0],s[1]=t[1]-r[1],s[2]=t[2]-r[2],o[0]=s[2]*Math.sin(n)+s[0]*Math.cos(n),o[1]=s[1],o[2]=s[2]*Math.cos(n)-s[0]*Math.sin(n),e[0]=o[0]+r[0],e[1]=o[1]+r[1],e[2]=o[2]+r[2],e};var W5=Y5;const Z5=(e,t,r,n)=>{const s=[],o=[];return s[0]=t[0]-r[0],s[1]=t[1]-r[1],o[0]=s[0]*Math.cos(n)-s[1]*Math.sin(n),o[1]=s[0]*Math.sin(n)+s[1]*Math.cos(n),e[0]=o[0]+r[0],e[1]=o[1]+r[1],e[2]=t[2],e};var Q5=Z5;const K5=(e,t,r)=>(e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e);var Zd=K5;const J5=(e,t,r)=>(e[0]=Math.round(t[0]/r)*r+0,e[1]=Math.round(t[1]/r)*r+0,e[2]=Math.round(t[2]/r)*r+0,e);var ey=J5;const ty=(e,t)=>{const r=t[0]-e[0],n=t[1]-e[1],s=t[2]-e[2];return r*r+n*n+s*s};var Qd=ty;const ry=e=>{const t=e[0],r=e[1],n=e[2];return t*t+r*r+n*n};var Kd=ry;const ny=(e,t,r)=>(e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e);var wa=ny;const sy=e=>`[${e[0].toFixed(7)}, ${e[1].toFixed(7)}, ${e[2].toFixed(7)}]`;var oy=sy;const ay=(e,t,r)=>{const n=t[0],s=t[1],o=t[2];let a=r[3]*n+r[7]*s+r[11]*o+r[15];return a=a||1,e[0]=(r[0]*n+r[4]*s+r[8]*o+r[12])/a,e[1]=(r[1]*n+r[5]*s+r[9]*o+r[13])/a,e[2]=(r[2]*n+r[6]*s+r[10]*o+r[14])/a,e};var iy=ay,Ie={abs:Ud,add:qd,angle:d5,clone:v5,copy:Xd,create:ba,cross:Ys,distance:jd,divide:_5,dot:ya,equals:E5,fromScalar:A5,fromValues:P5,fromVec2:O5,length:Hd,lerp:L5,max:Yd,min:Wd,multiply:D5,negate:B5,normalize:rl,orthogonal:X5,rotateX:H5,rotateY:W5,rotateZ:Q5,scale:Zd,snap:ey,squaredDistance:Qd,squaredLength:Kd,subtract:wa,toString:oy,transform:iy};const Br=Ie,cy=zd,ly=(e,t,r)=>{const n=Br.normalize(Br.create(),t),s=Br.normalize(Br.create(),r),o=Br.cross(Br.create(),s,n),a=Br.dot(s,n);if(a===-1)return cy(e,Math.PI,Br.orthogonal(o,n));const i=1/(1+a);return e[0]=o[0]*o[0]*i+a,e[1]=o[1]*o[0]*i-o[2],e[2]=o[2]*o[0]*i+o[1],e[3]=0,e[4]=o[0]*o[1]*i+o[2],e[5]=o[1]*o[1]*i+a,e[6]=o[2]*o[1]*i-o[0],e[7]=0,e[8]=o[0]*o[2]*i-o[1],e[9]=o[1]*o[2]*i+o[0],e[10]=o[2]*o[2]*i+a,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e};var fy=ly;const{sin:uy,cos:dy}=Bt,hy=(e,t)=>{const r=uy(t),n=dy(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=n,e[6]=r,e[7]=0,e[8]=0,e[9]=-r,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e};var my=hy;const{sin:py,cos:vy}=Bt,gy=(e,t)=>{const r=py(t),n=vy(t);return e[0]=n,e[1]=0,e[2]=-r,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=r,e[9]=0,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e};var yy=gy;const{sin:by,cos:wy}=Bt,_y=(e,t)=>{const r=by(t),n=wy(t);return e[0]=n,e[1]=r,e[2]=0,e[3]=0,e[4]=-r,e[5]=n,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e};var xy=_y;const Ey=e=>e[0]===1&&e[1]===0&&e[2]===0&&e[3]===0&&e[4]===0&&e[5]===1&&e[6]===0&&e[7]===0&&e[8]===0&&e[9]===0&&e[10]===1&&e[11]===0&&e[12]===0&&e[13]===0&&e[14]===0&&e[15]===1;var $y=Ey;const Ay=e=>Tr(e[1])&&Tr(e[2])&&Tr(e[3])&&Tr(e[4])&&Tr(e[6])&&Tr(e[7])&&Tr(e[8])&&Tr(e[9])&&Tr(e[11])&&e[15]===1,Tr=e=>Math.abs(e)<Number.EPSILON;var Ty=Ay;const Sy=e=>{const t=e[4]*e[9]-e[8]*e[5],r=e[8]*e[1]-e[0]*e[9],n=e[0]*e[5]-e[4]*e[1];return t*e[2]+r*e[6]+n*e[10]<0};var Py=Sy;const Cy=(e,t)=>{const[r,n,s,o]=t;return e[0]=1-2*r*r,e[1]=-2*n*r,e[2]=-2*s*r,e[3]=0,e[4]=-2*r*n,e[5]=1-2*n*n,e[6]=-2*s*n,e[7]=0,e[8]=-2*r*s,e[9]=-2*n*s,e[10]=1-2*s*s,e[11]=0,e[12]=2*r*o,e[13]=2*n*o,e[14]=2*s*o,e[15]=1,e};var Oy=Cy;const My=(e,t,r)=>{const n=t[0],s=t[1],o=t[2],a=t[3],i=t[4],c=t[5],l=t[6],u=t[7],d=t[8],h=t[9],p=t[10],E=t[11],g=t[12],b=t[13],S=t[14],G=t[15];let R=r[0],M=r[1],F=r[2],L=r[3];return e[0]=R*n+M*i+F*d+L*g,e[1]=R*s+M*c+F*h+L*b,e[2]=R*o+M*l+F*p+L*S,e[3]=R*a+M*u+F*E+L*G,R=r[4],M=r[5],F=r[6],L=r[7],e[4]=R*n+M*i+F*d+L*g,e[5]=R*s+M*c+F*h+L*b,e[6]=R*o+M*l+F*p+L*S,e[7]=R*a+M*u+F*E+L*G,R=r[8],M=r[9],F=r[10],L=r[11],e[8]=R*n+M*i+F*d+L*g,e[9]=R*s+M*c+F*h+L*b,e[10]=R*o+M*l+F*p+L*S,e[11]=R*a+M*u+F*E+L*G,R=r[12],M=r[13],F=r[14],L=r[15],e[12]=R*n+M*i+F*d+L*g,e[13]=R*s+M*c+F*h+L*b,e[14]=R*o+M*l+F*p+L*S,e[15]=R*a+M*u+F*E+L*G,e};var Ry=My;const{EPS:Ly}=st,{sin:Fy,cos:Gy}=Bt,Ny=Bd,Dy=(e,t,r,n)=>{let[s,o,a]=n;const i=s*s+o*o+a*a;if(Math.abs(i)<Ly)return Ny(e,t);const c=1/Math.sqrt(i);s*=c,o*=c,a*=c;const l=Fy(r),u=Gy(r),d=1-u,h=t[0],p=t[1],E=t[2],g=t[3],b=t[4],S=t[5],G=t[6],R=t[7],M=t[8],F=t[9],L=t[10],U=t[11],ee=s*s*d+u,oe=o*s*d+a*l,pe=a*s*d-o*l,Q=s*o*d-a*l,Se=o*o*d+u,qe=a*o*d+s*l,$e=s*a*d+o*l,Xe=o*a*d-s*l,Ne=a*a*d+u;return e[0]=h*ee+b*oe+M*pe,e[1]=p*ee+S*oe+F*pe,e[2]=E*ee+G*oe+L*pe,e[3]=g*ee+R*oe+U*pe,e[4]=h*Q+b*Se+M*qe,e[5]=p*Q+S*Se+F*qe,e[6]=E*Q+G*Se+L*qe,e[7]=g*Q+R*Se+U*qe,e[8]=h*$e+b*Xe+M*Ne,e[9]=p*$e+S*Xe+F*Ne,e[10]=E*$e+G*Xe+L*Ne,e[11]=g*$e+R*Xe+U*Ne,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e};var ky=Dy;const{sin:By,cos:Iy}=Bt,Vy=(e,t,r)=>{const n=By(r),s=Iy(r),o=t[4],a=t[5],i=t[6],c=t[7],l=t[8],u=t[9],d=t[10],h=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=o*s+l*n,e[5]=a*s+u*n,e[6]=i*s+d*n,e[7]=c*s+h*n,e[8]=l*s-o*n,e[9]=u*s-a*n,e[10]=d*s-i*n,e[11]=h*s-c*n,e};var zy=Vy;const{sin:Uy,cos:qy}=Bt,Xy=(e,t,r)=>{const n=Uy(r),s=qy(r),o=t[0],a=t[1],i=t[2],c=t[3],l=t[8],u=t[9],d=t[10],h=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=o*s-l*n,e[1]=a*s-u*n,e[2]=i*s-d*n,e[3]=c*s-h*n,e[8]=o*n+l*s,e[9]=a*n+u*s,e[10]=i*n+d*s,e[11]=c*n+h*s,e};var jy=Xy;const{sin:Hy,cos:Yy}=Bt,Wy=(e,t,r)=>{const n=Hy(r),s=Yy(r),o=t[0],a=t[1],i=t[2],c=t[3],l=t[4],u=t[5],d=t[6],h=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=o*s+l*n,e[1]=a*s+u*n,e[2]=i*s+d*n,e[3]=c*s+h*n,e[4]=l*s-o*n,e[5]=u*s-a*n,e[6]=d*s-i*n,e[7]=h*s-c*n,e};var Zy=Wy;const Qy=(e,t,r)=>{const n=r[0],s=r[1],o=r[2];return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*s,e[5]=t[5]*s,e[6]=t[6]*s,e[7]=t[7]*s,e[8]=t[8]*o,e[9]=t[9]*o,e[10]=t[10]*o,e[11]=t[11]*o,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e};var Ky=Qy;const Jy=(e,t,r)=>(e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e[3]=t[3]-r[3],e[4]=t[4]-r[4],e[5]=t[5]-r[5],e[6]=t[6]-r[6],e[7]=t[7]-r[7],e[8]=t[8]-r[8],e[9]=t[9]-r[9],e[10]=t[10]-r[10],e[11]=t[11]-r[11],e[12]=t[12]-r[12],e[13]=t[13]-r[13],e[14]=t[14]-r[14],e[15]=t[15]-r[15],e);var eb=Jy;const tb=e=>e.map(t=>t.toFixed(7)).toString();var rb=tb;const nb=(e,t,r)=>{const n=r[0],s=r[1],o=r[2];let a,i,c,l,u,d,h,p,E,g,b,S;return t===e?(e[12]=t[0]*n+t[4]*s+t[8]*o+t[12],e[13]=t[1]*n+t[5]*s+t[9]*o+t[13],e[14]=t[2]*n+t[6]*s+t[10]*o+t[14],e[15]=t[3]*n+t[7]*s+t[11]*o+t[15]):(a=t[0],i=t[1],c=t[2],l=t[3],u=t[4],d=t[5],h=t[6],p=t[7],E=t[8],g=t[9],b=t[10],S=t[11],e[0]=a,e[1]=i,e[2]=c,e[3]=l,e[4]=u,e[5]=d,e[6]=h,e[7]=p,e[8]=E,e[9]=g,e[10]=b,e[11]=S,e[12]=a*n+u*s+E*o+t[12],e[13]=i*n+d*s+g*o+t[13],e[14]=c*n+h*s+b*o+t[14],e[15]=l*n+p*s+S*o+t[15]),e};var sb=nb,ft={add:Cg,clone:Lg,copy:Bd,create:tl,invert:Ng,equals:kg,fromRotation:zd,fromScaling:Jg,fromTaitBryanRotation:t5,fromTranslation:n5,fromValues:a5,fromVectorRotation:fy,fromXRotation:my,fromYRotation:yy,fromZRotation:xy,identity:Vd,isIdentity:$y,isOnlyTransformScale:Ty,isMirroring:Py,mirrorByPlane:Oy,multiply:Ry,rotate:ky,rotateX:zy,rotateY:jy,rotateZ:Zy,scale:Ky,subtract:eb,toString:rb,translate:sb};const ob=ft,ab=e=>(e===void 0&&(e=[]),{sides:e,transforms:ob.create()});var _a=ab;const ib=(e,t)=>(e[0]=Math.abs(t[0]),e[1]=Math.abs(t[1]),e);var cb=ib;const lb=(e,t,r)=>(e[0]=t[0]+r[0],e[1]=t[1]+r[1],e);var fb=lb;const ub=e=>Math.atan2(e[1],e[0]);var nl=ub,db=nl;const hb=nl,mb=e=>hb(e)*57.29577951308232;var pb=mb;const vb=()=>[0,0];var xa=vb;const gb=xa,yb=e=>{const t=gb();return t[0]=e[0],t[1]=e[1],t};var bb=yb;const wb=(e,t)=>(e[0]=t[0],e[1]=t[1],e);var _b=wb;const xb=(e,t,r)=>(e[0]=0,e[1]=0,e[2]=t[0]*r[1]-t[1]*r[0],e);var Eb=xb;const $b=(e,t)=>{const r=t[0]-e[0],n=t[1]-e[1];return Math.sqrt(r*r+n*n)};var Ab=$b;const Tb=(e,t,r)=>(e[0]=t[0]/r[0],e[1]=t[1]/r[1],e);var Sb=Tb;const Pb=(e,t)=>e[0]*t[0]+e[1]*t[1];var Cb=Pb;const Ob=(e,t)=>e[0]===t[0]&&e[1]===t[1];var Mb=Ob;const{sin:Rb,cos:Lb}=Bt,Fb=(e,t)=>(e[0]=Lb(t),e[1]=Rb(t),e);var Jd=Fb;const Gb=Jd,Nb=(e,t)=>Gb(e,t*.017453292519943295);var Db=Nb;const kb=(e,t)=>(e[0]=t,e[1]=t,e);var Bb=kb;const Ib=xa,Vb=(e,t)=>{const r=Ib();return r[0]=e,r[1]=t,r};var zb=Vb;const Ub=e=>Math.sqrt(e[0]*e[0]+e[1]*e[1]);var qb=Ub;const Xb=(e,t,r,n)=>{const s=t[0],o=t[1];return e[0]=s+n*(r[0]-s),e[1]=o+n*(r[1]-o),e};var jb=Xb;const Hb=(e,t,r)=>(e[0]=Math.max(t[0],r[0]),e[1]=Math.max(t[1],r[1]),e);var Yb=Hb;const Wb=(e,t,r)=>(e[0]=Math.min(t[0],r[0]),e[1]=Math.min(t[1],r[1]),e);var Zb=Wb;const Qb=(e,t,r)=>(e[0]=t[0]*r[0],e[1]=t[1]*r[1],e);var Kb=Qb;const Jb=(e,t)=>(e[0]=-t[0],e[1]=-t[1],e);var e3=Jb;const t3=(e,t,r,n)=>{const s=t[0]-r[0],o=t[1]-r[1],a=Math.cos(n),i=Math.sin(n);return e[0]=s*a-o*i+r[0],e[1]=s*i+o*a+r[1],e};var eh=t3;const{TAU:r3}=st,n3=xa,s3=eh,o3=(e,t)=>s3(e,t,n3(),r3/4);var a3=o3;const i3=(e,t)=>{const r=t[0],n=t[1];let s=r*r+n*n;return s>0&&(s=1/Math.sqrt(s)),e[0]=r*s,e[1]=n*s,e};var c3=i3;const l3=(e,t,r)=>(e[0]=t[0]*r,e[1]=t[1]*r,e);var f3=l3;const u3=(e,t,r)=>(e[0]=Math.round(t[0]/r)*r+0,e[1]=Math.round(t[1]/r)*r+0,e);var d3=u3;const h3=(e,t)=>{const r=t[0]-e[0],n=t[1]-e[1];return r*r+n*n};var m3=h3;const p3=e=>{const t=e[0],r=e[1];return t*t+r*r};var v3=p3;const g3=(e,t,r)=>(e[0]=t[0]-r[0],e[1]=t[1]-r[1],e);var y3=g3;const b3=e=>`[${e[0].toFixed(7)}, ${e[1].toFixed(7)}]`;var w3=b3;const _3=(e,t,r)=>{const n=t[0],s=t[1];return e[0]=r[0]*n+r[4]*s+r[12],e[1]=r[1]*n+r[5]*s+r[13],e};var x3=_3,rt={abs:cb,add:fb,angle:db,angleDegrees:pb,angleRadians:nl,clone:bb,copy:_b,create:xa,cross:Eb,distance:Ab,divide:Sb,dot:Cb,equals:Mb,fromAngleDegrees:Db,fromAngleRadians:Jd,fromScalar:Bb,fromValues:zb,length:qb,lerp:jb,max:Yb,min:Zb,multiply:Kb,negate:e3,normal:a3,normalize:c3,rotate:eh,scale:f3,snap:d3,squaredDistance:m3,squaredLength:v3,subtract:y3,toString:w3,transform:x3};const ki=rt,E3=_a,$3=e=>{if(!Array.isArray(e))throw new Error("the given points must be an array");let t=e.length;if(t<3)throw new Error("the given points must define a closed geometry with three or more points");ki.equals(e[0],e[t-1])&&--t;const r=[];let n=e[t-1];for(let s=0;s<t;s++){const o=e[s];r.push([ki.clone(n),ki.clone(o)]),n=o}return E3(r)};var A3=$3;const T3=ft,N1=rt,S3=_a,P3=e=>{if(e[0]!==0)throw new Error("invalid compact binary data");const t=S3();t.transforms=T3.clone(e.slice(1,17));for(let r=21;r<e.length;r+=4){const n=N1.fromValues(e[r+0],e[r+1]),s=N1.fromValues(e[r+2],e[r+3]);t.sides.push([n,s])}return e[17]>=0&&(t.color=[e[17],e[18],e[19],e[20]]),t};var C3=P3;const O3=e=>!!(e&&typeof e=="object"&&"sides"in e&&"transforms"in e&&Array.isArray(e.sides)&&"length"in e.transforms);var th=O3;const D1=ft,No=rt,M3=e=>(D1.isIdentity(e.transforms)||(e.sides=e.sides.map(t=>{const r=No.transform(No.create(),t[0],e.transforms),n=No.transform(No.create(),t[1],e.transforms);return[r,n]}),e.transforms=D1.create()),e);var R3=M3;const L3=R3,F3=e=>L3(e).sides;var Ws=F3;const G3=_a,N3=Ws,D3=e=>{const r=N3(e).map(n=>[n[1],n[0]]);return r.reverse(),G3(r)};var rh=D3;const Ts=rt,k3=Ws,B3=e=>{const t=new Map,r=n=>{const s=n.toString();return t.has(s)?t.get(s):(t.set(s,n),n)};return e.map(n=>n.map(r))},I3=e=>{const t=new Map;return B3(e).forEach(n=>{t.has(n[0])?t.get(n[0]).push(n):t.set(n[0],[n])}),t},V3=e=>{const t=I3(k3(e)),r=[];for(;;){let n;for(const[a,i]of t){if(n=i.shift(),!n){t.delete(a);continue}break}if(n===void 0)break;const s=[],o=n[0];for(;;){s.push(n[0]);const a=n[1];if(a===o)break;const i=t.get(a);if(!i)throw new Error(`geometry is not closed at vertex ${a}`);const c=z3(n,i);i.length===0&&t.delete(a),n=c}s.length>0&&s.push(s.shift()),r.push(s)}return t.clear(),r},z3=(e,t)=>{if(t.length===1)return t.pop();const r=Ts.create(),n=Ts.angleDegrees(Ts.subtract(r,e[1],e[0]));let s,o;t.forEach((i,c)=>{let u=Ts.angleDegrees(Ts.subtract(r,i[1],i[0]))-n;u<-180&&(u+=360),u>=180&&(u-=360),(o===void 0||u>s)&&(o=c,s=u)});const a=t[o];return t.splice(o,1),a};var nh=V3;const U3=Ws,q3=e=>{const r=U3(e).map(n=>n[0]);return r.length>0&&r.push(r.shift()),r};var X3=q3;const k1=rt,j3=Ws,H3=e=>{const t=j3(e);let r="geom2 ("+t.length+` sides):
[
`;return t.forEach(n=>{r+="  ["+k1.toString(n[0])+", "+k1.toString(n[1])+`]
`}),r+=`]
`,r};var Y3=H3;const W3=e=>{const t=e.sides,r=e.transforms;let n=[-1,-1,-1,-1];e.color&&(n=e.color);const s=new Float32Array(21+t.length*4);s[0]=0,s[1]=r[0],s[2]=r[1],s[3]=r[2],s[4]=r[3],s[5]=r[4],s[6]=r[5],s[7]=r[6],s[8]=r[7],s[9]=r[8],s[10]=r[9],s[11]=r[10],s[12]=r[11],s[13]=r[12],s[14]=r[13],s[15]=r[14],s[16]=r[15],s[17]=n[0],s[18]=n[1],s[19]=n[2],s[20]=n[3];for(let o=0;o<t.length;o++){const a=o*4+21,i=t[o][0],c=t[o][1];s[a+0]=i[0],s[a+1]=i[1],s[a+2]=c[0],s[a+3]=c[1]}return s};var Z3=W3;const B1=ft,Q3=rh,K3=(e,t)=>{const r=B1.multiply(B1.create(),e,t.transforms),n=Object.assign({},t,{transforms:r});return e[0]*e[5]-e[4]*e[1]<0?Q3(n):n};var J3=K3;const ew=rt,tw=th,rw=nh,nw=e=>{if(!tw(e))throw new Error("invalid geom2 structure");if(rw(e),e.sides.forEach(t=>{if(ew.equals(t[0],t[1]))throw new Error(`geom2 self-edge ${t[0]}`)}),!e.transforms.every(Number.isFinite))throw new Error(`geom2 invalid transforms ${e.transforms}`)};var sw=nw,Qe={clone:Sg,create:_a,fromPoints:A3,fromCompactBinary:C3,isA:th,reverse:rh,toOutlines:nh,toPoints:X3,toSides:Ws,toString:Y3,toCompactBinary:Z3,transform:J3,validate:sw};const ow=e=>Object.assign({},e);var aw=ow;const iw=ft,cw=e=>(e===void 0&&(e=[]),{polygons:e,transforms:iw.create()});var Ea=cw;const lw=e=>((e===void 0||e.length<3)&&(e=[]),{vertices:e});var ss=lw;const fw=ss,uw=Ie,dw=(...e)=>{let t,r;return e.length===1?(t=fw(),r=e[0]):(t=e[0],r=e[1]),t.vertices=r.vertices.map(n=>uw.clone(n)),t};var hw=dw;const mw=Ie,pw=ss,vw=e=>{const t=e.map(r=>mw.clone(r));return pw(t)};var gw=vw;const yw=ss,bw=(e,t)=>{const r=yw(e);return r.plane=t,r};var ww=bw;const _w=()=>[0,0,0,0];var $a=_w;const xw=$a,Ew=e=>{const t=xw();return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t};var sh=Ew;const $w=(e,t)=>(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e);var oh=$w;const Aw=(e,t)=>e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3];var ah=Aw;const Tw=(e,t)=>(e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e);var ih=Tw;const Bi=Ie,Sw=(e,t,r)=>{const n=Bi.normalize(Bi.create(),t),s=Bi.dot(r,n);return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=s,e};var ch=Sw;const Pw=$a,Cw=(e,t,r,n)=>{const s=Pw();return s[0]=e,s[1]=t,s[2]=r,s[3]=n,s};var lh=Cw;const tr=Ie,Ow=ch,Mw=(e,...t)=>{e[0]=0,e[1]=0,e[2]=0,e[3]=0;const r=t.length;t.forEach(p=>{tr.add(e,e,p)}),tr.scale(e,e,1/r);let n=0,s=0,o=0,a=0,i=0,c=0;const l=tr.create();t.forEach(p=>{tr.subtract(l,p,e),n+=l[0]*l[0],s+=l[0]*l[1],o+=l[0]*l[2],a+=l[1]*l[1],i+=l[1]*l[2],c+=l[2]*l[2]}),n/=r,s/=r,o/=r,a/=r,i/=r,c/=r,l[0]=0,l[1]=0,l[2]=0;const u=tr.create();let d=a*c-i*i;u[0]=d,u[1]=o*i-s*c,u[2]=s*i-o*a;let h=d*d;return tr.add(l,l,tr.scale(u,u,h)),d=n*c-o*o,u[0]=o*i-s*c,u[1]=d,u[2]=s*o-i*n,h=d*d,tr.dot(l,u)<0&&(h=-h),tr.add(l,l,tr.scale(u,u,h)),d=n*a-s*s,u[0]=s*i-o*a,u[1]=s*o-i*n,u[2]=d,h=d*d,tr.dot(l,u)<0&&(h=-h),tr.add(l,l,tr.scale(u,u,h)),Ow(e,l,e)};var Rw=Mw;const gr=Ie,Lw=(e,...t)=>{const r=t.length,n=gr.create(),s=gr.create(),o=a=>{const i=t[a],c=t[(a+1)%r],l=t[(a+2)%r];return gr.subtract(n,c,i),gr.subtract(s,l,i),gr.cross(n,n,s),gr.normalize(n,n),n};return e[0]=0,e[1]=0,e[2]=0,r===3?gr.copy(e,o(0)):(t.forEach((a,i)=>{gr.add(e,e,o(i))}),gr.normalize(e,e)),e[3]=gr.dot(e,t[0]),e};var fh=Lw;const{EPS:Ii}=st,It=Ie,Fw=(e,t,r,n)=>{let s=It.subtract(It.create(),r,t),o=It.subtract(It.create(),n,t);It.length(s)<Ii&&(s=It.orthogonal(s,o)),It.length(o)<Ii&&(o=It.orthogonal(o,s));let a=It.cross(It.create(),s,o);It.length(a)<Ii&&(o=It.orthogonal(o,s),a=It.cross(a,s,o)),a=It.normalize(a,a);const i=It.dot(a,t);return e[0]=a[0],e[1]=a[1],e[2]=a[2],e[3]=i,e};var Gw=Fw;const Nw=Ie,Dw=(e,t)=>{const r=t[0]*e[0]+t[1]*e[1]+t[2]*e[2]-e[3],n=t[0]-r*e[0],s=t[1]-r*e[1],o=t[2]-r*e[2];return Nw.fromValues(n,s,o)};var kw=Dw;const Bw=Ie,Iw=(e,t)=>Bw.dot(e,t)-e[3];var uh=Iw;const Vw=e=>`(${e[0].toFixed(9)}, ${e[1].toFixed(9)}, ${e[2].toFixed(9)}, ${e[3].toFixed(9)})`;var dh=Vw;const zw=ft,Vt=Ie,Uw=fh,qw=ih,Xw=(e,t,r)=>{const n=zw.isMirroring(r),s=Vt.orthogonal(Vt.create(),t),o=Vt.cross(s,t,s),a=Vt.cross(Vt.create(),t,o);let i=Vt.fromScalar(Vt.create(),t[3]);Vt.multiply(i,i,t);let c=Vt.add(Vt.create(),i,o),l=Vt.add(Vt.create(),i,a);return i=Vt.transform(i,i,r),c=Vt.transform(c,c,r),l=Vt.transform(l,l,r),Uw(e,i,c,l),n&&qw(e,e),e};var jw=Xw,xr={clone:sh,copy:oh,create:$a,equals:ah,flip:ih,fromNormalAndPoint:ch,fromValues:lh,fromNoisyPoints:Rw,fromPoints:fh,fromPointsRandom:Gw,projectionOfPoint:kw,signedDistanceToPoint:uh,toString:dh,transform:jw};const I1=xr,Hw=ss,Yw=e=>{const t=e.vertices.slice().reverse(),r=Hw(t);return e.plane&&(r.plane=I1.flip(I1.create(),e.plane)),r};var Ww=Yw;const Zw=e=>!!(e&&typeof e=="object"&&"vertices"in e&&Array.isArray(e.vertices));var hh=Zw;const V1=xr,hn=Ie,Qw=e=>Kw(e.vertices),Kw=e=>{const t=e.length;if(t>2){const r=V1.fromPoints(V1.create(),...e);let n=e[t-2],s=e[t-1];for(let o=0;o<t;o++){const a=e[o];if(!Jw(n,s,a,r))return!1;n=s,s=a}}return!0},Jw=(e,t,r,n)=>{const s=hn.cross(hn.create(),hn.subtract(hn.create(),t,e),hn.subtract(hn.create(),r,t));return hn.dot(s,n)>=0};var mh=Qw;const z1=xr,e_=e=>(e.plane||(e.plane=z1.fromPoints(z1.create(),...e.vertices)),e.plane);var sl=e_;const t_=sl,r_=e=>{const t=e.vertices.length;if(t<3)return 0;const r=e.vertices,n=t_(e),s=Math.abs(n[0]),o=Math.abs(n[1]),a=Math.abs(n[2]);if(s+o+a===0)return 0;let i=3;s>o&&s>a?i=1:o>a&&(i=2);let c=0,l=0,u=1,d=2;switch(i){case 1:for(u=1;u<t;u++)l=u-1,d=(u+1)%t,c+=r[u][1]*(r[d][2]-r[l][2]);c+=r[0][1]*(r[1][2]-r[t-1][2]),c/=2*n[0];break;case 2:for(u=1;u<t;u++)l=u-1,d=(u+1)%t,c+=r[u][2]*(r[d][0]-r[l][0]);c+=r[0][2]*(r[1][0]-r[t-1][0]),c/=2*n[1];break;case 3:default:for(u=1;u<t;u++)l=u-1,d=(u+1)%t,c+=r[u][0]*(r[d][1]-r[l][1]);c+=r[0][0]*(r[1][1]-r[t-1][1]),c/=2*n[2];break}return c};var ph=r_;const Ss=Ie,n_=e=>{const t=e.vertices,r=t.length,n=r===0?Ss.create():Ss.clone(t[0]),s=Ss.clone(n);for(let o=1;o<r;o++)Ss.min(n,n,t[o]),Ss.max(s,s,t[o]);return[n,s]};var s_=n_;const o_=(e,t)=>e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3];var a_=o_;const i_=(e,t)=>(e[0]=t,e[1]=t,e[2]=t,e[3]=t,e);var c_=i_;const l_=(e,t,r)=>{const[n,s,o,a]=t;return e[0]=r[0]*n+r[4]*s+r[8]*o+r[12]*a,e[1]=r[1]*n+r[5]*s+r[9]*o+r[13]*a,e[2]=r[2]*n+r[6]*s+r[10]*o+r[14]*a,e[3]=r[3]*n+r[7]*s+r[11]*o+r[15]*a,e};var f_=l_,vh={clone:sh,copy:oh,create:$a,dot:a_,equals:ah,fromScalar:c_,fromValues:lh,toString:dh,transform:f_};const u_=vh,U1=new WeakMap,d_=e=>{const t=U1.get(e);if(t)return t;const r=e.vertices,n=u_.create();if(r.length===0)return n[0]=0,n[1]=0,n[2]=0,n[3]=0,n;let s=r[0],o=s,a=s,i=s,c=s,l=s;r.forEach(p=>{s[0]>p[0]&&(s=p),o[1]>p[1]&&(o=p),a[2]>p[2]&&(a=p),i[0]<p[0]&&(i=p),c[1]<p[1]&&(c=p),l[2]<p[2]&&(l=p)}),n[0]=(s[0]+i[0])*.5,n[1]=(o[1]+c[1])*.5,n[2]=(a[2]+l[2])*.5;const u=n[0]-i[0],d=n[1]-c[1],h=n[2]-l[2];return n[3]=Math.sqrt(u*u+d*d+h*h),U1.set(e,n),n};var h_=d_;const Vi=Ie,m_=e=>{let t=0;const r=e.vertices,n=Vi.create();for(let s=0;s<r.length-2;s++)Vi.cross(n,r[s+1],r[s+2]),t+=Vi.dot(r[0],n);return t/=6,t};var p_=m_;const v_=e=>e.vertices;var g_=v_;const y_=Ie,b_=e=>{let t="poly3: vertices: [";return e.vertices.forEach(r=>{t+=`${y_.toString(r)}, `}),t+="]",t};var w_=b_;const __=ft,q1=Ie,x_=ss,E_=(e,t)=>{const r=t.vertices.map(n=>q1.transform(q1.create(),n,e));return __.isMirroring(e)&&r.reverse(),x_(r)};var $_=E_;const A_=uh,{NEPS:T_}=st,S_=Ie,P_=hh,C_=mh,O_=ph,M_=sl,R_=e=>{if(!P_(e))throw new Error("invalid poly3 structure");if(e.vertices.length<3)throw new Error(`poly3 not enough vertices ${e.vertices.length}`);if(O_(e)<=0)throw new Error("poly3 area must be greater than zero");for(let t=0;t<e.vertices.length;t++)if(S_.equals(e.vertices[t],e.vertices[(t+1)%e.vertices.length]))throw new Error(`poly3 duplicate vertex ${e.vertices[t]}`);if(!C_(e))throw new Error("poly3 must be convex");if(e.vertices.forEach(t=>{if(!t.every(Number.isFinite))throw new Error(`poly3 invalid vertex ${t}`)}),e.vertices.length>3){const t=M_(e);e.vertices.forEach(r=>{const n=Math.abs(A_(t,r));if(n>T_)throw new Error(`poly3 must be coplanar: vertex ${r} distance ${n}`)})}};var L_=R_,ot={clone:hw,create:ss,fromPoints:gw,fromPointsAndPlane:ww,invert:Ww,isA:hh,isConvex:mh,measureArea:ph,measureBoundingBox:s_,measureBoundingSphere:h_,measureSignedVolume:p_,plane:sl,toPoints:g_,toString:w_,transform:$_,validate:L_};const F_=ot,G_=Ea,N_=e=>{if(!Array.isArray(e))throw new Error("the given points must be an array");const t=e.map((n,s)=>F_.create(n));return G_(t)};var D_=N_;const k_=Ie,B_=ft,I_=ot,V_=Ea,z_=e=>{if(e[0]!==1)throw new Error("invalid compact binary data");const t=V_();t.transforms=B_.clone(e.slice(1,17));const r=e[21];let n=22,s=e.length-r*3;for(;s<e.length;){const o=e[n];n++;const a=[];for(let i=0;i<o;i++)a.push(k_.fromValues(e[s],e[s+1],e[s+2])),s+=3;t.polygons.push(I_.create(a))}return e[17]>=0&&(t.color=[e[17],e[18],e[19],e[20]]),t};var U_=z_;const X1=ft,q_=ot,X_=e=>(X1.isIdentity(e.transforms)||(e.polygons=e.polygons.map(t=>q_.transform(e.transforms,t)),e.transforms=X1.create()),e);var j_=X_;const H_=j_,Y_=e=>H_(e).polygons;var Aa=Y_;const W_=ot,Z_=Ea,Q_=Aa,K_=e=>{const r=Q_(e).map(n=>W_.invert(n));return Z_(r)};var J_=K_;const ex=e=>!!(e&&typeof e=="object"&&"polygons"in e&&"transforms"in e&&Array.isArray(e.polygons)&&"length"in e.transforms);var gh=ex;const tx=ot,rx=Aa,nx=e=>rx(e).map(n=>tx.toPoints(n));var sx=nx;const ox=ot,ax=Aa,ix=e=>{const t=ax(e);let r="geom3 ("+t.length+` polygons):
`;return t.forEach(n=>{r+="  "+ox.toString(n)+`
`}),r};var cx=ix;const lx=ot,fx=e=>{const t=e.polygons,r=e.transforms,n=t.length,s=t.reduce((l,u)=>l+u.vertices.length,0);let o=[-1,-1,-1,-1];e.color&&(o=e.color);const a=new Float32Array(22+n+s*3);a[0]=1,a[1]=r[0],a[2]=r[1],a[3]=r[2],a[4]=r[3],a[5]=r[4],a[6]=r[5],a[7]=r[6],a[8]=r[7],a[9]=r[8],a[10]=r[9],a[11]=r[10],a[12]=r[11],a[13]=r[12],a[14]=r[13],a[15]=r[14],a[16]=r[15],a[17]=o[0],a[18]=o[1],a[19]=o[2],a[20]=o[3],a[21]=s;let i=22,c=i+n;return t.forEach(l=>{const u=lx.toPoints(l);a[i]=u.length,i++;for(let d=0;d<u.length;d++){const h=u[d];a[c+0]=h[0],a[c+1]=h[1],a[c+2]=h[2],c+=3}}),a};var ux=fx;const j1=ft,dx=(e,t)=>{const r=j1.multiply(j1.create(),e,t.transforms);return Object.assign({},t,{transforms:r})};var hx=dx;const mx=ot,px=gh,vx=e=>{if(!px(e))throw new Error("invalid geom3 structure");if(e.polygons.forEach(mx.validate),gx(e),!e.transforms.every(Number.isFinite))throw new Error(`geom3 invalid transforms ${e.transforms}`)},gx=e=>{const t=new Map;e.polygons.forEach(({vertices:n})=>{n.forEach((s,o)=>{const a=`${s}`,i=`${n[(o+1)%n.length]}`,c=`${a}/${i}`,l=t.has(c)?t.get(c):0;t.set(c,l+1)})});const r=[];if(t.forEach((n,s)=>{const o=s.split("/").reverse().join("/"),a=t.get(o);n!==a&&r.push(s.replace("/"," -> "))}),r.length>0)throw new Error(`non-manifold edges ${r.length}
${r.join(`
`)}`)};var yx=vx,Ke={clone:aw,create:Ea,fromPoints:D_,fromCompactBinary:U_,invert:J_,isA:gh,toPoints:sx,toPolygons:Aa,toString:cx,toCompactBinary:ux,transform:hx,validate:yx};const bx=e=>Object.assign({},e);var ol=bx;const{EPS:H1}=st,wx=rt,_x=ol,xx=e=>{if(e.isClosed)return e;const t=_x(e);if(t.isClosed=!0,t.points.length>1){const r=t.points,n=r[0];let s=r[r.length-1];for(;wx.distance(n,s)<H1*H1&&(r.pop(),r.length!==1);)s=r[r.length-1]}return t};var yh=xx;const Ex=ft,$x=e=>(e===void 0&&(e=[]),{points:e,isClosed:!1,transforms:Ex.create()});var Ta=$x;const{EPS:Y1}=st,W1=rt,Ax=yh,Tx=Ta,Sx=(e,t)=>{const r={closed:!1};let{closed:n}=Object.assign({},r,e),s=Tx();if(s.points=t.map(o=>W1.clone(o)),s.points.length>1){const o=s.points[0],a=s.points[s.points.length-1];W1.distance(o,a)<Y1*Y1&&(n=!0)}return n===!0&&(s=Ax(s)),s};var al=Sx;const Z1=ft,Q1=rt,Px=e=>(Z1.isIdentity(e.transforms)||(e.points=e.points.map(t=>Q1.transform(Q1.create(),t,e.transforms)),e.transforms=Z1.create()),e);var Cx=Px;const Ox=Cx,Mx=e=>Ox(e).points;var os=Mx;const{TAU:Do}=st,St=rt,Rx=al,Lx=os,Fx=(e,t)=>{const r={radius:[0,0],xaxisrotation:0,clockwise:!1,large:!1,segments:16};let{endpoint:n,radius:s,xaxisrotation:o,clockwise:a,large:i,segments:c}=Object.assign({},r,e);if(!Array.isArray(n))throw new Error("endpoint must be an array of X and Y values");if(n.length<2)throw new Error("endpoint must contain X and Y values");if(n=St.clone(n),!Array.isArray(s))throw new Error("radius must be an array of X and Y values");if(s.length<2)throw new Error("radius must contain X and Y values");if(c<4)throw new Error("segments must be four or more");const l=1e5;if(t.isClosed)throw new Error("the given path cannot be closed");const u=Lx(t);if(u.length<1)throw new Error("the given path must contain one or more points (as the starting point for the arc)");let d=s[0],h=s[1];const p=u[u.length-1];d=Math.round(d*l)/l,h=Math.round(h*l)/l,n=St.fromValues(Math.round(n[0]*l)/l,Math.round(n[1]*l)/l);const E=!a;let g=[];if(d===0||h===0)g.push(n);else{d=Math.abs(d),h=Math.abs(h);const S=o,G=Math.cos(S),R=Math.sin(S),M=St.subtract(St.create(),p,n);St.scale(M,M,.5);const F=Math.round((G*M[0]+R*M[1])*l)/l,L=Math.round((-R*M[0]+G*M[1])*l)/l,U=St.fromValues(F,L),ee=U[0]*U[0]/(d*d)+U[1]*U[1]/(h*h);if(ee>1){const Rt=Math.sqrt(ee);d*=Rt,h*=Rt,d=Math.round(d*l)/l,h=Math.round(h*l)/l}let oe=Math.sqrt((d*d*h*h-d*d*U[1]*U[1]-h*h*U[0]*U[0])/(d*d*U[1]*U[1]+h*h*U[0]*U[0]));E===i&&(oe=-oe);const pe=St.fromValues(d*U[1]/h,-h*U[0]/d);St.scale(pe,pe,oe);let Q=St.fromValues(G*pe[0]-R*pe[1],R*pe[0]+G*pe[1]);Q=St.add(Q,Q,St.scale(St.create(),St.add(St.create(),p,n),.5));const Se=St.fromValues((U[0]-pe[0])/d,(U[1]-pe[1])/h),qe=St.fromValues((-U[0]-pe[0])/d,(-U[1]-pe[1])/h),$e=St.angleRadians(Se);let Ne=St.angleRadians(qe)-$e;Ne=Ne%Do,!E&&Ne>0?Ne-=Do:E&&Ne<0&&(Ne+=Do);let Ct=Math.ceil(Math.abs(Ne)/Do*c)+1;Ct<1&&(Ct=1);for(let Rt=1;Rt<Ct;Rt++){const Or=$e+Rt/Ct*Ne,ur=Math.cos(Or),Mr=Math.sin(Or),dr=St.fromValues(G*d*ur-R*h*Mr,R*d*ur+G*h*Mr);St.add(dr,dr,Q),g.push(dr)}Ct&&g.push(e.endpoint)}return g=u.concat(g),Rx({},g)};var Gx=Fx;const Nx=al,Dx=os,{equals:kx}=rt,Bx=(...e)=>{let t=!1,r=[];return e.forEach((n,s)=>{const o=Dx(n).slice();if(r.length>0&&o.length>0&&kx(o[0],r[r.length-1])&&o.shift(),o.length>0&&t)throw new Error(`Cannot concatenate to a closed path; check the ${s}th path`);t=n.isClosed,r=r.concat(o)}),Nx({closed:t},r)};var bh=Bx;const Ix=bh,Vx=Ta,zx=(e,t)=>Ix(t,Vx(e));var wh=zx;const{TAU:Ux}=st,rr=rt,qx=rt,Xx=wh,jx=os,Hx=(e,t)=>{const r={segments:16};let{controlPoints:n,segments:s}=Object.assign({},r,e);if(!Array.isArray(n))throw new Error("controlPoints must be an array of one or more points");if(n.length<1)throw new Error("controlPoints must be an array of one or more points");if(s<4)throw new Error("segments must be four or more");if(t.isClosed)throw new Error("the given geometry cannot be closed");const o=jx(t);if(o.length<1)throw new Error("the given path must contain one or more points (as the starting point for the bezier curve)");if(n=n.slice(),n[0]===null){if(n.length<2)throw new Error("a null control point must be passed with one more control points");let L=o[o.length-2];if("lastBezierControlPoint"in t&&(L=t.lastBezierControlPoint),!Array.isArray(L))throw new Error("the given path must contain TWO or more points if given a null control point");const U=rr.scale(rr.create(),o[o.length-1],2);rr.subtract(U,U,L),n[0]=U}n.unshift(o[o.length-1]);const i=n.length-1,c=[];let l=1;for(let L=0;L<=i;++L)L>0&&(l*=L),c.push(l);const u=[];for(let L=0;L<=i;++L){const U=c[i]/(c[L]*c[i-L]);u.push(U)}const d=rr.create(),h=rr.create(),p=qx.create(),E=L=>{let U=1,ee=Math.pow(1-L,i);const oe=L!==1?1/(1-L):1,pe=rr.create();for(let Q=0;Q<=i;++Q){Q===i&&(ee=1);const Se=u[Q]*U*ee,qe=rr.scale(d,n[Q],Se);rr.add(pe,pe,qe),U*=L,ee*=oe}return pe},g=[],b=[],S=i+1;for(let L=0;L<S;++L){const U=L/(S-1),ee=E(U);g.push(ee),b.push(U)}let G=1;const R=Ux/s,M=Math.sin(R);for(;G<g.length-1;){const L=rr.subtract(d,g[G],g[G-1]);rr.normalize(L,L);const U=rr.subtract(h,g[G+1],g[G]);rr.normalize(U,U);const ee=rr.cross(p,L,U);if(Math.abs(ee[2])>M){const oe=b[G-1],pe=b[G+1],Q=oe+(pe-oe)*1/3,Se=oe+(pe-oe)*2/3,qe=E(Q),$e=E(Se);g.splice(G,1,qe,$e),b.splice(G,1,Q,Se),G--,G<1&&(G=1)}else++G}g.shift();const F=Xx(g,t);return F.lastBezierControlPoint=n[n.length-2],F};var Yx=Hx;const Wx=rt,K1=os,Zx=(e,t)=>{if(e.isClosed!==t.isClosed||e.points.length!==t.points.length)return!1;const r=K1(e),n=K1(t),s=r.length;let o=0;do{let a=!1;for(let i=0;i<s;i++)if(!Wx.equals(r[i],n[(i+o)%s])){a=!0;break}if(a===!1)return!0;if(!e.isClosed)return!1}while(++o<s);return!1};var Qx=Zx;const Kx=ft,Jx=rt,eE=Ta,tE=e=>{if(e[0]!==2)throw new Error("invalid compact binary data");const t=eE();t.transforms=Kx.clone(e.slice(1,17)),t.isClosed=!!e[17];for(let r=22;r<e.length;r+=2){const n=Jx.fromValues(e[r],e[r+1]);t.points.push(n)}return e[18]>=0&&(t.color=[e[18],e[19],e[20],e[21]]),t};var rE=tE;const nE=e=>!!(e&&typeof e=="object"&&"points"in e&&"transforms"in e&&"isClosed"in e&&Array.isArray(e.points)&&"length"in e.transforms);var _h=nE;const sE=ol,oE=e=>{const t=sE(e);return t.points=e.points.slice().reverse(),t};var aE=oE;const iE=rt,cE=os,lE=e=>{const t=cE(e);let r="path ("+t.length+" points, "+e.isClosed+`):
[
`;return t.forEach(n=>{r+="  "+iE.toString(n)+`,
`}),r+=`]
`,r};var fE=lE;const uE=e=>{const t=e.points,r=e.transforms;let n=[-1,-1,-1,-1];e.color&&(n=e.color);const s=new Float32Array(22+t.length*2);s[0]=2,s[1]=r[0],s[2]=r[1],s[3]=r[2],s[4]=r[3],s[5]=r[4],s[6]=r[5],s[7]=r[6],s[8]=r[7],s[9]=r[8],s[10]=r[9],s[11]=r[10],s[12]=r[11],s[13]=r[12],s[14]=r[13],s[15]=r[14],s[16]=r[15],s[17]=e.isClosed?1:0,s[18]=n[0],s[19]=n[1],s[20]=n[2],s[21]=n[3];for(let o=0;o<t.length;o++){const a=o*2+22,i=t[o];s[a]=i[0],s[a+1]=i[1]}return s};var dE=uE;const J1=ft,hE=(e,t)=>{const r=J1.multiply(J1.create(),e,t.transforms);return Object.assign({},t,{transforms:r})};var mE=hE;const pE=rt,vE=_h,gE=e=>{if(!vE(e))throw new Error("invalid path2 structure");if(e.points.length>1){for(let t=0;t<e.points.length;t++)if(pE.equals(e.points[t],e.points[(t+1)%e.points.length]))throw new Error(`path2 duplicate points ${e.points[t]}`)}if(e.points.forEach(t=>{if(!t.every(Number.isFinite))throw new Error(`path2 invalid point ${t}`)}),!e.transforms.every(Number.isFinite))throw new Error(`path2 invalid transforms ${e.transforms}`)};var yE=gE,ct={appendArc:Gx,appendBezier:Yx,appendPoints:wh,clone:ol,close:yh,concat:bh,create:Ta,equals:Qx,fromPoints:al,fromCompactBinary:rE,isA:_h,reverse:aE,toPoints:os,toString:fE,toCompactBinary:dE,transform:mE,validate:yE};const bE=We,xh=Qe,Eh=Ke,$h=ct,Ah=ot,wE=(e,t)=>{const r=xh.clone(t);return r.color=e,r},_E=(e,t)=>{const r=Eh.clone(t);return r.color=e,r},xE=(e,t)=>{const r=$h.clone(t);return r.color=e,r},EE=(e,t)=>{const r=Ah.clone(t);return r.color=e,r},$E=(e,...t)=>{if(!Array.isArray(e))throw new Error("color must be an array");if(e.length<3)throw new Error("color must contain R, G and B values");if(e.length===3&&(e=[e[0],e[1],e[2],1]),t=bE(t),t.length===0)throw new Error("wrong number of arguments");const r=t.map(n=>xh.isA(n)?wE(e,n):Eh.isA(n)?_E(e,n):$h.isA(n)?xE(e,n):Ah.isA(n)?EE(e,n):(n.color=e,n));return r.length===1?r[0]:r};var AE=$E;const TE={black:[0/255,0/255,0/255],silver:[192/255,192/255,192/255],gray:[128/255,128/255,128/255],white:[255/255,255/255,255/255],maroon:[128/255,0/255,0/255],red:[255/255,0/255,0/255],purple:[128/255,0/255,128/255],fuchsia:[255/255,0/255,255/255],green:[0/255,128/255,0/255],lime:[0/255,255/255,0/255],olive:[128/255,128/255,0/255],yellow:[255/255,255/255,0/255],navy:[0/255,0/255,128/255],blue:[0/255,0/255,255/255],teal:[0/255,128/255,128/255],aqua:[0/255,255/255,255/255],aliceblue:[240/255,248/255,255/255],antiquewhite:[250/255,235/255,215/255],aquamarine:[127/255,255/255,212/255],azure:[240/255,255/255,255/255],beige:[245/255,245/255,220/255],bisque:[255/255,228/255,196/255],blanchedalmond:[255/255,235/255,205/255],blueviolet:[138/255,43/255,226/255],brown:[165/255,42/255,42/255],burlywood:[222/255,184/255,135/255],cadetblue:[95/255,158/255,160/255],chartreuse:[127/255,255/255,0/255],chocolate:[210/255,105/255,30/255],coral:[255/255,127/255,80/255],cornflowerblue:[100/255,149/255,237/255],cornsilk:[255/255,248/255,220/255],crimson:[220/255,20/255,60/255],cyan:[0/255,255/255,255/255],darkblue:[0/255,0/255,139/255],darkcyan:[0/255,139/255,139/255],darkgoldenrod:[184/255,134/255,11/255],darkgray:[169/255,169/255,169/255],darkgreen:[0/255,100/255,0/255],darkgrey:[169/255,169/255,169/255],darkkhaki:[189/255,183/255,107/255],darkmagenta:[139/255,0/255,139/255],darkolivegreen:[85/255,107/255,47/255],darkorange:[255/255,140/255,0/255],darkorchid:[153/255,50/255,204/255],darkred:[139/255,0/255,0/255],darksalmon:[233/255,150/255,122/255],darkseagreen:[143/255,188/255,143/255],darkslateblue:[72/255,61/255,139/255],darkslategray:[47/255,79/255,79/255],darkslategrey:[47/255,79/255,79/255],darkturquoise:[0/255,206/255,209/255],darkviolet:[148/255,0/255,211/255],deeppink:[255/255,20/255,147/255],deepskyblue:[0/255,191/255,255/255],dimgray:[105/255,105/255,105/255],dimgrey:[105/255,105/255,105/255],dodgerblue:[30/255,144/255,255/255],firebrick:[178/255,34/255,34/255],floralwhite:[255/255,250/255,240/255],forestgreen:[34/255,139/255,34/255],gainsboro:[220/255,220/255,220/255],ghostwhite:[248/255,248/255,255/255],gold:[255/255,215/255,0/255],goldenrod:[218/255,165/255,32/255],greenyellow:[173/255,255/255,47/255],grey:[128/255,128/255,128/255],honeydew:[240/255,255/255,240/255],hotpink:[255/255,105/255,180/255],indianred:[205/255,92/255,92/255],indigo:[75/255,0/255,130/255],ivory:[255/255,255/255,240/255],khaki:[240/255,230/255,140/255],lavender:[230/255,230/255,250/255],lavenderblush:[255/255,240/255,245/255],lawngreen:[124/255,252/255,0/255],lemonchiffon:[255/255,250/255,205/255],lightblue:[173/255,216/255,230/255],lightcoral:[240/255,128/255,128/255],lightcyan:[224/255,255/255,255/255],lightgoldenrodyellow:[250/255,250/255,210/255],lightgray:[211/255,211/255,211/255],lightgreen:[144/255,238/255,144/255],lightgrey:[211/255,211/255,211/255],lightpink:[255/255,182/255,193/255],lightsalmon:[255/255,160/255,122/255],lightseagreen:[32/255,178/255,170/255],lightskyblue:[135/255,206/255,250/255],lightslategray:[119/255,136/255,153/255],lightslategrey:[119/255,136/255,153/255],lightsteelblue:[176/255,196/255,222/255],lightyellow:[255/255,255/255,224/255],limegreen:[50/255,205/255,50/255],linen:[250/255,240/255,230/255],magenta:[255/255,0/255,255/255],mediumaquamarine:[102/255,205/255,170/255],mediumblue:[0/255,0/255,205/255],mediumorchid:[186/255,85/255,211/255],mediumpurple:[147/255,112/255,219/255],mediumseagreen:[60/255,179/255,113/255],mediumslateblue:[123/255,104/255,238/255],mediumspringgreen:[0/255,250/255,154/255],mediumturquoise:[72/255,209/255,204/255],mediumvioletred:[199/255,21/255,133/255],midnightblue:[25/255,25/255,112/255],mintcream:[245/255,255/255,250/255],mistyrose:[255/255,228/255,225/255],moccasin:[255/255,228/255,181/255],navajowhite:[255/255,222/255,173/255],oldlace:[253/255,245/255,230/255],olivedrab:[107/255,142/255,35/255],orange:[255/255,165/255,0/255],orangered:[255/255,69/255,0/255],orchid:[218/255,112/255,214/255],palegoldenrod:[238/255,232/255,170/255],palegreen:[152/255,251/255,152/255],paleturquoise:[175/255,238/255,238/255],palevioletred:[219/255,112/255,147/255],papayawhip:[255/255,239/255,213/255],peachpuff:[255/255,218/255,185/255],peru:[205/255,133/255,63/255],pink:[255/255,192/255,203/255],plum:[221/255,160/255,221/255],powderblue:[176/255,224/255,230/255],rosybrown:[188/255,143/255,143/255],royalblue:[65/255,105/255,225/255],saddlebrown:[139/255,69/255,19/255],salmon:[250/255,128/255,114/255],sandybrown:[244/255,164/255,96/255],seagreen:[46/255,139/255,87/255],seashell:[255/255,245/255,238/255],sienna:[160/255,82/255,45/255],skyblue:[135/255,206/255,235/255],slateblue:[106/255,90/255,205/255],slategray:[112/255,128/255,144/255],slategrey:[112/255,128/255,144/255],snow:[255/255,250/255,250/255],springgreen:[0/255,255/255,127/255],steelblue:[70/255,130/255,180/255],tan:[210/255,180/255,140/255],thistle:[216/255,191/255,216/255],tomato:[255/255,99/255,71/255],turquoise:[64/255,224/255,208/255],violet:[238/255,130/255,238/255],wheat:[245/255,222/255,179/255],whitesmoke:[245/255,245/255,245/255],yellowgreen:[154/255,205/255,50/255]};var Th=TE;const SE=Th,PE=e=>SE[e.toLowerCase()];var CE=PE;const OE=e=>{if(e=e.replace("#",""),e.length<6)throw new Error("the given notation must contain 3 or more hex values");const t=parseInt(e.substring(0,2),16)/255,r=parseInt(e.substring(2,4),16)/255,n=parseInt(e.substring(4,6),16)/255;if(e.length>=8){const s=parseInt(e.substring(6,8),16)/255;return[t,r,n,s]}return[t,r,n]};var ME=OE;const RE=(e,t,r)=>(r<0&&(r+=1),r>1&&(r-=1),r<1/6?e+(t-e)*6*r:r<1/2?t:r<2/3?e+(t-e)*(2/3-r)*6:e);var Sh=RE;const LE=We,zi=Sh,FE=(...e)=>{if(e=LE(e),e.length<3)throw new Error("values must contain H, S and L values");const t=e[0],r=e[1],n=e[2];let s=n,o=n,a=n;if(r!==0){const i=n<.5?n*(1+r):n+r-n*r,c=2*n-i;s=zi(c,i,t+1/3),o=zi(c,i,t),a=zi(c,i,t-1/3)}if(e.length>3){const i=e[3];return[s,o,a,i]}return[s,o,a]};var GE=FE;const NE=We,DE=(...e)=>{if(e=NE(e),e.length<3)throw new Error("values must contain H, S and V values");const t=e[0],r=e[1],n=e[2];let s=0,o=0,a=0;const i=Math.floor(t*6),c=t*6-i,l=n*(1-r),u=n*(1-c*r),d=n*(1-(1-c)*r);switch(i%6){case 0:s=n,o=d,a=l;break;case 1:s=u,o=n,a=l;break;case 2:s=l,o=n,a=d;break;case 3:s=l,o=u,a=n;break;case 4:s=d,o=l,a=n;break;case 5:s=n,o=l,a=u;break}if(e.length>3){const h=e[3];return[s,o,a,h]}return[s,o,a]};var kE=DE;const BE=We,IE=(...e)=>{if(e=BE(e),e.length<3)throw new Error("values must contain R, G and B values");const t=e[0]*255,r=e[1]*255,n=e[2]*255;let s=`#${Number(16777216+t*65536+r*256+n).toString(16).substring(1,7)}`;return e.length>3&&(s=s+Number(e[3]*255).toString(16)),s};var VE=IE;const zE=We,UE=(...e)=>{if(e=zE(e),e.length<3)throw new Error("values must contain R, G and B values");const t=e[0],r=e[1],n=e[2],s=Math.max(t,r,n),o=Math.min(t,r,n);let a,i;const c=(s+o)/2;if(s===o)a=i=0;else{const l=s-o;switch(i=c>.5?l/(2-s-o):l/(s+o),s){case t:a=(r-n)/l+(r<n?6:0);break;case r:a=(n-t)/l+2;break;case n:a=(t-r)/l+4;break}a/=6}if(e.length>3){const l=e[3];return[a,i,c,l]}return[a,i,c]};var qE=UE;const XE=We,jE=(...e)=>{if(e=XE(e),e.length<3)throw new Error("values must contain R, G and B values");const t=e[0],r=e[1],n=e[2],s=Math.max(t,r,n),o=Math.min(t,r,n);let a;const i=s,c=s-o,l=s===0?0:c/s;if(s===o)a=0;else{switch(s){case t:a=(r-n)/c+(r<n?6:0);break;case r:a=(n-t)/c+2;break;case n:a=(t-r)/c+4;break}a/=6}if(e.length>3){const u=e[3];return[a,l,i,u]}return[a,l,i]};var HE=jE,YE={colorize:AE,colorNameToRgb:CE,cssColors:Th,hexToRgb:ME,hslToRgb:GE,hsvToRgb:kE,hueToColorComponent:Sh,rgbToHex:VE,rgbToHsl:qE,rgbToHsv:HE};const WE=e=>{if(!Array.isArray(e))throw new Error("Bezier points must be a valid array/");if(e.length<2)throw new Error("Bezier points must contain at least 2 values.");const t=ZE(e);return{points:e,pointType:t,dimensions:t==="float_single"?0:e[0].length,permutations:eu(e.length-1),tangentPermutations:eu(e.length-2)}},ZE=function(e){let t=null;return e.forEach(r=>{let n="";if(Number.isFinite(r))n="float_single";else if(Array.isArray(r))r.forEach(s=>{if(!Number.isFinite(s))throw new Error("Bezier point values must all be numbers.")}),n="float_"+r.length;else throw new Error("Bezier points must all be numbers or arrays of number.");if(t==null)t=n;else if(t!==n)throw new Error("Bezier points must be either all numbers or all arrays of numbers of the same size.")}),t},eu=function(e){const t=[];for(let r=0;r<=e;r++)t.push(Ui(e)/(Ui(r)*Ui(e-r)));return t},Ui=function(e){let t=1;for(let r=2;r<=e;r++)t*=r;return t};var QE=WE;const KE=(e,t)=>{if(e<0||e>1)throw new Error("Bezier valueAt() input must be between 0 and 1");if(t.pointType==="float_single")return tu(t,t.points,e);{const r=[];for(let n=0;n<t.dimensions;n++){const s=[];for(let o=0;o<t.points.length;o++)s.push(t.points[o][n]);r.push(tu(t,s,e))}return r}},tu=function(e,t,r){const n=t.length-1;let s=0;for(let o=0;o<=n;o++)s+=e.permutations[o]*Math.pow(1-r,n-o)*Math.pow(r,o)*t[o];return s};var Ph=KE;const JE=(e,t)=>{if(e<0||e>1)throw new Error("Bezier tangentAt() input must be between 0 and 1");if(t.pointType==="float_single")return ru(t,t.points,e);{const r=[];for(let n=0;n<t.dimensions;n++){const s=[];for(let o=0;o<t.points.length;o++)s.push(t.points[o][n]);r.push(ru(t,s,e))}return r}},ru=function(e,t,r){const n=t.length-1;let s=0;for(let o=0;o<n;o++){const a=n*(t[o+1]-t[o]);s+=e.tangentPermutations[o]*Math.pow(1-r,n-1-o)*Math.pow(r,o)*a}return s};var e$=JE;const nu=Ph,t$=(e,t)=>{let r=0;const n=[0];let s=nu(0,t);for(let o=1;o<=e;o++){const a=nu(o/e,t);r+=r$(a,s),n.push(r),s=a}return n},r$=(e,t)=>{if(Number.isFinite(e)&&Number.isFinite(t))return Math.abs(e-t);if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)throw new Error("The operands must have the same number of dimensions.");let r=0;for(let n=0;n<e.length;n++)r+=(t[n]-e[n])*(t[n]-e[n]);return Math.sqrt(r)}else throw new Error("The operands must be of the same type, either number or array.")};var il=t$;const n$=il,s$=(e,t)=>n$(e,t)[e];var o$=s$;const a$=il,i$=(e,t)=>{const r={distance:0,segments:100},{distance:n,segments:s}=Object.assign({},r,e),o=a$(s,t);let a=0,i=s;for(;a<=i;){const p=Math.floor(a+(i-a)/2),E=o[p]-n;if(E<0)a=p+1;else if(E>0)i=p-1;else{i=p;break}}const c=i;if(o[c]===n)return c/s;const l=o[c],d=o[c+1]-l,h=(n-l)/d;return(c+h)/s};var c$=i$,l$={create:QE,valueAt:Ph,tangentAt:e$,lengths:il,length:o$,arcLengthToT:c$},f$={bezier:l$};const u$=e=>{let t=0;for(let r=0;r<e.length;r++){const n=(r+1)%e.length;t+=e[r][0]*e[n][1],t-=e[n][0]*e[r][1]}return t/2};var Sa=u$;const d$=Sa,h$=e=>d$(e.vertices);var Ch=h$;const m$=e=>((e===void 0||e.length<3)&&(e=[]),{vertices:e});var Oh=m$;const p$=Oh,v$=e=>{const t=e.vertices.slice().reverse();return p$(t)};var Mh=v$;const g$=Ch,y$=Mh,b$=(e,t)=>{if(e.length===0)return 0;const r=t.vertices;return r.length<3?0:(g$(t)<0&&(t=y$(t)),e.reduce((s,o)=>s+w$(o,r),0)===e.length?1:0)},w$=(e,t)=>{const r=t.length,n=e[0],s=e[1];let o=t[r-1],a=t[0],i=o[1]>s,c=0,l=0;for(let u=r+1;--u;){const d=a[1]>s;if(i!==d){const h=o[0]>n,p=a[0]>n;(h&&p||a[0]-(a[1]-s)*(o[0]-a[0])/(o[1]-a[1])>=n)&&(c=!c)}i=d,o=a,a=t[++l]}return c};var _$=b$,cl={arePointsInside:_$,create:Oh,flip:Mh,measureArea:Ch},ll={geom2:Qe,geom3:Ke,path2:ct,poly2:cl,poly3:ot};const x$=()=>[0,1,0];var fl=x$;const E$=fl,$$=e=>{const t=E$();return t[0]=e[0],t[1]=e[1],t[2]=e[2],t};var A$=$$;const qi=rt,T$=e=>{const t=qi.normal(qi.create(),e);return qi.negate(t,t),t};var ul=T$;const su=rt,S$=e=>su.scale(su.create(),e,e[2]);var Pa=S$;const Ps=rt,P$=ul,C$=Pa,O$=(e,t)=>{const r=C$(e),n=P$(e),s=Ps.subtract(Ps.create(),t,r),o=Ps.dot(s,n);return Ps.scale(s,n,o),Ps.add(s,s,r),s};var M$=O$;const R$=(e,t)=>(e[0]=t[0],e[1]=t[1],e[2]=t[2],e);var Rh=R$;const L$=rt,F$=(e,t)=>{let r=L$.dot(t,e);return r=Math.abs(r-e[2]),r};var G$=F$;const N$=(e,t)=>e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2];var D$=N$;const Cs=rt,k$=(e,t,r)=>{const n=Cs.subtract(Cs.create(),r,t);Cs.normal(n,n),Cs.normalize(n,n);const s=Cs.dot(t,n);return e[0]=n[0],e[1]=n[1],e[2]=s,e};var Lh=k$;const B$=fl,I$=(e,t,r)=>{const n=B$();return n[0]=e,n[1]=t,n[2]=r,n};var Fh=I$;const{NEPS:Xi}=st,V$=(e,t)=>Math.abs(e[0]-t[0])<=Xi&&Math.abs(e[1]-t[1])<=Xi&&Math.abs(e[2]-t[2])<=Xi;var dl=V$;const z$=(e,t,r)=>{let n=r-e[1],s=t[1]-e[1];s<0&&(n=-n,s=-s);let o;return n<=0?o=0:n>=s?o=1:s<1e-10?o=.5:o=n/s,e[0]+o*(t[0]-e[0])};var Gh=z$;const U$=(e,t,r,n)=>{if(e[0]===t[0]&&e[1]===t[1]||r[0]===n[0]&&r[1]===n[1])return;const s=(n[1]-r[1])*(t[0]-e[0])-(n[0]-r[0])*(t[1]-e[1]);if(Math.abs(s)<Number.MIN_VALUE)return;const o=((n[0]-r[0])*(e[1]-r[1])-(n[1]-r[1])*(e[0]-r[0]))/s,a=((t[0]-e[0])*(e[1]-r[1])-(t[1]-e[1])*(e[0]-r[0]))/s;if(o<0||o>1||a<0||a>1)return;const i=e[0]+o*(t[0]-e[0]),c=e[1]+o*(t[1]-e[1]);return[i,c]};var Nh=U$;const q$=(e,t,r,n,s,o)=>{const i=1/(e*n-t*r);let c=s*n-t*o,l=-s*r+e*o;return c*=i,l*=i,[c,l]};var X$=q$,Zs={aboutEqualNormals:dl,area:Sa,cos:Bt.cos,interpolateBetween2DPointsForY:Gh,intersect:Nh,sin:Bt.sin,solve2Linear:X$};const j$=rt,{solve2Linear:H$}=Zs,Y$=(e,t)=>{const r=H$(e[0],e[1],t[0],t[1],e[2],t[2]);return j$.clone(r)};var W$=Y$;const ou=rt,Z$=Rh,Q$=Fh,K$=(e,t)=>{const r=ou.negate(ou.create(),t),n=-t[2];return Z$(e,Q$(r[0],r[1],n))};var J$=K$;const eA=e=>`line2: (${e[0].toFixed(7)}, ${e[1].toFixed(7)}, ${e[2].toFixed(7)})`;var tA=eA;const au=rt,rA=Lh,nA=Pa,sA=ul,oA=(e,t,r)=>{const n=nA(t),s=sA(t);return au.transform(n,n,r),au.transform(s,s,r),rA(e,n,s)};var aA=oA;const iA=Pa,cA=(e,t)=>{let r=(e[2]-e[1]*t)/e[0];return Number.isNaN(r)&&(r=iA(e)[0]),r};var lA=cA,hl={clone:A$,closestPoint:M$,copy:Rh,create:fl,direction:ul,distanceToPoint:G$,equals:D$,fromPoints:Lh,fromValues:Fh,intersectPointOfLines:W$,origin:Pa,reverse:J$,toString:tA,transform:aA,xAtY:lA};const iu=Ie,fA=()=>[iu.fromValues(0,0,0),iu.fromValues(0,0,1)];var Dh=fA;const cu=Ie,uA=Dh,dA=e=>{const t=uA();return cu.copy(t[0],e[0]),cu.copy(t[1],e[1]),t};var hA=dA;const mn=Ie,mA=(e,t)=>{const r=e[0],n=e[1],s=mn.dot(mn.subtract(mn.create(),t,r),n),o=mn.dot(n,n),a=s/o,i=mn.scale(mn.create(),n,a);return mn.add(i,i,r),i};var kh=mA;const lu=Ie,pA=(e,t)=>(lu.copy(e[0],t[0]),lu.copy(e[1],t[1]),e);var vA=pA;const gA=e=>e[1];var yA=gA;const ji=Ie,bA=kh,wA=(e,t)=>{const r=bA(e,t),n=ji.subtract(ji.create(),t,r);return ji.length(n)};var _A=wA;const fu=Ie,xA=(e,t)=>!(!fu.equals(e[1],t[1])||!fu.equals(e[0],t[0]));var EA=xA;const ko=Ie,$A=(e,t,r)=>{const n=ko.normalize(ko.create(),r);return ko.copy(e[0],t),ko.copy(e[1],n),e};var Qs=$A;const pn=Ie,{solve2Linear:Hi}=Zs,{EPS:AA}=st,TA=Qs,SA=(e,t,r)=>{let n=pn.cross(pn.create(),t,r),s=pn.length(n);if(s<AA)throw new Error("parallel planes do not intersect");s=1/s,n=pn.scale(n,n,s);const o=Math.abs(n[0]),a=Math.abs(n[1]),i=Math.abs(n[2]);let c,l;return o>=a&&o>=i?(l=Hi(t[1],t[2],r[1],r[2],t[3],r[3]),c=pn.fromValues(0,l[0],l[1])):a>=o&&a>=i?(l=Hi(t[0],t[2],r[0],r[2],t[3],r[3]),c=pn.fromValues(l[0],0,l[1])):(l=Hi(t[0],t[1],r[0],r[1],t[3],r[3]),c=pn.fromValues(l[0],l[1],0)),TA(e,c,n)};var PA=SA;const uu=Ie,CA=Qs,OA=(e,t,r)=>{const n=uu.subtract(uu.create(),r,t);return CA(e,t,n)};var MA=OA;const In=Ie,RA=(e,t)=>{const r=t,n=t[3],s=e[0],o=e[1],a=(n-In.dot(r,s))/In.dot(r,o);return In.add(In.create(),s,In.scale(In.create(),o,a))};var LA=RA;const FA=e=>e[0];var GA=FA;const Yi=Ie,NA=Qs,DA=(e,t)=>{const r=Yi.clone(t[0]),n=Yi.negate(Yi.create(),t[1]);return NA(e,r,n)};var kA=DA;const BA=e=>{const t=e[0],r=e[1];return`line3: point: (${t[0].toFixed(7)}, ${t[1].toFixed(7)}, ${t[2].toFixed(7)}) direction: (${r[0].toFixed(7)}, ${r[1].toFixed(7)}, ${r[2].toFixed(7)})`};var IA=BA;const Vn=Ie,VA=Qs,zA=(e,t,r)=>{const n=t[0],s=t[1],o=Vn.add(Vn.create(),n,s),a=Vn.transform(Vn.create(),n,r),i=Vn.transform(o,o,r),c=Vn.subtract(i,i,a);return VA(e,a,c)};var UA=zA,qA={clone:hA,closestPoint:kh,copy:vA,create:Dh,direction:yA,distanceToPoint:_A,equals:EA,fromPlanes:PA,fromPointAndDirection:Qs,fromPoints:MA,intersectPointOfLineAndPlane:LA,origin:GA,reverse:kA,toString:IA,transform:UA},XA={constants:st,line2:hl,line3:qA,mat4:ft,plane:xr,utils:Zs,vec2:rt,vec3:Ie,vec4:vh};const jA=We,Bh=Qe,Ih=Ke,HA=ct,YA=ot,ua=new WeakMap,WA=()=>0,ZA=e=>{let t=ua.get(e);return t||(t=Bh.toSides(e).reduce((n,s)=>n+(s[0][0]*s[1][1]-s[0][1]*s[1][0]),0),t*=.5,ua.set(e,t),t)},QA=e=>{let t=ua.get(e);return t||(t=Ih.toPolygons(e).reduce((n,s)=>n+YA.measureArea(s),0),ua.set(e,t),t)},KA=(...e)=>{if(e=jA(e),e.length===0)throw new Error("wrong number of arguments");const t=e.map(r=>HA.isA(r)?WA():Bh.isA(r)?ZA(r):Ih.isA(r)?QA(r):0);return t.length===1?t[0]:t};var Vh=KA;const JA=We,e4=Vh,t4=(...e)=>{if(e=JA(e),e.length===0)throw new Error("measureAggregateArea: no geometries supplied");const t=e4(e);return e.length===1?t:t.reduce((n,s)=>n+s,0)};var r4=t4;const n4=We,_r=rt,Os=Ie,zh=Qe,Uh=Ke,qh=ct,du=ot,es=new WeakMap,s4=e=>{let t=es.get(e);if(t)return t;const r=qh.toPoints(e);let n;r.length===0?n=_r.create():n=_r.clone(r[0]);let s=_r.clone(n);return r.forEach(o=>{_r.min(n,n,o),_r.max(s,s,o)}),n=[n[0],n[1],0],s=[s[0],s[1],0],t=[n,s],es.set(e,t),t},o4=e=>{let t=es.get(e);if(t)return t;const r=zh.toPoints(e);let n;r.length===0?n=_r.create():n=_r.clone(r[0]);let s=_r.clone(n);return r.forEach(o=>{_r.min(n,n,o),_r.max(s,s,o)}),n=[n[0],n[1],0],s=[s[0],s[1],0],t=[n,s],es.set(e,t),t},a4=e=>{let t=es.get(e);if(t)return t;const r=Uh.toPolygons(e);let n=Os.create();if(r.length>0){const o=du.toPoints(r[0]);Os.copy(n,o[0])}let s=Os.clone(n);return r.forEach(o=>{du.toPoints(o).forEach(a=>{Os.min(n,n,a),Os.max(s,s,a)})}),n=[n[0],n[1],n[2]],s=[s[0],s[1],s[2]],t=[n,s],es.set(e,t),t},i4=(...e)=>{if(e=n4(e),e.length===0)throw new Error("wrong number of arguments");const t=e.map(r=>qh.isA(r)?s4(r):zh.isA(r)?o4(r):Uh.isA(r)?a4(r):[[0,0,0],[0,0,0]]);return t.length===1?t[0]:t};var En=i4;const c4=We,l4=Wd,f4=Yd,u4=En,d4=(...e)=>{if(e=c4(e),e.length===0)throw new Error("measureAggregateBoundingBox: no geometries supplied");const t=u4(e);if(e.length===1)return t;const r=[[Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE],[-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE]];return t.reduce((n,s)=>(n=[l4(n[0],n[0],s[0]),f4(n[1],n[1],s[1])],n),r)};var ml=d4;const{EPS:h4}=st,m4=(e,t)=>{let r=0;for(let n=0;n<t;n++)r+=e[1][n]-e[0][n];return h4*r/t};var Xh=m4;const p4=We,v4=ml,g4=Xh,{geom2:y4,geom3:b4,path2:w4}=ll,_4=(...e)=>{if(e=p4(e),e.length===0)throw new Error("measureAggregateEpsilon: no geometries supplied");const t=v4(e);let r=0;return r=e.reduce((n,s)=>w4.isA(s)||y4.isA(s)?Math.max(n,2):b4.isA(s)?Math.max(n,3):0,r),g4(t,r)};var x4=_4;const E4=We,$4=Qe,jh=Ke,A4=ct,T4=ot,hu=new WeakMap,S4=()=>0,P4=()=>0,C4=e=>{let t=hu.get(e);return t||(t=jh.toPolygons(e).reduce((n,s)=>n+T4.measureSignedVolume(s),0),hu.set(e,t),t)},O4=(...e)=>{if(e=E4(e),e.length===0)throw new Error("wrong number of arguments");const t=e.map(r=>A4.isA(r)?S4():$4.isA(r)?P4():jh.isA(r)?C4(r):0);return t.length===1?t[0]:t};var Hh=O4;const M4=We,R4=Hh,L4=(...e)=>{if(e=M4(e),e.length===0)throw new Error("measureAggregateVolume: no geometries supplied");const t=R4(e);return e.length===1?t:t.reduce((n,s)=>n+s,0)};var F4=L4;const G4=We,Yh=rt,Yt=Ie,Wh=Qe,Zh=Ke,Qh=ct,mu=ot,ts=new WeakMap,N4=e=>{let t=ts.get(e);if(t!==void 0)return t;const r=Yt.create();let n=0;const s=Qh.toPoints(e);if(s.length>0){let o=0;const a=Yt.create();s.forEach(i=>{Yt.add(r,r,Yt.fromVec2(a,i,0)),o++}),Yt.scale(r,r,1/o),s.forEach(i=>{n=Math.max(n,Yh.squaredDistance(r,i))}),n=Math.sqrt(n)}return t=[r,n],ts.set(e,t),t},D4=e=>{let t=ts.get(e);if(t!==void 0)return t;const r=Yt.create();let n=0;const s=Wh.toSides(e);if(s.length>0){let o=0;const a=Yt.create();s.forEach(i=>{Yt.add(r,r,Yt.fromVec2(a,i[0],0)),o++}),Yt.scale(r,r,1/o),s.forEach(i=>{n=Math.max(n,Yh.squaredDistance(r,i[0]))}),n=Math.sqrt(n)}return t=[r,n],ts.set(e,t),t},k4=e=>{let t=ts.get(e);if(t!==void 0)return t;const r=Yt.create();let n=0;const s=Zh.toPolygons(e);if(s.length>0){let o=0;s.forEach(a=>{mu.toPoints(a).forEach(i=>{Yt.add(r,r,i),o++})}),Yt.scale(r,r,1/o),s.forEach(a=>{mu.toPoints(a).forEach(i=>{n=Math.max(n,Yt.squaredDistance(r,i))})}),n=Math.sqrt(n)}return t=[r,n],ts.set(e,t),t},B4=(...e)=>{e=G4(e);const t=e.map(r=>Qh.isA(r)?N4(r):Wh.isA(r)?D4(r):Zh.isA(r)?k4(r):[[0,0,0],0]);return t.length===1?t[0]:t};var I4=B4;const V4=We,z4=En,U4=(...e)=>{e=V4(e);const t=e.map(r=>{const n=z4(r);return[n[0][0]+(n[1][0]-n[0][0])/2,n[0][1]+(n[1][1]-n[0][1])/2,n[0][2]+(n[1][2]-n[0][2])/2]});return t.length===1?t[0]:t};var q4=U4;const X4=We,wr=Ie,Kh=Qe,Jh=Ke,da=new WeakMap,j4=e=>{let t=da.get(e);if(t!==void 0)return t;const r=Kh.toSides(e);let n=0,s=0,o=0;if(r.length>0){for(let i=0;i<r.length;i++){const c=r[i][0],l=r[i][1],u=c[0]*l[1]-c[1]*l[0];n+=u,s+=(c[0]+l[0])*u,o+=(c[1]+l[1])*u}n/=2;const a=1/(n*6);s*=a,o*=a}return t=wr.fromValues(s,o,0),da.set(e,t),t},H4=e=>{let t=da.get(e);if(t!==void 0)return t;t=wr.create();const r=Jh.toPolygons(e);if(r.length===0)return t;let n=0;const s=wr.create();return r.forEach(o=>{const a=o.vertices;for(let i=0;i<a.length-2;i++){wr.cross(s,a[i+1],a[i+2]);const c=wr.dot(a[0],s)/6;n+=c,wr.add(s,a[0],a[i+1]),wr.add(s,s,a[i+2]);const l=wr.scale(s,s,1/4*c);wr.add(t,t,l)}}),wr.scale(t,t,1/n),da.set(e,t),t},Y4=(...e)=>{e=X4(e);const t=e.map(r=>Kh.isA(r)?j4(r):Jh.isA(r)?H4(r):[0,0,0]);return t.length===1?t[0]:t};var W4=Y4;const Z4=We,Q4=En,K4=(...e)=>{e=Z4(e);const t=e.map(r=>{const n=Q4(r);return[n[1][0]-n[0][0],n[1][1]-n[0][1],n[1][2]-n[0][2]]});return t.length===1?t[0]:t};var J4=K4;const eT=We,{geom2:tT,geom3:rT,path2:nT}=ll,pl=Xh,vl=En,sT=e=>pl(vl(e),2),oT=e=>pl(vl(e),2),aT=e=>pl(vl(e),3),iT=(...e)=>{if(e=eT(e),e.length===0)throw new Error("wrong number of arguments");const t=e.map(r=>nT.isA(r)?sT(r):tT.isA(r)?oT(r):rT.isA(r)?aT(r):0);return t.length===1?t[0]:t};var Zr=iT,cT={measureAggregateArea:r4,measureAggregateBoundingBox:ml,measureAggregateEpsilon:x4,measureAggregateVolume:F4,measureArea:Vh,measureBoundingBox:En,measureBoundingSphere:I4,measureCenter:q4,measureCenterOfMass:W4,measureDimensions:J4,measureEpsilon:Zr,measureVolume:Hh};const lT=(e,t)=>Array.isArray(e)&&e.length>=t?e.every(r=>Number.isFinite(r)):!1,fT=(e,t)=>Number.isFinite(e)&&e>t,uT=(e,t)=>Number.isFinite(e)&&e>=t;var Mt={isNumberArray:lT,isGT:fT,isGTE:uT};const{EPS:pu,TAU:zn}=st,Sr=rt,dT=ct,{isGT:hT,isGTE:Wi,isNumberArray:mT}=Mt,pT=e=>{const t={center:[0,0],radius:1,startAngle:0,endAngle:zn,makeTangent:!1,segments:32};let{center:r,radius:n,startAngle:s,endAngle:o,makeTangent:a,segments:i}=Object.assign({},t,e);if(!mT(r,2))throw new Error("center must be an array of X and Y values");if(!hT(n,0))throw new Error("radius must be greater than zero");if(!Wi(s,0))throw new Error("startAngle must be positive");if(!Wi(o,0))throw new Error("endAngle must be positive");if(!Wi(i,4))throw new Error("segments must be four or more");s=s%zn,o=o%zn;let c=zn;s<o&&(c=o-s),s>o&&(c=o+(zn-s));const l=Math.acos((n*n+n*n-pu*pu)/(2*n*n)),u=Sr.clone(r);let d;const h=[];if(c<l)d=Sr.fromAngleRadians(Sr.create(),s),Sr.scale(d,d,n),Sr.add(d,d,u),h.push(d);else{const p=Math.max(1,Math.floor(i*(c/zn)))+1;let E=p*.5/c;E>.25&&(E=.25);const g=a?p+2:p;for(let b=0;b<=g;b++){let S=b;a&&(S=(b-1)*(p-2*E)/p+E,S<0&&(S=0),S>p&&(S=p));const G=s+S*(c/p);d=Sr.fromAngleRadians(Sr.create(),G),Sr.scale(d,d,n),Sr.add(d,d,u),h.push(d)}}return dT.fromPoints({closed:!1},h)};var vT=pT;const{EPS:vu,TAU:Ir}=st,Zi=rt,gu=Qe,{sin:gT,cos:yT}=Bt,{isGTE:Qi,isNumberArray:yu}=Mt,bT=e=>{const t={center:[0,0],radius:[1,1],startAngle:0,endAngle:Ir,segments:32};let{center:r,radius:n,startAngle:s,endAngle:o,segments:a}=Object.assign({},t,e);if(!yu(r,2))throw new Error("center must be an array of X and Y values");if(!yu(n,2))throw new Error("radius must be an array of X and Y values");if(!n.every(p=>p>=0))throw new Error("radius values must be positive");if(!Qi(s,0))throw new Error("startAngle must be positive");if(!Qi(o,0))throw new Error("endAngle must be positive");if(!Qi(a,3))throw new Error("segments must be three or more");if(n[0]===0||n[1]===0)return gu.create();s=s%Ir,o=o%Ir;let i=Ir;s<o&&(i=o-s),s>o&&(i=o+(Ir-s));const c=Math.min(n[0],n[1]),l=Math.acos((c*c+c*c-vu*vu)/(2*c*c));if(i<l)throw new Error("startAngle and endAngle do not define a significant rotation");a=Math.floor(a*(i/Ir));const u=Zi.clone(r),d=i/a,h=[];a=i<Ir?a+1:a;for(let p=0;p<a;p++){const E=d*p+s,g=Zi.fromValues(n[0]*yT(E),n[1]*gT(E));Zi.add(g,u,g),h.push(g)}return i<Ir&&h.push(u),gu.fromPoints(h)};var em=bT;const{TAU:wT}=st,_T=em,{isGTE:xT}=Mt,ET=e=>{const t={center:[0,0],radius:1,startAngle:0,endAngle:wT,segments:32};let{center:r,radius:n,startAngle:s,endAngle:o,segments:a}=Object.assign({},t,e);if(!xT(n,0))throw new Error("radius must be positive");return n=[n,n],_T({center:r,radius:n,startAngle:s,endAngle:o,segments:a})};var tm=ET;const bu=Ke,$T=ot,{isNumberArray:wu}=Mt,AT=e=>{const t={center:[0,0,0],size:[2,2,2]},{center:r,size:n}=Object.assign({},t,e);if(!wu(r,3))throw new Error("center must be an array of X, Y and Z values");if(!wu(n,3))throw new Error("size must be an array of width, depth and height values");if(!n.every(o=>o>=0))throw new Error("size values must be positive");return n[0]===0||n[1]===0||n[2]===0?bu.create():bu.create([[[0,4,6,2],[-1,0,0]],[[1,3,7,5],[1,0,0]],[[0,1,5,4],[0,-1,0]],[[2,6,7,3],[0,1,0]],[[0,2,3,1],[0,0,-1]],[[4,5,7,6],[0,0,1]]].map(o=>{const a=o[0].map(i=>[r[0]+n[0]/2*(2*!!(i&1)-1),r[1]+n[1]/2*(2*!!(i&2)-1),r[2]+n[2]/2*(2*!!(i&4)-1)]);return $T.create(a)}))};var gl=AT;const TT=gl,{isGTE:ST}=Mt,PT=e=>{const t={center:[0,0,0],size:2};let{center:r,size:n}=Object.assign({},t,e);if(!ST(n,0))throw new Error("size must be positive");return n=[n,n,n],TT({center:r,size:n})};var CT=PT;const{EPS:_u,TAU:Vr}=st,Dt=Ie,OT=Ke,MT=ot,{sin:RT,cos:LT}=Bt,{isGT:FT,isGTE:Ki,isNumberArray:Ji}=Mt,GT=e=>{const t={center:[0,0,0],height:2,startRadius:[1,1],startAngle:0,endRadius:[1,1],endAngle:Vr,segments:32};let{center:r,height:n,startRadius:s,startAngle:o,endRadius:a,endAngle:i,segments:c}=Object.assign({},t,e);if(!Ji(r,3))throw new Error("center must be an array of X, Y and Z values");if(!FT(n,0))throw new Error("height must be greater then zero");if(!Ji(s,2))throw new Error("startRadius must be an array of X and Y values");if(!s.every(oe=>oe>=0))throw new Error("startRadius values must be positive");if(!Ji(a,2))throw new Error("endRadius must be an array of X and Y values");if(!a.every(oe=>oe>=0))throw new Error("endRadius values must be positive");if(a.every(oe=>oe===0)&&s.every(oe=>oe===0))throw new Error("at least one radius must be positive");if(!Ki(o,0))throw new Error("startAngle must be positive");if(!Ki(i,0))throw new Error("endAngle must be positive");if(!Ki(c,4))throw new Error("segments must be four or more");o=o%Vr,i=i%Vr;let l=Vr;o<i&&(l=i-o),o>i&&(l=i+(Vr-o));const u=Math.min(s[0],s[1],a[0],a[1]),d=Math.acos((u*u+u*u-_u*_u)/(2*u*u));if(l<d)throw new Error("startAngle and endAngle do not define a significant rotation");const h=Math.floor(c*(l/Vr)),p=Dt.fromValues(0,0,-(n/2)),E=Dt.fromValues(0,0,n/2),g=Dt.subtract(Dt.create(),E,p),b=Dt.fromValues(1,0,0),S=Dt.fromValues(0,1,0),G=Dt.create(),R=Dt.create(),M=Dt.create(),F=(oe,pe,Q)=>{const Se=pe*l+o;return Dt.scale(G,b,Q[0]*LT(Se)),Dt.scale(R,S,Q[1]*RT(Se)),Dt.add(G,G,R),Dt.scale(M,g,oe),Dt.add(M,M,p),Dt.add(Dt.create(),G,M)},L=(...oe)=>{const pe=oe.map(Q=>Dt.add(Dt.create(),Q,r));return MT.create(pe)},U=[];for(let oe=0;oe<h;oe++){const pe=oe/h;let Q=(oe+1)/h;l===Vr&&oe===h-1&&(Q=0),a[0]===s[0]&&a[1]===s[1]?(U.push(L(p,F(0,Q,a),F(0,pe,a))),U.push(L(F(0,Q,a),F(1,Q,a),F(1,pe,a),F(0,pe,a))),U.push(L(E,F(1,pe,a),F(1,Q,a)))):(s[0]>0&&s[1]>0&&U.push(L(p,F(0,Q,s),F(0,pe,s))),(s[0]>0||s[1]>0)&&U.push(L(F(0,pe,s),F(0,Q,s),F(1,pe,a))),a[0]>0&&a[1]>0&&U.push(L(E,F(1,pe,a),F(1,Q,a))),(a[0]>0||a[1]>0)&&U.push(L(F(1,pe,a),F(0,Q,s),F(1,Q,a))))}return l<Vr&&(U.push(L(p,F(0,0,s),E)),U.push(L(F(0,0,s),F(1,0,a),E)),U.push(L(p,E,F(0,1,s))),U.push(L(F(0,1,s),E,F(1,1,a)))),OT.create(U)};var rm=GT;const NT=Ke,DT=rm,{isGTE:kT}=Mt,BT=e=>{const t={center:[0,0,0],height:2,radius:1,segments:32},{center:r,height:n,radius:s,segments:o}=Object.assign({},t,e);if(!kT(s,0))throw new Error("radius must be positive");return n===0||s===0?NT.create():DT({center:r,height:n,startRadius:[s,s],endRadius:[s,s],segments:o})};var nm=BT;const{TAU:xu}=st,ze=Ie,Eu=Ke,$u=ot,{sin:Au,cos:Tu}=Bt,{isGTE:IT,isNumberArray:Su}=Mt,VT=e=>{const t={center:[0,0,0],radius:[1,1,1],segments:32,axes:[[1,0,0],[0,-1,0],[0,0,1]]},{center:r,radius:n,segments:s,axes:o}=Object.assign({},t,e);if(!Su(r,3))throw new Error("center must be an array of X, Y and Z values");if(!Su(n,3))throw new Error("radius must be an array of X, Y and Z values");if(!n.every(E=>E>=0))throw new Error("radius values must be positive");if(!IT(s,4))throw new Error("segments must be four or more");if(n[0]===0||n[1]===0||n[2]===0)return Eu.create();const a=ze.scale(ze.create(),ze.normalize(ze.create(),o[0]),n[0]),i=ze.scale(ze.create(),ze.normalize(ze.create(),o[1]),n[1]),c=ze.scale(ze.create(),ze.normalize(ze.create(),o[2]),n[2]),l=Math.round(s/4);let u;const d=[],h=ze.create(),p=ze.create();for(let E=0;E<=s;E++){const g=xu*E/s,b=ze.add(ze.create(),ze.scale(h,a,Tu(g)),ze.scale(p,i,Au(g)));if(E>0){let S,G;for(let R=0;R<=l;R++){const M=xu/4*R/l,F=Tu(M),L=Au(M);if(R>0){let U=[],ee;ee=ze.subtract(ze.create(),ze.scale(h,u,S),ze.scale(p,c,G)),U.push(ze.add(ee,ee,r)),ee=ze.subtract(ze.create(),ze.scale(h,b,S),ze.scale(p,c,G)),U.push(ze.add(ee,ee,r)),R<l&&(ee=ze.subtract(ze.create(),ze.scale(h,b,F),ze.scale(p,c,L)),U.push(ze.add(ee,ee,r))),ee=ze.subtract(ze.create(),ze.scale(h,u,F),ze.scale(p,c,L)),U.push(ze.add(ee,ee,r)),d.push($u.create(U)),U=[],ee=ze.add(ze.create(),ze.scale(h,u,S),ze.scale(p,c,G)),U.push(ze.add(ze.create(),r,ee)),ee=ze.add(ee,ze.scale(h,b,S),ze.scale(p,c,G)),U.push(ze.add(ze.create(),r,ee)),R<l&&(ee=ze.add(ee,ze.scale(h,b,F),ze.scale(p,c,L)),U.push(ze.add(ze.create(),r,ee))),ee=ze.add(ee,ze.scale(h,u,F),ze.scale(p,c,L)),U.push(ze.add(ze.create(),r,ee)),U.reverse(),d.push($u.create(U))}S=F,G=L}}u=b}return Eu.create(d)};var sm=VT;const zT=Ke,UT=ot,{isNumberArray:Pu}=Mt,qT=e=>{const t={points:[],faces:[],colors:void 0,orientation:"outward"},{points:r,faces:n,colors:s,orientation:o}=Object.assign({},t,e);if(!(Array.isArray(r)&&Array.isArray(n)))throw new Error("points and faces must be arrays");if(r.length<3)throw new Error("three or more points are required");if(n.length<1)throw new Error("one or more faces are required");if(s){if(!Array.isArray(s))throw new Error("colors must be an array");if(s.length!==n.length)throw new Error("faces and colors must have the same length")}r.forEach((i,c)=>{if(!Pu(i,3))throw new Error(`point ${c} must be an array of X, Y, Z values`)}),n.forEach((i,c)=>{if(i.length<3)throw new Error(`face ${c} must contain 3 or more indexes`);if(!Pu(i,i.length))throw new Error(`face ${c} must be an array of numbers`)}),o!=="outward"&&n.forEach(i=>i.reverse());const a=n.map((i,c)=>{const l=UT.create(i.map(u=>r[u]));return s&&s[c]&&(l.color=s[c]),l});return zT.create(a)};var om=qT;const Cu=ft,Ou=Ie,Mu=Ke,XT=om,{isGTE:Ru}=Mt,jT=e=>{const t={radius:1,frequency:6};let{radius:r,frequency:n}=Object.assign({},t,e);if(!Ru(r,0))throw new Error("radius must be positive");if(!Ru(n,6))throw new Error("frequency must be six or more");if(r===0)return Mu.create();n=Math.floor(n/6);const s=[[.850651,0,-.525731],[.850651,-0,.525731],[-.850651,-0,.525731],[-.850651,0,-.525731],[0,-.525731,.850651],[0,.525731,.850651],[0,.525731,-.850651],[0,-.525731,-.850651],[-.525731,-.850651,-0],[.525731,-.850651,-0],[.525731,.850651,0],[-.525731,.850651,0]],o=[[0,9,1],[1,10,0],[6,7,0],[10,6,0],[7,9,0],[5,1,4],[4,1,9],[5,10,1],[2,8,3],[3,11,2],[2,5,4],[4,8,2],[2,11,5],[3,7,6],[6,11,3],[8,7,3],[9,8,4],[11,10,5],[10,11,6],[8,9,7]],a=(h,p,E)=>{const g=h[0],b=h[1],S=h[2];let G=E;const R=[],M=[];for(let F=0;F<p;F++)for(let L=0;L<p-F;L++){const U=F/p,ee=(F+1)/p,oe=L/(p-F),pe=(L+1)/(p-F),Q=p-F-1?L/(p-F-1):1,Se=[];Se[0]=i(i(g,b,oe),S,U),Se[1]=i(i(g,b,pe),S,U),Se[2]=i(i(g,b,Q),S,ee);for(let qe=0;qe<3;qe++){const $e=Ou.length(Se[qe]);for(let Xe=0;Xe<3;Xe++)Se[qe][Xe]/=$e}if(R.push(Se[0],Se[1],Se[2]),M.push([G,G+1,G+2]),G+=3,L<p-F-1){const qe=p-F-1?(L+1)/(p-F-1):1;Se[0]=i(i(g,b,pe),S,U),Se[1]=i(i(g,b,qe),S,ee),Se[2]=i(i(g,b,Q),S,ee);for(let $e=0;$e<3;$e++){const Xe=Ou.length(Se[$e]);for(let Ne=0;Ne<3;Ne++)Se[$e][Ne]/=Xe}R.push(Se[0],Se[1],Se[2]),M.push([G,G+1,G+2]),G+=3}}return{points:R,triangles:M,offset:G}},i=(h,p,E)=>{const g=1-E,b=[];for(let S=0;S<3;S++)b[S]=h[S]*g+p[S]*E;return b};let c=[],l=[],u=0;for(let h=0;h<o.length;h++){const p=a([s[o[h][0]],s[o[h][1]],s[o[h][2]]],n,u);c=c.concat(p.points),l=l.concat(p.triangles),u=p.offset}let d=XT({points:c,faces:l,orientation:"inward"});return r!==1&&(d=Mu.transform(Cu.fromScaling(Cu.create(),[r,r,r]),d)),d};var HT=jT;const YT=ct,WT=e=>{if(!Array.isArray(e))throw new Error("points must be an array");return YT.fromPoints({},e)};var ZT=WT;const Bo=Qe,QT=e=>{const t={points:[],paths:[],orientation:"counterclockwise"},{points:r,paths:n,orientation:s}=Object.assign({},t,e);if(!(Array.isArray(r)&&Array.isArray(n)))throw new Error("points and paths must be arrays");let o=r;Array.isArray(r[0])&&(Array.isArray(r[0][0])||(o=[r])),o.forEach((u,d)=>{if(!Array.isArray(u))throw new Error("list of points "+d+" must be an array");if(u.length<3)throw new Error("list of points "+d+" must contain three or more points");u.forEach((h,p)=>{if(!Array.isArray(h))throw new Error("list of points "+d+", point "+p+" must be an array");if(h.length<2)throw new Error("list of points "+d+", point "+p+" must contain by X and Y values")})});let a=n;if(n.length===0){let u=0;a=o.map(d=>d.map(h=>u++))}const i=[];o.forEach(u=>u.forEach(d=>i.push(d)));let c=[];a.forEach(u=>{const d=u.map(p=>i[p]),h=Bo.fromPoints(d);c=c.concat(Bo.toSides(h))});let l=Bo.create(c);return s=="clockwise"&&(l=Bo.reverse(l)),l};var KT=QT;const zr=rt,Lu=Qe,{isNumberArray:Fu}=Mt,JT=e=>{const t={center:[0,0],size:[2,2]},{center:r,size:n}=Object.assign({},t,e);if(!Fu(r,2))throw new Error("center must be an array of X and Y values");if(!Fu(n,2))throw new Error("size must be an array of X and Y values");if(!n.every(i=>i>=0))throw new Error("size values must be positive");if(n[0]===0||n[1]===0)return Lu.create();const s=[n[0]/2,n[1]/2],o=[s[0],-s[1]],a=[zr.subtract(zr.create(),r,s),zr.add(zr.create(),r,o),zr.add(zr.create(),r,s),zr.subtract(zr.create(),r,o)];return Lu.fromPoints(a)};var yl=JT;const{EPS:ia,TAU:Ms}=st,ec=rt,At=Ie,Gu=Ke,rs=ot,{sin:eS,cos:tS}=Bt,{isGTE:Nu,isNumberArray:Du}=Mt,rS=gl,ku=(e,t,r,n,s,o)=>{const a=Ms/4*s/n,i=tS(a),c=eS(a),l=n-s;let u=r*i,d=t[2]-(r-r*c);o||(d=r-r*c-t[2]),u=u>ia?u:0;const h=At.add(At.create(),e,[t[0]-r,t[1]-r,d]),p=At.add(At.create(),e,[r-t[0],t[1]-r,d]),E=At.add(At.create(),e,[r-t[0],r-t[1],d]),g=At.add(At.create(),e,[t[0]-r,r-t[1],d]),b=[],S=[],G=[],R=[];for(let M=0;M<=l;M++){const F=l>0?Ms/4*M/l:0,L=ec.fromAngleRadians(ec.create(),F);ec.scale(L,L,u);const U=At.fromVec2(At.create(),L);b.push(At.add(At.create(),h,U)),At.rotateZ(U,U,[0,0,0],Ms/4),S.push(At.add(At.create(),p,U)),At.rotateZ(U,U,[0,0,0],Ms/4),G.push(At.add(At.create(),E,U)),At.rotateZ(U,U,[0,0,0],Ms/4),R.push(At.add(At.create(),g,U))}return o?[b,S,G,R]:(b.reverse(),S.reverse(),G.reverse(),R.reverse(),[R,G,S,b])},Bu=(e,t)=>{const r=[];for(let n=0;n<e.length;n++){const s=e[n],o=t[n];for(let a=0;a<s.length-1;a++)r.push(rs.create([s[a],s[a+1],o[a]])),a<o.length-1&&r.push(rs.create([o[a],s[a+1],o[a+1]]))}return r},Iu=(e,t)=>{const r=[];for(let n=0;n<e.length;n++){let s=e[n],o=t[n];const a=s[s.length-1],i=o[o.length-1],c=(n+1)%e.length;s=e[c],o=t[c];const l=s[0],u=o[0];r.push(rs.create([a,l,u,i]))}return r},nS=(e,t)=>{e=[e[3],e[2],e[1],e[0]],e=e.map(o=>o.slice().reverse());const r=[];e.forEach(o=>{o.forEach(a=>r.push(a))});const n=[];t.forEach(o=>{o.forEach(a=>n.push(a))});const s=[];for(let o=0;o<n.length;o++){const a=(o+1)%n.length;s.push(rs.create([r[o],r[a],n[a],n[o]]))}return s},sS=e=>{const t={center:[0,0,0],size:[2,2,2],roundRadius:.2,segments:32};let{center:r,size:n,roundRadius:s,segments:o}=Object.assign({},t,e);if(!Du(r,3))throw new Error("center must be an array of X, Y and Z values");if(!Du(n,3))throw new Error("size must be an array of X, Y and Z values");if(!n.every(l=>l>=0))throw new Error("size values must be positive");if(!Nu(s,0))throw new Error("roundRadius must be positive");if(!Nu(o,4))throw new Error("segments must be four or more");if(n[0]===0||n[1]===0||n[2]===0)return Gu.create();if(s===0)return rS({center:r,size:n});if(n=n.map(l=>l/2),s>n[0]-ia||s>n[1]-ia||s>n[2]-ia)throw new Error("roundRadius must be smaller then the radius of all dimensions");o=Math.floor(o/4);let a=null,i=null,c=[];for(let l=0;l<=o;l++){const u=ku(r,n,s,o,l,!0),d=ku(r,n,s,o,l,!1);if(l===0&&(c=c.concat(nS(d,u))),a&&(c=c.concat(Bu(a,u),Iu(a,u))),i&&(c=c.concat(Bu(i,d),Iu(i,d))),l===o){let h=u.map(p=>p[0]);c.push(rs.create(h)),h=d.map(p=>p[0]),c.push(rs.create(h))}a=u,i=d}return Gu.create(c)};var oS=sS;const{EPS:aS,TAU:Vu}=st,Re=Ie,zu=Ke,iS=ot,{sin:Uu,cos:qu}=Bt,{isGTE:Io,isNumberArray:cS}=Mt,lS=nm,fS=e=>{const t={center:[0,0,0],height:2,radius:1,roundRadius:.2,segments:32},{center:r,height:n,radius:s,roundRadius:o,segments:a}=Object.assign({},t,e);if(!cS(r,3))throw new Error("center must be an array of X, Y and Z values");if(!Io(n,0))throw new Error("height must be positive");if(!Io(s,0))throw new Error("radius must be positive");if(!Io(o,0))throw new Error("roundRadius must be positive");if(o>s)throw new Error("roundRadius must be smaller then the radius");if(!Io(a,4))throw new Error("segments must be four or more");if(n===0||s===0)return zu.create();if(o===0)return lS({center:r,height:n,radius:s});const i=[0,0,-(n/2)],c=[0,0,n/2],l=Re.subtract(Re.create(),c,i),u=Re.length(l);if(2*o>u-aS)throw new Error("height must be larger than twice roundRadius");let d;Math.abs(l[0])>Math.abs(l[1])?d=Re.fromValues(0,1,0):d=Re.fromValues(1,0,0);const h=Re.scale(Re.create(),Re.normalize(Re.create(),l),o),p=Re.scale(Re.create(),Re.normalize(Re.create(),Re.cross(Re.create(),h,d)),s),E=Re.scale(Re.create(),Re.normalize(Re.create(),Re.cross(Re.create(),p,h)),s);Re.add(i,i,h),Re.subtract(c,c,h);const g=Math.floor(.25*a),b=L=>{const U=L.map(ee=>Re.add(ee,ee,r));return iS.create(U)},S=[],G=Re.create(),R=Re.create();let M;for(let L=0;L<=a;L++){const U=Vu*L/a,ee=Re.add(Re.create(),Re.scale(G,p,qu(U)),Re.scale(R,E,Uu(U)));if(L>0){let oe=[];oe.push(Re.add(Re.create(),i,ee)),oe.push(Re.add(Re.create(),i,M)),oe.push(Re.add(Re.create(),c,M)),oe.push(Re.add(Re.create(),c,ee)),S.push(b(oe));let pe,Q;for(let Se=0;Se<=g;Se++){const qe=Vu/4*Se/g,$e=qu(qe),Xe=Uu(qe);if(Se>0){oe=[];let Ne;Ne=Re.add(Re.create(),i,Re.subtract(G,Re.scale(G,M,pe),Re.scale(R,h,Q))),oe.push(Ne),Ne=Re.add(Re.create(),i,Re.subtract(G,Re.scale(G,ee,pe),Re.scale(R,h,Q))),oe.push(Ne),Se<g&&(Ne=Re.add(Re.create(),i,Re.subtract(G,Re.scale(G,ee,$e),Re.scale(R,h,Xe))),oe.push(Ne)),Ne=Re.add(Re.create(),i,Re.subtract(G,Re.scale(G,M,$e),Re.scale(R,h,Xe))),oe.push(Ne),S.push(b(oe)),oe=[],Ne=Re.add(Re.create(),Re.scale(G,M,pe),Re.scale(R,h,Q)),Re.add(Ne,Ne,c),oe.push(Ne),Ne=Re.add(Re.create(),Re.scale(G,ee,pe),Re.scale(R,h,Q)),Re.add(Ne,Ne,c),oe.push(Ne),Se<g&&(Ne=Re.add(Re.create(),Re.scale(G,ee,$e),Re.scale(R,h,Xe)),Re.add(Ne,Ne,c),oe.push(Ne)),Ne=Re.add(Re.create(),Re.scale(G,M,$e),Re.scale(R,h,Xe)),Re.add(Ne,Ne,c),oe.push(Ne),oe.reverse(),S.push(b(oe))}pe=$e,Q=Xe}}M=ee}return zu.create(S)};var uS=fS;const{EPS:Xu,TAU:Vo}=st,pt=rt,ju=Qe,{isGTE:Hu,isNumberArray:Yu}=Mt,dS=yl,hS=e=>{const t={center:[0,0],size:[2,2],roundRadius:.2,segments:32};let{center:r,size:n,roundRadius:s,segments:o}=Object.assign({},t,e);if(!Yu(r,2))throw new Error("center must be an array of X and Y values");if(!Yu(n,2))throw new Error("size must be an array of X and Y values");if(!n.every(g=>g>=0))throw new Error("size values must be positive");if(!Hu(s,0))throw new Error("roundRadius must be positive");if(!Hu(o,4))throw new Error("segments must be four or more");if(n[0]===0||n[1]===0)return ju.create();if(s===0)return dS({center:r,size:n});if(n=n.map(g=>g/2),s>n[0]-Xu||s>n[1]-Xu)throw new Error("roundRadius must be smaller then the radius of all dimensions");const a=Math.floor(o/4),i=pt.add(pt.create(),r,[n[0]-s,n[1]-s]),c=pt.add(pt.create(),r,[s-n[0],n[1]-s]),l=pt.add(pt.create(),r,[s-n[0],s-n[1]]),u=pt.add(pt.create(),r,[n[0]-s,s-n[1]]),d=[],h=[],p=[],E=[];for(let g=0;g<=a;g++){const b=Vo/4*g/a,S=pt.fromAngleRadians(pt.create(),b);pt.scale(S,S,s),d.push(pt.add(pt.create(),i,S)),pt.rotate(S,S,pt.create(),Vo/4),h.push(pt.add(pt.create(),c,S)),pt.rotate(S,S,pt.create(),Vo/4),p.push(pt.add(pt.create(),l,S)),pt.rotate(S,S,pt.create(),Vo/4),E.push(pt.add(pt.create(),u,S))}return ju.fromPoints(d.concat(h,p,E))};var mS=hS;const pS=sm,{isGTE:vS}=Mt,gS=e=>{const t={center:[0,0,0],radius:1,segments:32,axes:[[1,0,0],[0,-1,0],[0,0,1]]};let{center:r,radius:n,segments:s,axes:o}=Object.assign({},t,e);if(!vS(n,0))throw new Error("radius must be positive");return n=[n,n,n],pS({center:r,radius:n,segments:s,axes:o})};var am=gS;const yS=yl,{isGTE:bS}=Mt,wS=e=>{const t={center:[0,0],size:2};let{center:r,size:n}=Object.assign({},t,e);if(!bS(n,0))throw new Error("size must be positive");return n=[n,n],yS({center:r,size:n})};var _S=wS;const{TAU:im}=st,Bs=rt,xS=Qe,{isGT:ES,isGTE:zo,isNumberArray:$S}=Mt,AS=(e,t)=>e>0&&t>1&&t<e/2?Math.cos(Math.PI*t/e)/Math.cos(Math.PI*(t-1)/e):0,Wu=(e,t,r,n)=>{const s=im/e,o=[];for(let a=0;a<e;a++){const i=Bs.fromAngleRadians(Bs.create(),s*a+r);Bs.scale(i,i,t),Bs.add(i,n,i),o.push(i)}return o},TS=e=>{const t={center:[0,0],vertices:5,outerRadius:1,innerRadius:0,density:2,startAngle:0};let{center:r,vertices:n,outerRadius:s,innerRadius:o,density:a,startAngle:i}=Object.assign({},t,e);if(!$S(r,2))throw new Error("center must be an array of X and Y values");if(!zo(n,2))throw new Error("vertices must be two or more");if(!ES(s,0))throw new Error("outerRadius must be greater than zero");if(!zo(o,0))throw new Error("innerRadius must be greater than zero");if(!zo(i,0))throw new Error("startAngle must be greater than zero");if(n=Math.floor(n),a=Math.floor(a),i=i%im,o===0){if(!zo(a,2))throw new Error("density must be two or more");o=s*AS(n,a)}const c=Bs.clone(r),l=Wu(n,s,i,c),u=Wu(n,o,i+Math.PI/n,c),d=[];for(let h=0;h<n;h++)d.push(l[h]),d.push(u[h]);return xS.fromPoints(d)};var SS=TS;const PS=We,Zu=ft,Qu=xr,Ku=Qe,Ju=Ke,e0=ct,Ca=(e,...t)=>{const r={origin:[0,0,0],normal:[0,0,1]},{origin:n,normal:s}=Object.assign({},r,e);if(t=PS(t),t.length===0)throw new Error("wrong number of arguments");const o=Qu.fromNormalAndPoint(Qu.create(),s,n);if(Number.isNaN(o[0]))throw new Error("the given origin and normal do not define a proper plane");const a=Zu.mirrorByPlane(Zu.create(),o),i=t.map(c=>e0.isA(c)?e0.transform(a,c):Ku.isA(c)?Ku.transform(a,c):Ju.isA(c)?Ju.transform(a,c):c);return i.length===1?i[0]:i},CS=(...e)=>Ca({normal:[1,0,0]},e),OS=(...e)=>Ca({normal:[0,1,0]},e),MS=(...e)=>Ca({normal:[0,0,1]},e);var Is={mirror:Ca,mirrorX:CS,mirrorY:OS,mirrorZ:MS};const t0=xr,vn=Ie,RS=e=>{const t=e.edges;if(t.length<3)throw new Error("slices must have 3 or more edges to calculate a plane");const r=t.reduce((a,i)=>vn.add(vn.create(),a,i[0]),vn.create());vn.scale(r,r,1/t.length);let n,s=0;t.forEach(a=>{if(!vn.equals(a[0],a[1])){const i=vn.squaredDistance(r,a[0]);i>s&&(n=a,s=i)}});const o=t.find(a=>vn.equals(a[1],n[0]));return t0.fromPoints(t0.create(),o[0],n[0],n[1])};var cm=RS;const LS=e=>(e||(e=[]),{edges:e});var $n=LS;const FS=$n,r0=Ie,GS=(...e)=>{let t,r;return e.length===1?(t=FS(),r=e[0]):(t=e[0],r=e[1]),t.edges=r.edges.map(n=>[r0.clone(n[0]),r0.clone(n[1])]),t};var NS=GS;const DS=Ie,kS=(e,t)=>{const r=e.edges,n=t.edges;return r.length!==n.length?!1:r.reduce((o,a,i)=>{const c=n[i],l=DS.squaredDistance(a[0],c[0]);return o&&l<Number.EPSILON},!0)};var BS=kS;const Uo=Ie,IS=$n,VS=e=>{if(!Array.isArray(e))throw new Error("the given points must be an array");if(e.length<3)throw new Error("the given points must contain THREE or more points");const t=[];let r=e[e.length-1];return e.forEach(n=>{n.length===2&&t.push([Uo.fromVec2(Uo.create(),r),Uo.fromVec2(Uo.create(),n)]),n.length===3&&t.push([r,n]),r=n}),IS(t)};var zS=VS;const qo=Ie,US=$n,qS=e=>{if(!Array.isArray(e))throw new Error("the given sides must be an array");const t=[];return e.forEach(r=>{t.push([qo.fromVec2(qo.create(),r[0]),qo.fromVec2(qo.create(),r[1])])}),US(t)};var XS=qS;const jS=e=>!!(e&&typeof e=="object"&&"edges"in e&&Array.isArray(e.edges));var HS=jS;const YS=$n,WS=(...e)=>{let t,r;return e.length===1?(t=YS(),r=e[0]):(t=e[0],r=e[1]),t.edges=r.edges.map(n=>[n[1],n[0]]),t};var ZS=WS;const QS=e=>e.edges;var KS=QS;const JS=(e,t)=>{let r,n,s,o,a,i=1;do{n=e,e=null;let c=null;for(a=0;n;){a++,s=n;let l=0;for(r=0;r<i&&(l++,s=s.nextZ,!!s);r++);let u=i;for(;l>0||u>0&&s;)l!==0&&(u===0||!s||t(n)<=t(s))?(o=n,n=n.nextZ,l--):(o=s,s=s.nextZ,u--),c?c.nextZ=o:e=o,o.prevZ=c,c=o;n=s}c.nextZ=null,i*=2}while(a>1);return e};var eP=JS;const tP=eP;let lm=class{constructor(t,r,n){this.i=t,this.x=r,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}};const rP=(e,t,r,n)=>{const s=new lm(e,t,r);return n?(s.next=n.next,s.prev=n,n.next.prev=s,n.next=s):(s.prev=s,s.next=s),s},nP=e=>{e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)};var fm={Node:lm,insertNode:rP,removeNode:nP,sortLinked:tP};const sP=(e,t,r,n,s,o,a,i)=>(s-a)*(t-i)-(e-a)*(o-i)>=0&&(e-a)*(n-i)-(r-a)*(t-i)>=0&&(r-a)*(o-i)-(s-a)*(n-i)>=0,oP=(e,t,r)=>(t.y-e.y)*(r.x-t.x)-(t.x-e.x)*(r.y-t.y);var bl={area:oP,pointInTriangle:sP};const{Node:n0,insertNode:s0,removeNode:ha}=fm,{area:Wt}=bl,aP=(e,t,r,n,s)=>{let o;if(s===dP(e,t,r,n)>0)for(let a=t;a<r;a+=n)o=s0(a,e[a],e[a+1],o);else for(let a=r-n;a>=t;a-=n)o=s0(a,e[a],e[a+1],o);return o&&Oa(o,o.next)&&(ha(o),o=o.next),o},um=(e,t)=>{if(!e)return e;t||(t=e);let r=e,n;do if(n=!1,!r.steiner&&(Oa(r,r.next)||Wt(r.prev,r,r.next)===0)){if(ha(r),r=t=r.prev,r===r.next)break;n=!0}else r=r.next;while(n||r!==t);return t},iP=(e,t,r)=>{let n=e;do{const s=n.prev,o=n.next.next;!Oa(s,o)&&dm(s,n,n.next,o)&&Xs(s,o)&&Xs(o,s)&&(t.push(s.i/r),t.push(n.i/r),t.push(o.i/r),ha(n),ha(n.next),n=e=o),n=n.next}while(n!==e);return um(n)},cP=(e,t)=>{let r=e;do{if(r.i!==e.i&&r.next.i!==e.i&&r.i!==t.i&&r.next.i!==t.i&&dm(r,r.next,e,t))return!0;r=r.next}while(r!==e);return!1},Xs=(e,t)=>Wt(e.prev,e,e.next)<0?Wt(e,t,e.next)>=0&&Wt(e,e.prev,t)>=0:Wt(e,t,e.prev)<0||Wt(e,e.next,t)<0,lP=(e,t)=>{let r=e,n=!1;const s=(e.x+t.x)/2,o=(e.y+t.y)/2;do r.y>o!=r.next.y>o&&r.next.y!==r.y&&s<(r.next.x-r.x)*(o-r.y)/(r.next.y-r.y)+r.x&&(n=!n),r=r.next;while(r!==e);return n},fP=(e,t)=>{const r=new n0(e.i,e.x,e.y),n=new n0(t.i,t.x,t.y),s=e.next,o=t.prev;return e.next=t,t.prev=e,r.next=s,s.prev=r,n.next=r,r.prev=n,o.next=n,n.prev=o,n},uP=(e,t)=>e.next.i!==t.i&&e.prev.i!==t.i&&!cP(e,t)&&(Xs(e,t)&&Xs(t,e)&&lP(e,t)&&(Wt(e.prev,e,t.prev)||Wt(e,t.prev,t))||Oa(e,t)&&Wt(e.prev,e,e.next)>0&&Wt(t.prev,t,t.next)>0),dm=(e,t,r,n)=>{const s=Math.sign(Wt(e,t,r)),o=Math.sign(Wt(e,t,n)),a=Math.sign(Wt(r,n,e)),i=Math.sign(Wt(r,n,t));return!!(s!==o&&a!==i||s===0&&Xo(e,r,t)||o===0&&Xo(e,n,t)||a===0&&Xo(r,e,n)||i===0&&Xo(r,t,n))},Xo=(e,t,r)=>t.x<=Math.max(e.x,r.x)&&t.x>=Math.min(e.x,r.x)&&t.y<=Math.max(e.y,r.y)&&t.y>=Math.min(e.y,r.y),dP=(e,t,r,n)=>{let s=0;for(let o=t,a=r-n;o<r;o+=n)s+=(e[a]-e[o])*(e[o+1]+e[a+1]),a=o;return s},Oa=(e,t)=>e.x===t.x&&e.y===t.y;var hm={cureLocalIntersections:iP,filterPoints:um,isValidDiagonal:uP,linkedPolygon:aP,locallyInside:Xs,splitPolygon:fP};const{filterPoints:Uc,linkedPolygon:hP,locallyInside:mP,splitPolygon:pP}=hm,{area:o0,pointInTriangle:vP}=bl,gP=(e,t,r,n)=>{const s=[];for(let o=0,a=t.length;o<a;o++){const i=t[o]*n,c=o<a-1?t[o+1]*n:e.length,l=hP(e,i,c,n,!1);l===l.next&&(l.steiner=!0),s.push(_P(l))}s.sort((o,a)=>o.x-a.x);for(let o=0;o<s.length;o++)r=yP(s[o],r),r=Uc(r,r.next);return r},yP=(e,t)=>{const r=bP(e,t);if(!r)return t;const n=pP(r,e),s=Uc(r,r.next);return Uc(n,n.next),t===r?s:t},bP=(e,t)=>{let r=t;const n=e.x,s=e.y;let o=-1/0,a;do{if(s<=r.y&&s>=r.next.y&&r.next.y!==r.y){const d=r.x+(s-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(d<=n&&d>o){if(o=d,d===n){if(s===r.y)return r;if(s===r.next.y)return r.next}a=r.x<r.next.x?r:r.next}}r=r.next}while(r!==t);if(!a)return null;if(n===o)return a;const i=a,c=a.x,l=a.y;let u=1/0;r=a;do{if(n>=r.x&&r.x>=c&&n!==r.x&&vP(s<l?n:o,s,c,l,s<l?o:n,s,r.x,r.y)){const d=Math.abs(s-r.y)/(n-r.x);mP(r,e)&&(d<u||d===u&&(r.x>a.x||r.x===a.x&&wP(a,r)))&&(a=r,u=d)}r=r.next}while(r!==i);return a},wP=(e,t)=>o0(e.prev,e,t.prev)<0&&o0(t.next,e,e.next)<0,_P=e=>{let t=e,r=e;do(t.x<r.x||t.x===r.x&&t.y<r.y)&&(r=t),t=t.next;while(t!==e);return r};var xP=gP;const EP=xP,{removeNode:$P,sortLinked:AP}=fm,{cureLocalIntersections:TP,filterPoints:ma,isValidDiagonal:SP,linkedPolygon:PP,splitPolygon:CP}=hm,{area:yn,pointInTriangle:Vs}=bl,OP=(e,t,r=2)=>{const n=t&&t.length,s=n?t[0]*r:e.length;let o=PP(e,0,s,r,!0);const a=[];if(!o||o.next===o.prev)return a;let i,c,l,u,d;if(n&&(o=EP(e,t,o,r)),e.length>80*r){i=l=e[0],c=u=e[1];for(let h=r;h<s;h+=r){const p=e[h],E=e[h+1];p<i&&(i=p),E<c&&(c=E),p>l&&(l=p),E>u&&(u=E)}d=Math.max(l-i,u-c),d=d!==0?1/d:0}return js(o,a,r,i,c,d),a},js=(e,t,r,n,s,o,a)=>{if(!e)return;!a&&o&&FP(e,n,s,o);let i=e,c,l;for(;e.prev!==e.next;){if(c=e.prev,l=e.next,o?RP(e,n,s,o):MP(e)){t.push(c.i/r),t.push(e.i/r),t.push(l.i/r),$P(e),e=l.next,i=l.next;continue}if(e=l,e===i){a?a===1?(e=TP(ma(e),t,r),js(e,t,r,n,s,o,2)):a===2&&LP(e,t,r,n,s,o):js(ma(e),t,r,n,s,o,1);break}}},MP=e=>{const t=e.prev,r=e,n=e.next;if(yn(t,r,n)>=0)return!1;let s=e.next.next;for(;s!==e.prev;){if(Vs(t.x,t.y,r.x,r.y,n.x,n.y,s.x,s.y)&&yn(s.prev,s,s.next)>=0)return!1;s=s.next}return!0},RP=(e,t,r,n)=>{const s=e.prev,o=e,a=e.next;if(yn(s,o,a)>=0)return!1;const i=s.x<o.x?s.x<a.x?s.x:a.x:o.x<a.x?o.x:a.x,c=s.y<o.y?s.y<a.y?s.y:a.y:o.y<a.y?o.y:a.y,l=s.x>o.x?s.x>a.x?s.x:a.x:o.x>a.x?o.x:a.x,u=s.y>o.y?s.y>a.y?s.y:a.y:o.y>a.y?o.y:a.y,d=qc(i,c,t,r,n),h=qc(l,u,t,r,n);let p=e.prevZ,E=e.nextZ;for(;p&&p.z>=d&&E&&E.z<=h;){if(p!==e.prev&&p!==e.next&&Vs(s.x,s.y,o.x,o.y,a.x,a.y,p.x,p.y)&&yn(p.prev,p,p.next)>=0||(p=p.prevZ,E!==e.prev&&E!==e.next&&Vs(s.x,s.y,o.x,o.y,a.x,a.y,E.x,E.y)&&yn(E.prev,E,E.next)>=0))return!1;E=E.nextZ}for(;p&&p.z>=d;){if(p!==e.prev&&p!==e.next&&Vs(s.x,s.y,o.x,o.y,a.x,a.y,p.x,p.y)&&yn(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;E&&E.z<=h;){if(E!==e.prev&&E!==e.next&&Vs(s.x,s.y,o.x,o.y,a.x,a.y,E.x,E.y)&&yn(E.prev,E,E.next)>=0)return!1;E=E.nextZ}return!0},LP=(e,t,r,n,s,o)=>{let a=e;do{let i=a.next.next;for(;i!==a.prev;){if(a.i!==i.i&&SP(a,i)){let c=CP(a,i);a=ma(a,a.next),c=ma(c,c.next),js(a,t,r,n,s,o),js(c,t,r,n,s,o);return}i=i.next}a=a.next}while(a!==e)},FP=(e,t,r,n)=>{let s=e;do s.z===null&&(s.z=qc(s.x,s.y,t,r,n)),s.prevZ=s.prev,s.nextZ=s.next,s=s.next;while(s!==e);s.prevZ.nextZ=null,s.prevZ=null,AP(s,o=>o.z)},qc=(e,t,r,n,s)=>(e=32767*(e-r)*s,t=32767*(t-n)*s,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,e|t<<1);var GP=OP;const{area:NP}=Zs,{toOutlines:DP}=Qe,{arePointsInside:kP}=cl,BP=e=>{const t=DP(e),r=[],n=[];t.forEach((a,i)=>{const c=NP(a);c<0?n.push(i):c>0&&r.push(i)});const s=[],o=[];return r.forEach((a,i)=>{const c=t[a];s[i]=[],n.forEach((l,u)=>{const d=t[l];kP([d[0]],{vertices:c})&&(s[i].push(l),o[u]||(o[u]=[]),o[u].push(i))})}),n.forEach((a,i)=>{if(o[i]&&o[i].length>1){const c=IP(o[i],l=>s[l].length);o[i].forEach((l,u)=>{u!==c&&(s[l]=s[l].filter(d=>d!==a))})}}),s.map((a,i)=>({solid:t[r[i]],holes:a.map(c=>t[c])}))},IP=(e,t)=>{let r,n;return e.forEach((s,o)=>{const a=t(s);(n===void 0||a<n)&&(r=o,n=a)}),r};var VP=BP;const zP=Qe,a0=xr,UP=rt,kt=Ie,qP=cm,XP=VP;let jP=class{constructor(t){this.plane=qP(t);const r=kt.orthogonal(kt.create(),this.plane),n=kt.cross(kt.create(),this.plane,r);this.v=kt.normalize(n,n),this.u=kt.cross(kt.create(),this.v,this.plane),this.basisMap=new Map;const s=t.edges.map(a=>a.map(i=>this.to2D(i))),o=zP.create(s);this.roots=XP(o)}to2D(t){const r=UP.fromValues(kt.dot(t,this.u),kt.dot(t,this.v));return this.basisMap.set(r,t),r}to3D(t){const r=this.basisMap.get(t);if(r)return r;{console.log("Warning: point not in original slice");const n=kt.scale(kt.create(),this.u,t[0]),s=kt.scale(kt.create(),this.v,t[1]),o=kt.scale(kt.create(),a0,a0[3]),a=kt.add(n,n,o);return kt.add(s,s,a)}}};var HP=jP;const YP=ot,WP=GP,ZP=HP,QP=e=>{const t=new ZP(e),r=[];return t.roots.forEach(({solid:n,holes:s})=>{let o=n.length;const a=[];s.forEach((d,h)=>{a.push(o),o+=d.length});const i=[n,...s].flat(),c=i.flat(),l=d=>t.to3D(i[d]),u=WP(c,a);for(let d=0;d<u.length;d+=3){const h=u.slice(d,d+3).map(l);r.push(YP.fromPointsAndPlane(h,t.plane))}}),r};var KP=QP;const i0=Ie,JP=e=>e.reduce((t,r)=>t+=`[${i0.toString(r[0])}, ${i0.toString(r[1])}], `,""),e8=e=>`[${JP(e.edges)}]`;var t8=e8;const jo=Ie,r8=$n,n8=(e,t)=>{const r=t.edges.map(n=>[jo.transform(jo.create(),n[0],e),jo.transform(jo.create(),n[1],e)]);return r8(r)};var s8=n8,as={calculatePlane:cm,clone:NS,create:$n,equals:BS,fromPoints:zS,fromSides:XS,isA:HS,reverse:ZS,toEdges:KS,toPolygons:KP,toString:t8,transform:s8};const c0=Ie,o8=$n,a8=e=>{if(!e.edges)return e;let t=e.edges;const r=new Map,n=new Map;t=t.filter(a=>!c0.equals(a[0],a[1])),t.forEach(a=>{const i=a[0].toString(),c=a[1].toString();r.set(i,a[0]),r.set(c,a[1]),n.set(i,(n.get(i)||0)+1),n.set(c,(n.get(c)||0)-1)});const s=[],o=[];return n.forEach((a,i)=>{a<0&&s.push(i),a>0&&o.push(i)}),s.forEach(a=>{const i=r.get(a);let c=1/0,l;o.forEach(u=>{const d=r.get(u),h=c0.distance(i,d);h<c&&(c=h,l=d)}),console.warn(`slice.repair: repairing vertex gap ${i} to ${l} distance ${c}`),t=t.map(u=>u[0].toString()===a?[l,u[1]]:u[1].toString()===a?[u[0],l]:u)}),o8(t)};var i8=a8;const{EPS:l0}=st,Un=Ie,Ho=ot,f0=as,Xc=(e,t)=>e===t?e:e<t?Xc(t,e):t===1?1:t===0?e:Xc(t,e%t),c8=(e,t)=>e*t/Xc(e,t),u0=(e,t)=>{const r=e/t.length;if(r===1)return t;const n=Un.fromValues(r,r,r),s=[];return t.forEach(o=>{const a=Un.subtract(Un.create(),o[1],o[0]);Un.divide(a,a,n);let i=o[0];for(let c=1;c<=r;++c){const l=Un.add(Un.create(),i,a);s.push([i,l]),i=l}}),s},d0=l0*l0/2*Math.sin(Math.PI/3),l8=(e,t)=>{let r=f0.toEdges(e),n=f0.toEdges(t);if(r.length!==n.length){const o=c8(r.length,n.length);o!==r.length&&(r=u0(o,r)),o!==n.length&&(n=u0(o,n))}const s=[];return r.forEach((o,a)=>{const i=n[a],c=Ho.create([o[0],o[1],i[1]]),l=Ho.measureArea(c);Number.isFinite(l)&&l>d0&&s.push(c);const u=Ho.create([o[0],i[1],i[0]]),d=Ho.measureArea(u);Number.isFinite(d)&&d>d0&&s.push(u)}),s};var f8=l8;const h0=ft,m0=Qe,u8=Ke,jc=ot,Wr=as,d8=i8,p0=f8,h8=(e,t,r)=>{let n=null;return m0.isA(r)&&(n=Wr.fromSides(m0.toSides(r))),jc.isA(r)&&(n=Wr.fromPoints(jc.toPoints(r))),e===0||e===1?Wr.transform(h0.fromTranslation(h0.create(),[0,0,e]),n):null},m8=(e,t)=>{const r={numberOfSlices:2,capStart:!0,capEnd:!0,close:!1,repair:!0,callback:h8},{numberOfSlices:n,capStart:s,capEnd:o,close:a,repair:i,callback:c}=Object.assign({},r,e);if(n<2)throw new Error("numberOfSlices must be 2 or more");i&&(t=d8(t));const l=n-1;let u=null,d=null,h=null,p=[];for(let E=0;E<n;E++){const g=c(E/l,E,t);if(g){if(!Wr.isA(g))throw new Error("the callback function must return slice objects");if(Wr.toEdges(g).length===0)throw new Error("the callback function must return slices with one or more edges");h&&(p=p.concat(p0(h,g))),E===0&&(u=g),E===n-1&&(d=g),h=g}}if(o){const E=Wr.toPolygons(d);p=p.concat(E)}if(s){const E=Wr.toPolygons(u).map(jc.invert);p=p.concat(E)}return!s&&!o&&a&&!Wr.equals(d,u)&&(p=p.concat(p0(d,u))),u8.create(p)};var Ma=m8;const{TAU:nr}=st,Rs=ft,{mirrorX:p8}=Is,Yo=Qe,tc=as,v8=Ma,g8=(e,t)=>{const r={segments:12,startAngle:0,angle:nr,overflow:"cap"};let{segments:n,startAngle:s,angle:o,overflow:a}=Object.assign({},r,e);if(n<3)throw new Error("segments must be greater then 3");s=Math.abs(s)>nr?s%nr:s,o=Math.abs(o)>nr?o%nr:o;let i=s+o;if(i=Math.abs(i)>nr?i%nr:i,i<s){const G=s;s=i,i=G}let c=i-s;if(c<=0&&(c=nr),Math.abs(c)<nr){const G=nr/n;n=Math.floor(Math.abs(c)/G),Math.abs(c)>n*G&&n++}let l=Yo.toSides(t);if(l.length===0)throw new Error("the given geometry cannot be empty");const u=l.filter(G=>G[0][0]<0),d=l.filter(G=>G[0][0]>=0);u.length>0&&d.length>0&&a==="cap"&&(u.length>d.length?(l=l.map(G=>{let R=G[0],M=G[1];return R=[Math.min(R[0],0),R[1]],M=[Math.min(M[0],0),M[1]],[R,M]}),t=Yo.create(l),t=p8(t)):d.length>=u.length&&(l=l.map(G=>{let R=G[0],M=G[1];return R=[Math.max(R[0],0),R[1]],M=[Math.max(M[0],0),M[1]],[R,M]}),t=Yo.create(l)));const p=c/n,E=Math.abs(c)<nr,g=tc.fromSides(Yo.toSides(t));tc.reverse(g,g);const b=Rs.create(),S=(G,R,M)=>{let F=p*R+s;return c===nr&&R===n&&(F=s),Rs.multiply(b,Rs.fromZRotation(b,F),Rs.fromXRotation(Rs.create(),nr/4)),tc.transform(b,M)};return e={numberOfSlices:n+1,capStart:E,capEnd:E,close:!E,callback:S},v8(e,g)};var mm=g8;const y8=We,v0=ft,g0=Qe,y0=Ke,b0=ct,Ra=(e,...t)=>{if(!Array.isArray(e))throw new Error("angles must be an array");if(t=y8(t),t.length===0)throw new Error("wrong number of arguments");for(e=e.slice();e.length<3;)e.push(0);const r=e[2],n=e[1],s=e[0],o=v0.fromTaitBryanRotation(v0.create(),r,n,s),a=t.map(i=>b0.isA(i)?b0.transform(o,i):g0.isA(i)?g0.transform(o,i):y0.isA(i)?y0.transform(o,i):i);return a.length===1?a[0]:a},b8=(e,...t)=>Ra([e,0,0],t),w8=(e,...t)=>Ra([0,e,0],t),_8=(e,...t)=>Ra([0,0,e],t);var zs={rotate:Ra,rotateX:b8,rotateY:w8,rotateZ:_8};const x8=We,w0=ft,_0=Qe,x0=Ke,E0=ct,La=(e,...t)=>{if(!Array.isArray(e))throw new Error("offset must be an array");if(t=x8(t),t.length===0)throw new Error("wrong number of arguments");for(e=e.slice();e.length<3;)e.push(0);const r=w0.fromTranslation(w0.create(),e),n=t.map(s=>E0.isA(s)?E0.transform(r,s):_0.isA(s)?_0.transform(r,s):x0.isA(s)?x0.transform(r,s):s);return n.length===1?n[0]:n},E8=(e,...t)=>La([e,0,0],t),$8=(e,...t)=>La([0,e,0],t),A8=(e,...t)=>La([0,0,e],t);var wn={translate:La,translateX:E8,translateY:$8,translateZ:A8};const{TAU:T8}=st,S8=mm,{rotate:P8}=zs,{translate:C8}=wn,O8=tm,{isGT:rc,isGTE:nc}=Mt,M8=e=>{const t={innerRadius:1,innerSegments:32,outerRadius:4,outerSegments:32,innerRotation:0,startAngle:0,outerRotation:T8},{innerRadius:r,innerSegments:n,outerRadius:s,outerSegments:o,innerRotation:a,startAngle:i,outerRotation:c}=Object.assign({},t,e);if(!rc(r,0))throw new Error("innerRadius must be greater than zero");if(!nc(n,3))throw new Error("innerSegments must be three or more");if(!rc(s,0))throw new Error("outerRadius must be greater than zero");if(!nc(o,3))throw new Error("outerSegments must be three or more");if(!nc(i,0))throw new Error("startAngle must be positive");if(!rc(c,0))throw new Error("outerRotation must be greater than zero");if(r>=s)throw new Error("inner circle is two large to rotate about the outer circle");let l=O8({radius:r,segments:n});return a!==0&&(l=P8([0,0,a],l)),l=C8([s,0],l),S8({startAngle:i,angle:c,segments:o},l)};var R8=M8;const{NEPS:ns}=st,Ls=rt,L8=Qe,{isNumberArray:F8}=Mt,Hc=(e,t,r)=>Math.acos((e*e+t*t-r*r)/(2*e*t)),G8=(e,t,r)=>t>ns?Math.sqrt(e*e+r*r-2*e*r*Math.cos(t)):Math.sqrt((e-r)*(e-r)+e*r*t*t*(1-t*t/12)),N8=e=>{if(Math.abs(e[0]+e[1]+e[2]-Math.PI)>ns)throw new Error("AAA triangles require angles that sum to PI");const r=e[0],n=e[1],s=Math.PI-r-n,o=1,a=o/Math.sin(s)*Math.sin(r),i=o/Math.sin(s)*Math.sin(n);return is(r,n,s,a,i,o)},D8=e=>{const t=e[0],r=e[1],n=Math.PI+ns-t-r;if(n<ns)throw new Error("AAS triangles require angles that sum to PI");const s=e[2],o=s/Math.sin(t)*Math.sin(r),a=s/Math.sin(t)*Math.sin(n);return is(t,r,n,s,o,a)},k8=e=>{const t=e[0],r=e[2],n=Math.PI+ns-t-r;if(n<ns)throw new Error("ASA triangles require angles that sum to PI");const s=e[1],o=s/Math.sin(n)*Math.sin(t),a=s/Math.sin(n)*Math.sin(r);return is(t,r,n,o,a,s)},B8=e=>{const t=e[0],r=e[1],n=e[2],s=G8(t,r,n),o=Hc(s,t,n),a=Math.PI-o-r;return is(o,r,a,n,s,t)},I8=e=>{const t=e[0],r=e[1],n=e[2],s=Math.asin(r*Math.sin(n)/t),o=Math.PI-s-n,a=t/Math.sin(n)*Math.sin(o);return is(s,o,n,r,a,t)},V8=e=>{const t=e[1],r=e[2],n=e[0];if(t+r<=n||r+n<=t||n+t<=r)throw new Error("SSS triangle is incorrect, as the longest side is longer than the sum of the other sides");const s=Hc(r,n,t),o=Hc(n,t,r),a=Math.PI-s-o;return is(s,o,a,t,r,n)},is=(e,t,r,n,s,o)=>{const a=Ls.fromValues(0,0),i=Ls.fromValues(o,0),c=Ls.fromValues(n,0);return Ls.add(c,Ls.rotate(c,c,[0,0],Math.PI-t),i),L8.fromPoints([a,i,c])},z8=e=>{const t={type:"SSS",values:[1,1,1]};let{type:r,values:n}=Object.assign({},t,e);if(typeof r!="string")throw new Error("triangle type must be a string");if(r=r.toUpperCase(),!((r[0]==="A"||r[0]==="S")&&(r[1]==="A"||r[1]==="S")&&(r[2]==="A"||r[2]==="S")))throw new Error("triangle type must contain three letters; A or S");if(!F8(n,3))throw new Error("triangle values must contain three values");if(!n.every(s=>s>0))throw new Error("triangle values must be greater than zero");switch(r){case"AAA":return N8(n);case"AAS":return D8(n);case"ASA":return k8(n);case"SAS":return B8(n);case"SSA":return I8(n);case"SSS":return V8(n);default:throw new Error("invalid triangle type, try again")}};var U8=z8,Us={arc:vT,circle:tm,cube:CT,cuboid:gl,cylinder:nm,cylinderElliptic:rm,ellipse:em,ellipsoid:sm,geodesicSphere:HT,line:ZT,polygon:KT,polyhedron:om,rectangle:yl,roundedCuboid:oS,roundedCylinder:uS,roundedRectangle:mS,sphere:am,square:_S,star:SS,torus:R8,triangle:U8},q8={height:14,32:[16],33:[10,5,21,5,7,void 0,5,2,4,1,5,0,6,1,5,2],34:[16,4,21,4,14,void 0,12,21,12,14],35:[21,11,25,4,-7,void 0,17,25,10,-7,void 0,4,12,18,12,void 0,3,6,17,6],36:[20,8,25,8,-4,void 0,12,25,12,-4,void 0,17,18,15,20,12,21,8,21,5,20,3,18,3,16,4,14,5,13,7,12,13,10,15,9,16,8,17,6,17,3,15,1,12,0,8,0,5,1,3,3],37:[24,21,21,3,0,void 0,8,21,10,19,10,17,9,15,7,14,5,14,3,16,3,18,4,20,6,21,8,21,10,20,13,19,16,19,19,20,21,21,void 0,17,7,15,6,14,4,14,2,16,0,18,0,20,1,21,3,21,5,19,7,17,7],38:[26,23,12,23,13,22,14,21,14,20,13,19,11,17,6,15,3,13,1,11,0,7,0,5,1,4,2,3,4,3,6,4,8,5,9,12,13,13,14,14,16,14,18,13,20,11,21,9,20,8,18,8,16,9,13,11,10,16,3,18,1,20,0,22,0,23,1,23,2],39:[10,5,19,4,20,5,21,6,20,6,18,5,16,4,15],40:[14,11,25,9,23,7,20,5,16,4,11,4,7,5,2,7,-2,9,-5,11,-7],41:[14,3,25,5,23,7,20,9,16,10,11,10,7,9,2,7,-2,5,-5,3,-7],42:[16,8,21,8,9,void 0,3,18,13,12,void 0,13,18,3,12],43:[26,13,18,13,0,void 0,4,9,22,9],44:[10,6,1,5,0,4,1,5,2,6,1,6,-1,5,-3,4,-4],45:[26,4,9,22,9],46:[10,5,2,4,1,5,0,6,1,5,2],47:[22,20,25,2,-7],48:[20,9,21,6,20,4,17,3,12,3,9,4,4,6,1,9,0,11,0,14,1,16,4,17,9,17,12,16,17,14,20,11,21,9,21],49:[20,6,17,8,18,11,21,11,0],50:[20,4,16,4,17,5,19,6,20,8,21,12,21,14,20,15,19,16,17,16,15,15,13,13,10,3,0,17,0],51:[20,5,21,16,21,10,13,13,13,15,12,16,11,17,8,17,6,16,3,14,1,11,0,8,0,5,1,4,2,3,4],52:[20,13,21,3,7,18,7,void 0,13,21,13,0],53:[20,15,21,5,21,4,12,5,13,8,14,11,14,14,13,16,11,17,8,17,6,16,3,14,1,11,0,8,0,5,1,4,2,3,4],54:[20,16,18,15,20,12,21,10,21,7,20,5,17,4,12,4,7,5,3,7,1,10,0,11,0,14,1,16,3,17,6,17,7,16,10,14,12,11,13,10,13,7,12,5,10,4,7],55:[20,17,21,7,0,void 0,3,21,17,21],56:[20,8,21,5,20,4,18,4,16,5,14,7,13,11,12,14,11,16,9,17,7,17,4,16,2,15,1,12,0,8,0,5,1,4,2,3,4,3,7,4,9,6,11,9,12,13,13,15,14,16,16,16,18,15,20,12,21,8,21],57:[20,16,14,15,11,13,9,10,8,9,8,6,9,4,11,3,14,3,15,4,18,6,20,9,21,10,21,13,20,15,18,16,14,16,9,15,4,13,1,10,0,8,0,5,1,4,3],58:[10,5,14,4,13,5,12,6,13,5,14,void 0,5,2,4,1,5,0,6,1,5,2],59:[10,5,14,4,13,5,12,6,13,5,14,void 0,6,1,5,0,4,1,5,2,6,1,6,-1,5,-3,4,-4],60:[24,20,18,4,9,20,0],61:[26,4,12,22,12,void 0,4,6,22,6],62:[24,4,18,20,9,4,0],63:[18,3,16,3,17,4,19,5,20,7,21,11,21,13,20,14,19,15,17,15,15,14,13,13,12,9,10,9,7,void 0,9,2,8,1,9,0,10,1,9,2],64:[27,18,13,17,15,15,16,12,16,10,15,9,14,8,11,8,8,9,6,11,5,14,5,16,6,17,8,void 0,12,16,10,14,9,11,9,8,10,6,11,5,void 0,18,16,17,8,17,6,19,5,21,5,23,7,24,10,24,12,23,15,22,17,20,19,18,20,15,21,12,21,9,20,7,19,5,17,4,15,3,12,3,9,4,6,5,4,7,2,9,1,12,0,15,0,18,1,20,2,21,3,void 0,19,16,18,8,18,6,19,5],65:[18,9,21,1,0,void 0,9,21,17,0,void 0,4,7,14,7],66:[21,4,21,4,0,void 0,4,21,13,21,16,20,17,19,18,17,18,15,17,13,16,12,13,11,void 0,4,11,13,11,16,10,17,9,18,7,18,4,17,2,16,1,13,0,4,0],67:[21,18,16,17,18,15,20,13,21,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5],68:[21,4,21,4,0,void 0,4,21,11,21,14,20,16,18,17,16,18,13,18,8,17,5,16,3,14,1,11,0,4,0],69:[19,4,21,4,0,void 0,4,21,17,21,void 0,4,11,12,11,void 0,4,0,17,0],70:[18,4,21,4,0,void 0,4,21,17,21,void 0,4,11,12,11],71:[21,18,16,17,18,15,20,13,21,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5,18,8,void 0,13,8,18,8],72:[22,4,21,4,0,void 0,18,21,18,0,void 0,4,11,18,11],73:[8,4,21,4,0],74:[16,12,21,12,5,11,2,10,1,8,0,6,0,4,1,3,2,2,5,2,7],75:[21,4,21,4,0,void 0,18,21,4,7,void 0,9,12,18,0],76:[17,4,21,4,0,void 0,4,0,16,0],77:[24,4,21,4,0,void 0,4,21,12,0,void 0,20,21,12,0,void 0,20,21,20,0],78:[22,4,21,4,0,void 0,4,21,18,0,void 0,18,21,18,0],79:[22,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5,19,8,19,13,18,16,17,18,15,20,13,21,9,21],80:[21,4,21,4,0,void 0,4,21,13,21,16,20,17,19,18,17,18,14,17,12,16,11,13,10,4,10],81:[22,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5,19,8,19,13,18,16,17,18,15,20,13,21,9,21,void 0,12,4,18,-2],82:[21,4,21,4,0,void 0,4,21,13,21,16,20,17,19,18,17,18,15,17,13,16,12,13,11,4,11,void 0,11,11,18,0],83:[20,17,18,15,20,12,21,8,21,5,20,3,18,3,16,4,14,5,13,7,12,13,10,15,9,16,8,17,6,17,3,15,1,12,0,8,0,5,1,3,3],84:[16,8,21,8,0,void 0,1,21,15,21],85:[22,4,21,4,6,5,3,7,1,10,0,12,0,15,1,17,3,18,6,18,21],86:[18,1,21,9,0,void 0,17,21,9,0],87:[24,2,21,7,0,void 0,12,21,7,0,void 0,12,21,17,0,void 0,22,21,17,0],88:[20,3,21,17,0,void 0,17,21,3,0],89:[18,1,21,9,11,9,0,void 0,17,21,9,11],90:[20,17,21,3,0,void 0,3,21,17,21,void 0,3,0,17,0],91:[14,4,25,4,-7,void 0,5,25,5,-7,void 0,4,25,11,25,void 0,4,-7,11,-7],92:[14,0,21,14,-3],93:[14,9,25,9,-7,void 0,10,25,10,-7,void 0,3,25,10,25,void 0,3,-7,10,-7],94:[16,6,15,8,18,10,15,void 0,3,12,8,17,13,12,void 0,8,17,8,0],95:[16,0,-2,16,-2],96:[10,6,21,5,20,4,18,4,16,5,15,6,16,5,17],97:[19,15,14,15,0,void 0,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],98:[19,4,21,4,0,void 0,4,11,6,13,8,14,11,14,13,13,15,11,16,8,16,6,15,3,13,1,11,0,8,0,6,1,4,3],99:[18,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],100:[19,15,21,15,0,void 0,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],101:[18,3,8,15,8,15,10,14,12,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],102:[12,10,21,8,21,6,20,5,17,5,0,void 0,2,14,9,14],103:[19,15,14,15,-2,14,-5,13,-6,11,-7,8,-7,6,-6,void 0,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],104:[19,4,21,4,0,void 0,4,10,7,13,9,14,12,14,14,13,15,10,15,0],105:[8,3,21,4,20,5,21,4,22,3,21,void 0,4,14,4,0],106:[10,5,21,6,20,7,21,6,22,5,21,void 0,6,14,6,-3,5,-6,3,-7,1,-7],107:[17,4,21,4,0,void 0,14,14,4,4,void 0,8,8,15,0],108:[8,4,21,4,0],109:[30,4,14,4,0,void 0,4,10,7,13,9,14,12,14,14,13,15,10,15,0,void 0,15,10,18,13,20,14,23,14,25,13,26,10,26,0],110:[19,4,14,4,0,void 0,4,10,7,13,9,14,12,14,14,13,15,10,15,0],111:[19,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3,16,6,16,8,15,11,13,13,11,14,8,14],112:[19,4,14,4,-7,void 0,4,11,6,13,8,14,11,14,13,13,15,11,16,8,16,6,15,3,13,1,11,0,8,0,6,1,4,3],113:[19,15,14,15,-7,void 0,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],114:[13,4,14,4,0,void 0,4,8,5,11,7,13,9,14,12,14],115:[17,14,11,13,13,10,14,7,14,4,13,3,11,4,9,6,8,11,7,13,6,14,4,14,3,13,1,10,0,7,0,4,1,3,3],116:[12,5,21,5,4,6,1,8,0,10,0,void 0,2,14,9,14],117:[19,4,14,4,4,5,1,7,0,10,0,12,1,15,4,void 0,15,14,15,0],118:[16,2,14,8,0,void 0,14,14,8,0],119:[22,3,14,7,0,void 0,11,14,7,0,void 0,11,14,15,0,void 0,19,14,15,0],120:[17,3,14,14,0,void 0,14,14,3,0],121:[16,2,14,8,0,void 0,14,14,8,0,6,-4,4,-6,2,-7,1,-7],122:[17,14,14,3,0,void 0,3,14,14,14,void 0,3,0,14,0],123:[14,9,25,7,24,6,23,5,21,5,19,6,17,7,16,8,14,8,12,6,10,void 0,7,24,6,22,6,20,7,18,8,17,9,15,9,13,8,11,4,9,8,7,9,5,9,3,8,1,7,0,6,-2,6,-4,7,-6,void 0,6,8,8,6,8,4,7,2,6,1,5,-1,5,-3,6,-5,7,-6,9,-7],124:[8,4,25,4,-7],125:[14,5,25,7,24,8,23,9,21,9,19,8,17,7,16,6,14,6,12,8,10,void 0,7,24,8,22,8,20,7,18,6,17,5,15,5,13,6,11,10,9,6,7,5,5,5,3,6,1,7,0,8,-2,8,-4,7,-6,void 0,8,8,6,6,6,4,7,2,8,1,9,-1,9,-3,8,-5,7,-6,5,-7],126:[24,3,6,3,8,4,11,6,12,8,12,10,11,14,8,16,7,18,7,20,8,21,10,void 0,3,8,4,10,6,11,8,11,10,10,14,7,16,6,18,6,20,7,21,10,21,12]};const X8=q8,j8={xOffset:0,yOffset:0,input:"?",align:"left",font:X8,height:14,lineSpacing:2.142857142857143,letterSpacing:1,extrudeOffset:0},H8=(e,t)=>{!t&&typeof e=="string"&&(e={input:e}),e=e||{};const r=Object.assign({},j8,e);return r.input=t||r.input,r};var pm=H8;const Y8=pm,W8=(e,t)=>{const{xOffset:r,yOffset:n,input:s,font:o,height:a,extrudeOffset:i}=Y8(e,t);let c=s.charCodeAt(0);(!c||!o[c])&&(c=63);const l=[].concat(o[c]),u=(a-i)/o.height,d=i/2,h=l.shift()*u,p=[];let E=[];for(let g=0,b=l.length;g<b;g+=2){const S=u*l[g]+r,G=u*l[g+1]+n+d;if(l[g]!==void 0){E.push([S,G]);continue}p.push(E),E=[],g--}return E.length&&p.push(E),{width:h,height:a,segments:p}};var vm=W8;const Z8=vm,Q8=pm,$0=(e,t)=>{const{x:r,y:n}=Object.assign({x:0,y:0},e||{}),s=t.segments;let o=null,a=null;for(let i=0,c=s.length;i<c;i++){o=s[i];for(let l=0,u=o.length;l<u;l++)a=o[l],o[l]=[a[0]+r,a[1]+n]}return t},K8=(e,t)=>{const{xOffset:r,yOffset:n,input:s,font:o,height:a,align:i,extrudeOffset:c,lineSpacing:l,letterSpacing:u}=Q8(e,t);let[d,h]=[r,n],p,E,g,b,S,G,R={width:0,segments:[]};const M=[];let F=[],L=0;const U=d,ee=()=>{M.push(R),L=Math.max(L,R.width),R={width:0,segments:[]}};for(p=0,E=s.length;p<E;p++){if(g=s[p],b=Z8({xOffset:d,yOffset:h,font:o,height:a,extrudeOffset:c},g),g===`
`){d=U,h-=b.height*l,ee();continue}S=b.width*u,R.width+=S,d+=S,g!==" "&&(R.segments=R.segments.concat(b.segments))}for(R.segments.length&&ee(),p=0,E=M.length;p<E;p++)R=M[p],L>R.width&&(G=L-R.width,i==="right"?R=$0({x:G},R):i==="center"&&(R=$0({x:G/2},R))),F=F.concat(R.segments);return F};var J8=K8,eC={vectorChar:vm,vectorText:J8};const tC=Qe,rC=Ke,nC=ct,sC=e=>{let t;for(const r of e){let n=0;if(tC.isA(r)&&(n=1),rC.isA(r)&&(n=2),nC.isA(r)&&(n=3),t&&n!==t)return!1;t=n}return!0};var Ks=sC;const oC=e=>e*.017453292519943295;var aC=oC;const iC=(e,t)=>e-t;var gm=iC;const cC=(e,t,r)=>{let n=0,s=e.length;for(;s>n;){const o=Math.floor((n+s)/2),a=e[o];r(t,a)>0?n=o+1:s=o}e.splice(n,0,t)};var lC=cC;const{TAU:A0}=st,fC=(e,t,r)=>{const n=t>0?e*A0/t:0,s=r>0?A0/r:0;return Math.ceil(Math.max(n,s,4))};var uC=fC;const dC=e=>e*57.29577951308232;var hC=dC,wl={areAllShapesTheSameType:Ks,degToRad:aC,flatten:We,fnNumberSort:gm,insertSorted:lC,radiusToSegments:uC,radToDeg:hC};const T0=rt,mC=Qe,pC=(e,t)=>{if(t.vertices.length<4)return null;const r=[],n=t.vertices.filter((a,i)=>a[2]>0?(r.push(i),!0):!1);if(n.length!==2)throw new Error("Assertion failed: fromFakePolygon: not enough points found");const s=n.map(a=>{const i=Math.round(a[0]/e)*e+0,c=Math.round(a[1]/e)*e+0;return T0.fromValues(i,c)});if(T0.equals(s[0],s[1]))return null;const o=r[1]-r[0];if(o===1||o===3)o===1&&s.reverse();else throw new Error("Assertion failed: fromFakePolygon: unknown index ordering");return s},vC=(e,t)=>{const r=t.map(n=>pC(e,n)).filter(n=>n!==null);return mC.create(r)};var _l=vC;const Ur=Ie,gC=Qe,yC=Ke,bC=ot,wC=(e,t,r)=>{const n=[Ur.fromVec2(Ur.create(),r[0],e),Ur.fromVec2(Ur.create(),r[1],e),Ur.fromVec2(Ur.create(),r[1],t),Ur.fromVec2(Ur.create(),r[0],t)];return bC.create(n)},_C=(e,t)=>{const n=gC.toSides(t).map(o=>wC(e.z0,e.z1,o));return yC.create(n)};var xl=_C;const S0=ft,xC=rt,Pt=Ie,xn=function(e,t){arguments.length<2&&(t=Pt.orthogonal(Pt.create(),e)),this.v=Pt.normalize(Pt.create(),Pt.cross(Pt.create(),e,t)),this.u=Pt.cross(Pt.create(),this.v,e),this.plane=e,this.planeorigin=Pt.scale(Pt.create(),e,e[3])};xn.GetCartesian=function(e,t){const r=e+"/"+t;let n,s;if(r==="X/Y")n=[0,0,1],s=[1,0,0];else if(r==="Y/-X")n=[0,0,1],s=[0,1,0];else if(r==="-X/-Y")n=[0,0,1],s=[-1,0,0];else if(r==="-Y/X")n=[0,0,1],s=[0,-1,0];else if(r==="-X/Y")n=[0,0,-1],s=[-1,0,0];else if(r==="-Y/-X")n=[0,0,-1],s=[0,-1,0];else if(r==="X/-Y")n=[0,0,-1],s=[1,0,0];else if(r==="Y/X")n=[0,0,-1],s=[0,1,0];else if(r==="X/Z")n=[0,-1,0],s=[1,0,0];else if(r==="Z/-X")n=[0,-1,0],s=[0,0,1];else if(r==="-X/-Z")n=[0,-1,0],s=[-1,0,0];else if(r==="-Z/X")n=[0,-1,0],s=[0,0,-1];else if(r==="-X/Z")n=[0,1,0],s=[-1,0,0];else if(r==="-Z/-X")n=[0,1,0],s=[0,0,-1];else if(r==="X/-Z")n=[0,1,0],s=[1,0,0];else if(r==="Z/X")n=[0,1,0],s=[0,0,1];else if(r==="Y/Z")n=[1,0,0],s=[0,1,0];else if(r==="Z/-Y")n=[1,0,0],s=[0,0,1];else if(r==="-Y/-Z")n=[1,0,0],s=[0,-1,0];else if(r==="-Z/Y")n=[1,0,0],s=[0,0,-1];else if(r==="-Y/Z")n=[-1,0,0],s=[0,-1,0];else if(r==="-Z/-Y")n=[-1,0,0],s=[0,0,-1];else if(r==="Y/-Z")n=[-1,0,0],s=[0,1,0];else if(r==="Z/Y")n=[-1,0,0],s=[0,0,1];else throw new Error("OrthoNormalBasis.GetCartesian: invalid combination of axis identifiers. Should pass two string arguments from [X,Y,Z,-X,-Y,-Z], being two different axes.");return new xn(new Plane(new Vector3D(n),0),new Vector3D(s))};xn.Z0Plane=function(){const e=new Plane(new Vector3D([0,0,1]),0);return new xn(e,new Vector3D([1,0,0]))};xn.prototype={getProjectionMatrix:function(){return S0.fromValues(this.u[0],this.v[0],this.plane[0],0,this.u[1],this.v[1],this.plane[1],0,this.u[2],this.v[2],this.plane[2],0,0,0,-this.plane[3],1)},getInverseProjectionMatrix:function(){const e=Pt.scale(Pt.create(),this.plane,this.plane[3]);return S0.fromValues(this.u[0],this.u[1],this.u[2],0,this.v[0],this.v[1],this.v[2],0,this.plane[0],this.plane[1],this.plane[2],0,e[0],e[1],e[2],1)},to2D:function(e){return xC.fromValues(Pt.dot(e,this.u),Pt.dot(e,this.v))},to3D:function(e){const t=Pt.scale(Pt.create(),this.u,e[0]),r=Pt.scale(Pt.create(),this.v,e[1]),n=Pt.add(t,t,this.planeorigin);return Pt.add(r,r,n)},line3Dto2D:function(e){const t=e.point,r=e.direction.plus(t),n=this.to2D(t),s=this.to2D(r);return Line2D.fromPoints(n,s)},line2Dto3D:function(e){const t=e.origin(),r=e.direction().plus(t),n=this.to3D(t),s=this.to3D(r);return Line3D.fromPoints(n,s)},transform:function(e){const t=this.plane.transform(e),r=this.u.transform(e),n=new Vector3D(0,0,0).transform(e),s=r.minus(n);return new xn(t,s)}};var EC=xn;const{EPS:Pr}=st,qr=hl,fr=rt,$C=EC,qn=Gh,{insertSorted:AC,fnNumberSort:TC}=wl,P0=ot,SC=e=>{if(e.length<2)return e;const t=[],r=e.length,n=P0.plane(e[0]),s=new $C(n),o=[],a=[],i=new Map,c=new Map,l=new Map,u=10/Pr;for(let E=0;E<r;E++){const g=e[E];let b=[],S=g.vertices.length,G=-1;if(S>0){let R,M;for(let F=0;F<S;F++){let L=s.to2D(g.vertices[F]);const U=Math.floor(L[1]*u);let ee;l.has(U)?ee=l.get(U):l.has(U+1)?ee=l.get(U+1):l.has(U-1)?ee=l.get(U-1):(ee=L[1],l.set(U,L[1])),L=fr.fromValues(L[0],ee),b.push(L);const oe=L[1];(F===0||oe<R)&&(R=oe,G=F),(F===0||oe>M)&&(M=oe);let pe=c.get(oe);pe||(pe={},c.set(oe,pe)),pe[E]=!0}if(R>=M)b=[],S=0,G=-1;else{let F=i.get(R);F||(F=[],i.set(R,F)),F.push(E)}}b.reverse(),G=S-G-1,o.push(b),a.push(G)}const d=[];c.forEach((E,g)=>d.push(g)),d.sort(TC);let h=[],p=[];for(let E=0;E<d.length;E++){const g=[],b=d[E],S=c.get(b);for(let R=0;R<h.length;++R){const M=h[R],F=M.polygonindex;if(S[F]){const L=o[F],U=L.length;let ee=M.leftvertexindex,oe=M.rightvertexindex;for(;;){let Q=ee+1;if(Q>=U&&(Q=0),L[Q][1]!==b)break;ee=Q}let pe=oe-1;if(pe<0&&(pe=U-1),L[pe][1]===b&&(oe=pe),ee!==M.leftvertexindex&&ee===oe)h.splice(R,1),--R;else{M.leftvertexindex=ee,M.rightvertexindex=oe,M.topleft=L[ee],M.topright=L[oe];let Q=ee+1;Q>=U&&(Q=0),M.bottomleft=L[Q];let Se=oe-1;Se<0&&(Se=U-1),M.bottomright=L[Se]}}}let G;if(E>=d.length-1)h=[],G=null;else{G=Number(d[E+1]);const R=.5*(b+G),M=i.get(b);for(const F in M){const L=M[F],U=o[L],ee=U.length,oe=a[L];let pe=oe;for(;;){let Xe=pe+1;if(Xe>=ee&&(Xe=0),U[Xe][1]!==b||Xe===oe)break;pe=Xe}let Q=oe;for(;;){let Xe=Q-1;if(Xe<0&&(Xe=ee-1),U[Xe][1]!==b||Xe===pe)break;Q=Xe}let Se=pe+1;Se>=ee&&(Se=0);let qe=Q-1;qe<0&&(qe=ee-1);const $e={polygonindex:L,leftvertexindex:pe,rightvertexindex:Q,topleft:U[pe],topright:U[Q],bottomleft:U[Se],bottomright:U[qe]};AC(h,$e,(Xe,Ne)=>{const Ct=qn(Xe.topleft,Xe.bottomleft,R),Rt=qn(Ne.topleft,Ne.bottomleft,R);return Ct>Rt?1:Ct<Rt?-1:0})}}for(const R in h){const M=h[R];let F=qn(M.topleft,M.bottomleft,b);const L=fr.fromValues(F,b);F=qn(M.topright,M.bottomright,b);const U=fr.fromValues(F,b);F=qn(M.topleft,M.bottomleft,G);const ee=fr.fromValues(F,G);F=qn(M.topright,M.bottomright,G);const oe=fr.fromValues(F,G),pe={topleft:L,topright:U,bottomleft:ee,bottomright:oe,leftline:qr.fromPoints(qr.create(),L,ee),rightline:qr.fromPoints(qr.create(),oe,U)};if(g.length>0){const Q=g[g.length-1],Se=fr.distance(pe.topleft,Q.topright),qe=fr.distance(pe.bottomleft,Q.bottomright);Se<Pr&&qe<Pr&&(pe.topleft=Q.topleft,pe.leftline=Q.leftline,pe.bottomleft=Q.bottomleft,g.splice(g.length-1,1))}g.push(pe)}if(E>0){const R=new Set,M=new Set;for(let F=0;F<g.length;F++){const L=g[F];for(let U=0;U<p.length;U++)if(!M.has(U)){const ee=p[U];if(fr.distance(ee.bottomleft,L.topleft)<Pr&&fr.distance(ee.bottomright,L.topright)<Pr){M.add(U);const oe=qr.direction(L.leftline),pe=qr.direction(ee.leftline),Q=oe[0]-pe[0],Se=qr.direction(L.rightline),qe=qr.direction(ee.rightline),$e=Se[0]-qe[0],Xe=Math.abs(Q)<Pr,Ne=Math.abs($e)<Pr,Ct=Xe||Q>=0,Rt=Ne||$e>=0;Ct&&Rt&&(L.outpolygon=ee.outpolygon,L.leftlinecontinues=Xe,L.rightlinecontinues=Ne,R.add(U));break}}}for(let F=0;F<p.length;F++)if(!R.has(F)){const L=p[F];L.outpolygon.rightpoints.push(L.bottomright),fr.distance(L.bottomright,L.bottomleft)>Pr&&L.outpolygon.leftpoints.push(L.bottomleft),L.outpolygon.leftpoints.reverse();const ee=L.outpolygon.rightpoints.concat(L.outpolygon.leftpoints).map(pe=>s.to3D(pe)),oe=P0.fromPointsAndPlane(ee,n);oe.vertices.length&&t.push(oe)}}for(let R=0;R<g.length;R++){const M=g[R];M.outpolygon?(M.leftlinecontinues||M.outpolygon.leftpoints.push(M.topleft),M.rightlinecontinues||M.outpolygon.rightpoints.push(M.topright)):(M.outpolygon={leftpoints:[],rightpoints:[]},M.outpolygon.leftpoints.push(M.topleft),fr.distance(M.topleft,M.topright)>Pr&&M.outpolygon.rightpoints.push(M.topright))}p=g}return t};var PC=SC;const C0=Ke,CC=ot,{NEPS:OC}=st,MC=PC,RC=e=>{if(e.isRetesselated)return e;const t=C0.toPolygons(e).map((o,a)=>({vertices:o.vertices,plane:CC.plane(o),index:a})),r=LC(t),n=[];r.forEach(o=>{if(Array.isArray(o)){const a=MC(o);n.push(...a)}else n.push(o)});const s=C0.create(n);return s.isRetesselated=!0,s},LC=e=>{let t=[e];const r=[];for(let s=3;s>=0;s--){const o=[],a=s===3?15e-9:OC;t.forEach(i=>{i.sort(FC(s,a));let c=0;for(let l=1;l<i.length;l++)i[l].plane[s]-i[c].plane[s]>a&&(l-c===1?r.push(i[c]):o.push(i.slice(c,l)),c=l);i.length-c===1?r.push(i[c]):o.push(i.slice(c))}),t=o}const n=[];return t.forEach(s=>{s[0]&&(n[s[0].index]=s)}),r.forEach(s=>{n[s.index]=s}),n},FC=(e,t)=>(r,n)=>r.plane[e]-n.plane[e]>t?1:n.plane[e]-r.plane[e]>t?-1:0;var Js=RC;const{EPS:Xn}=st,O0=En,GC=(e,t)=>{if(e.polygons.length===0||t.polygons.length===0)return!1;const r=O0(e),n=r[0],s=r[1],o=O0(t),a=o[0],i=o[1];return!(a[0]-s[0]>Xn||n[0]-i[0]>Xn||a[1]-s[1]>Xn||n[1]-i[1]>Xn||a[2]-s[2]>Xn||n[2]-i[2]>Xn)};var El=GC;const M0=xr,NC=ot;let DC=class Yc{constructor(t){this.plane=null,this.front=null,this.back=null,this.polygontreenodes=[],this.parent=t}invert(){const t=[this];let r;for(let n=0;n<t.length;n++){r=t[n],r.plane&&(r.plane=M0.flip(M0.create(),r.plane)),r.front&&t.push(r.front),r.back&&t.push(r.back);const s=r.front;r.front=r.back,r.back=s}}clipPolygons(t,r){let n={node:this,polygontreenodes:t},s;const o=[];do{if(s=n.node,t=n.polygontreenodes,s.plane){const a=s.plane,i=[],c=[],l=r?i:c,u=t.length;for(let h=0;h<u;h++){const p=t[h];p.isRemoved()||p.splitByPlane(a,l,i,c,i)}s.front&&c.length>0&&o.push({node:s.front,polygontreenodes:c});const d=i.length;if(s.back&&d>0)o.push({node:s.back,polygontreenodes:i});else for(let h=0;h<d;h++)i[h].remove()}n=o.pop()}while(n!==void 0)}clipTo(t,r){let n=this;const s=[];do n.polygontreenodes.length>0&&t.rootnode.clipPolygons(n.polygontreenodes,r),n.front&&s.push(n.front),n.back&&s.push(n.back),n=s.pop();while(n!==void 0)}addPolygonTreeNodes(t){let r={node:this,polygontreenodes:t};const n=[];do{const s=r.node,o=r.polygontreenodes;if(o.length===0){r=n.pop();continue}if(!s.plane){let l=0;l=Math.floor(o.length/2);const u=o[l].getPolygon();s.plane=NC.plane(u)}const a=[],i=[],c=o.length;for(let l=0;l<c;++l)o[l].splitByPlane(s.plane,s.polygontreenodes,i,a,i);a.length>0&&(s.front||(s.front=new Yc(s)),c===a.length&&i.length===0?s.front.polygontreenodes=a:n.push({node:s.front,polygontreenodes:a})),i.length>0&&(s.back||(s.back=new Yc(s)),c===i.length&&a.length===0?s.back.polygontreenodes=i:n.push({node:s.back,polygontreenodes:i})),r=n.pop()}while(r!==void 0)}};var kC=DC;const jn=Ie,BC=(e,t,r)=>{const n=jn.subtract(jn.create(),r,t);let s=(e[3]-jn.dot(e,t))/jn.dot(e,n);return Number.isNaN(s)&&(s=0),s>1&&(s=1),s<0&&(s=0),jn.scale(n,n,s),jn.add(n,t,n),n};var IC=BC;const{EPS:Wo}=st,VC=xr,Zo=Ie,sc=ot,zC=IC,UC=(e,t)=>{const r={type:null,front:null,back:null},n=t.vertices,s=n.length,o=sc.plane(t);if(VC.equals(o,e))r.type=0;else{let a=!1,i=!1;const c=[],l=-Wo;for(let u=0;u<s;u++){const d=Zo.dot(e,n[u])-e[3],h=d<l;c.push(h),d>Wo&&(a=!0),d<l&&(i=!0)}if(!a&&!i){const u=Zo.dot(e,o);r.type=u>=0?0:1}else if(!i)r.type=2;else if(!a)r.type=3;else{r.type=4;const u=[],d=[];let h=c[0];for(let E=0;E<s;E++){const g=n[E];let b=E+1;b>=s&&(b=0);const S=c[b];if(h===S)h?d.push(g):u.push(g);else{const G=n[b],R=zC(e,g,G);h?(d.push(g),d.push(R),u.push(R)):(u.push(g),u.push(R),d.push(R))}h=S}const p=Wo*Wo;if(d.length>=3){let E=d[d.length-1];for(let g=0;g<d.length;g++){const b=d[g];Zo.squaredDistance(b,E)<p&&(d.splice(g,1),g--),E=b}}if(u.length>=3){let E=u[u.length-1];for(let g=0;g<u.length;g++){const b=u[g];Zo.squaredDistance(b,E)<p&&(u.splice(g,1),g--),E=b}}u.length>=3&&(r.front=sc.fromPointsAndPlane(u,o)),d.length>=3&&(r.back=sc.fromPointsAndPlane(d,o))}}return r};var qC=UC;const{EPS:XC}=st,jC=Ie,R0=ot,HC=qC;let YC=class ym{constructor(t,r){this.parent=t,this.children=[],this.polygon=r,this.removed=!1}addPolygons(t){if(!this.isRootNode())throw new Error("Assertion failed");const r=this;t.forEach(n=>{r.addChild(n)})}remove(){if(!this.removed){this.removed=!0,this.polygon=null;const t=this.parent.children,r=t.indexOf(this);if(r<0)throw new Error("Assertion failed");t.splice(r,1),this.parent.recursivelyInvalidatePolygon()}}isRemoved(){return this.removed}isRootNode(){return!this.parent}invert(){if(!this.isRootNode())throw new Error("Assertion failed");this.invertSub()}getPolygon(){if(!this.polygon)throw new Error("Assertion failed");return this.polygon}getPolygons(t){let r=[this];const n=[r];let s,o,a,i;for(s=0;s<n.length;++s)for(r=n[s],o=0,a=r.length;o<a;o++)i=r[o],i.polygon?t.push(i.polygon):i.children.length>0&&n.push(i.children)}splitByPlane(t,r,n,s,o){if(this.children.length){const a=[this.children];let i,c,l,u,d;for(i=0;i<a.length;i++)for(d=a[i],c=0,l=d.length;c<l;c++)u=d[c],u.children.length>0?a.push(u.children):u._splitByPlane(t,r,n,s,o)}else this._splitByPlane(t,r,n,s,o)}_splitByPlane(t,r,n,s,o){const a=this.polygon;if(a){const i=R0.measureBoundingSphere(a),c=i[3]+XC,l=i,u=jC.dot(t,l)-t[3];if(u>c)s.push(this);else if(u<-c)o.push(this);else{const d=HC(t,a);switch(d.type){case 0:r.push(this);break;case 1:n.push(this);break;case 2:s.push(this);break;case 3:o.push(this);break;case 4:if(d.front){const h=this.addChild(d.front);s.push(h)}if(d.back){const h=this.addChild(d.back);o.push(h)}break}}}}addChild(t){const r=new ym(this,t);return this.children.push(r),r}invertSub(){let t=[this];const r=[t];let n,s,o,a;for(n=0;n<r.length;n++)for(t=r[n],s=0,o=t.length;s<o;s++)a=t[s],a.polygon&&(a.polygon=R0.invert(a.polygon)),a.children.length>0&&r.push(a.children)}recursivelyInvalidatePolygon(){this.polygon=null,this.parent&&this.parent.recursivelyInvalidatePolygon()}clear(){let t=[this];const r=[t];for(let n=0;n<r.length;++n){t=r[n];const s=t.length;for(let o=0;o<s;o++){const a=t[o];a.polygon&&(a.polygon=null),a.parent&&(a.parent=null),a.children.length>0&&r.push(a.children),a.children=[]}}}toString(){let t="",r=[this];const n=[r];let s,o,a,i;for(s=0;s<n.length;++s){r=n[s];const c=" ".repeat(s);for(o=0,a=r.length;o<a;o++)i=r[o],t+=`${c}PolygonTreeNode (${i.isRootNode()}): ${i.children.length}`,i.polygon?t+=`
 ${c}polygon: ${i.polygon.vertices}
`:t+=`
`,i.children.length>0&&n.push(i.children)}return t}};var WC=YC;const ZC=kC,QC=WC;let KC=class{constructor(t){this.polygonTree=new QC,this.rootnode=new ZC(null),t&&this.addPolygons(t)}invert(){this.polygonTree.invert(),this.rootnode.invert()}clipTo(t,r=!1){this.rootnode.clipTo(t,r)}allPolygons(){const t=[];return this.polygonTree.getPolygons(t),t}addPolygons(t){const r=new Array(t.length);for(let n=0;n<t.length;n++)r[n]=this.polygonTree.addChild(t[n]);this.rootnode.addPolygonTreeNodes(r)}clear(){this.polygonTree.clear()}toString(){return"Tree: "+this.polygonTree.toString("")}};var JC=KC,$l={Tree:JC};const Qo=Ke,eO=El,{Tree:L0}=$l,tO=(e,t)=>{if(!eO(e,t))return Qo.create();const r=new L0(Qo.toPolygons(e)),n=new L0(Qo.toPolygons(t));r.invert(),n.clipTo(r),n.invert(),r.clipTo(n),n.clipTo(r),r.addPolygons(n.allPolygons()),r.invert();const s=r.allPolygons();return Qo.create(s)};var rO=tO;const nO=We,sO=Js,oO=rO,aO=(...e)=>{e=nO(e);let t=e.shift();return e.forEach(r=>{t=oO(t,r)}),t=sO(t),t};var bm=aO;const iO=We,cO=Ke,lO=Zr,fO=_l,uO=xl,dO=bm,hO=(...e)=>{e=iO(e);const t=e.map(s=>uO({z0:-1,z1:1},s)),r=dO(t),n=lO(r);return fO(n,cO.toPolygons(r))};var mO=hO;const pO=We,vO=Ks,gO=Qe,yO=Ke,bO=mO,wO=bm,_O=(...e)=>{if(e=pO(e),e.length===0)throw new Error("wrong number of arguments");if(!vO(e))throw new Error("only intersect of the types are supported");const t=e[0];return gO.isA(t)?bO(e):yO.isA(t)?wO(e):t};var xO=_O;const oc=Ie,EO=Zr,F0=Ke,$O=e=>e.sort((t,r)=>t-r).filter((t,r,n)=>!r||t!==n[r-1]),AO=(e,t,r)=>{const n=`${t}`,s=e.get(n);s===void 0?e.set(n,[r]):s.push(r)},TO=(e,t)=>{const r=`${t}`;return e.get(r)},SO=e=>{const t=EO(e),r=F0.toPolygons(e),n=r.length,s=new Map,o=oc.create();r.forEach((u,d)=>{u.vertices.forEach(h=>{AO(s,oc.snap(o,h,t),d)})});const a=r.map(u=>{let d=[];return u.vertices.forEach(h=>{d=d.concat(TO(s,oc.snap(o,h,t)))}),{e:1,d:$O(d)}});s.clear();let i=0;const c=a.length;for(let u=0;u<c;u++){const d=a[u];if(d.e>0){const h=new Array(n);h[u]=!0;do i=0,h.forEach((p,E)=>{const g=a[E];if(g.e>0){g.e=-1;for(let b=0;b<g.d.length;b++)h[g.d[b]]=!0;i++}});while(i>0);d.indexes=h}}const l=[];for(let u=0;u<c;u++)if(a[u].indexes){const d=[];a[u].indexes.forEach((h,p)=>d.push(r[p])),l.push(F0.create(d))}return l};var PO=SO;const CO=We,OO=Ke,MO=PO,RO=(...e)=>{if(e=CO(e),e.length===0)throw new Error("wrong number of arguments");const t=e.map(r=>OO.isA(r)?MO(r):r);return t.length===1?t[0]:t};var LO=RO;const Ko=Ke,FO=El,{Tree:G0}=$l,GO=(e,t)=>{if(!FO(e,t))return Ko.clone(e);const r=new G0(Ko.toPolygons(e)),n=new G0(Ko.toPolygons(t));r.invert(),r.clipTo(n),n.clipTo(r,!0),r.addPolygons(n.allPolygons()),r.invert();const s=r.allPolygons();return Ko.create(s)};var NO=GO;const DO=We,kO=Js,BO=NO,IO=(...e)=>{e=DO(e);let t=e.shift();return e.forEach(r=>{t=BO(t,r)}),t=kO(t),t};var wm=IO;const VO=We,zO=Ke,UO=Zr,qO=_l,XO=xl,jO=wm,HO=(...e)=>{e=VO(e);const t=e.map(s=>XO({z0:-1,z1:1},s)),r=jO(t),n=UO(r);return qO(n,zO.toPolygons(r))};var YO=HO;const WO=We,ZO=Ks,QO=Qe,KO=Ke,JO=YO,eM=wm,tM=(...e)=>{if(e=WO(e),e.length===0)throw new Error("wrong number of arguments");if(!ZO(e))throw new Error("only subtract of the types are supported");const t=e[0];return QO.isA(t)?JO(e):KO.isA(t)?eM(e):t};var rM=tM;const Kn=Ke,nM=El,{Tree:N0}=$l,sM=(e,t)=>{if(!nM(e,t))return oM(e,t);const r=new N0(Kn.toPolygons(e)),n=new N0(Kn.toPolygons(t));r.clipTo(n,!1),n.clipTo(r),n.invert(),n.clipTo(r),n.invert();const s=r.allPolygons().concat(n.allPolygons());return Kn.create(s)},oM=(e,t)=>{let r=Kn.toPolygons(e);return r=r.concat(Kn.toPolygons(t)),Kn.create(r)};var _m=sM;const aM=We,iM=Js,cM=_m,lM=(...e)=>{e=aM(e);let t;for(t=1;t<e.length;t+=2)e.push(cM(e[t-1],e[t]));let r=e[t-1];return r=iM(r),r};var xm=lM;const fM=We,uM=Ke,dM=Zr,hM=_l,mM=xl,pM=xm,vM=(...e)=>{e=fM(e);const t=e.map(s=>mM({z0:-1,z1:1},s)),r=pM(t),n=dM(r);return hM(n,uM.toPolygons(r))};var Em=vM;const gM=We,yM=Ks,bM=Qe,wM=Ke,_M=Em,xM=xm,EM=(...e)=>{if(e=gM(e),e.length===0)throw new Error("wrong number of arguments");if(!yM(e))throw new Error("only unions of the same type are supported");const t=e[0];return bM.isA(t)?_M(e):wM.isA(t)?xM(e):t};var Al=EM,ca={intersect:xO,scission:LO,subtract:rM,union:Al};const{EPS:$M,TAU:AM}=st,D0=Nh,Fs=hl,yt=rt,TM=Sa,SM=(e,t)=>{const r={delta:1,corners:"edge",closed:!1,segments:16};let{delta:n,corners:s,closed:o,segments:a}=Object.assign({},r,e);if(Math.abs(n)<$M)return t;let i=e.closed?TM(t):1;i===0&&(i=1);const c=i>0&&n>=0||i<0&&n<0;n=Math.abs(n);let l=null,u=[];const d=[],h=yt.create(),p=t.length;for(let E=0;E<p;E++){const g=(E+1)%p,b=t[E],S=t[g];c?yt.subtract(h,b,S):yt.subtract(h,S,b),yt.normal(h,h),yt.normalize(h,h),yt.scale(h,h,n);const G=yt.add(yt.create(),b,h),R=yt.add(yt.create(),S,h),M=[G,R];if(l!=null&&(o||!o&&g!==0)){const F=D0(l[0],l[1],M[0],M[1]);F?(u.pop(),M[0]=F):d.push({c:b,s0:l,s1:M})}l=[G,R],!(g===0&&!o)&&(u.push(M[0]),u.push(M[1]))}if(o&&l!=null){const E=u[0],g=u[1],b=D0(l[0],l[1],E,g);if(b)u[0]=b,u.pop();else{const S=t[0],G=[E,g];d.push({c:S,s0:l,s1:G})}}if(s==="edge"){const E=new Map;u.forEach((S,G)=>E.set(S,G));const g=Fs.create(),b=Fs.create();d.forEach(S=>{Fs.fromPoints(g,S.s0[0],S.s0[1]),Fs.fromPoints(b,S.s1[0],S.s1[1]);const G=Fs.intersectPointOfLines(g,b);if(Number.isFinite(G[0])&&Number.isFinite(G[1])){const R=S.s0[1],M=E.get(R);u[M]=G,u[(M+1)%u.length]=void 0}else{const R=S.s1[0],M=E.get(R);u[M]=void 0}}),u=u.filter(S=>S!==void 0)}if(s==="round"){let E=Math.floor(a/4);const g=yt.create();d.forEach(b=>{let S=yt.angle(yt.subtract(g,b.s1[0],b.c));if(S-=yt.angle(yt.subtract(g,b.s0[1],b.c)),c&&S<0&&(S=S+Math.PI,S<0&&(S=S+Math.PI)),!c&&S>0&&(S=S-Math.PI,S>0&&(S=S-Math.PI)),S!==0){E=Math.floor(a*(Math.abs(S)/AM));const G=S/E,R=yt.angle(yt.subtract(g,b.s0[1],b.c)),M=[];for(let F=1;F<E;F++){const L=R+G*F,U=yt.fromAngleRadians(yt.create(),L);yt.scale(U,U,n),yt.add(U,U,b.c),M.push(U)}if(M.length>0){const F=b.s0[1];let L=u.findIndex(U=>yt.equals(F,U));L=(L+1)%u.length,u.splice(L,0,...M)}}else{const G=b.s1[0],R=u.findIndex(M=>yt.equals(G,M));u.splice(R,1)}})}return u};var Fa=SM;const Jo=Qe,PM=Fa,CM=(e,t)=>{const r={delta:1,corners:"edge",segments:16},{delta:n,corners:s,segments:o}=Object.assign({},r,e);if(!(s==="edge"||s==="chamfer"||s==="round"))throw new Error('corners must be "edge", "chamfer", or "round"');const c=Jo.toOutlines(t).map(l=>(e={delta:n,corners:s,closed:!0,segments:o},PM(e,l))).reduce((l,u)=>l.concat(Jo.toSides(Jo.fromPoints(u))),[]);return Jo.create(c)};var OM=CM;const k0=ft,MM=Ie,RM=Ke,Gs=ot,LM=(e,t)=>{MM.dot(Gs.plane(t),e)>0&&(t=Gs.invert(t));const n=[t],s=Gs.transform(k0.fromTranslation(k0.create(),e),t),o=t.vertices.length;for(let a=0;a<o;a++){const i=a<o-1?a+1:0,c=Gs.create([t.vertices[a],s.vertices[a],s.vertices[i],t.vertices[i]]);n.push(c)}return n.push(Gs.invert(s)),RM.create(n)};var FM=LM;const{EPS:GM,TAU:ac}=st,B0=ft,ut=Ie,NM=gm,ic=Ke,gn=ot,DM=am,kM=Js,cc=_m,BM=FM,IM=(e,t,r)=>{const n=t.toString();if(e.has(n))e.get(n)[1].push(r);else{const s=[t,[r]];e.set(n,s)}},VM=(e,t,r)=>{const n=t[0].toString(),s=t[1].toString(),o=n<s?`${n},${s}`:`${s},${n}`;if(e.has(o))e.get(o)[1].push(r);else{const a=[t,[r]];e.set(o,a)}},lc=(e,t)=>{e.findIndex(n=>n===t)<0&&e.push(t)},zM=(e,t)=>{const r={delta:1,segments:12},{delta:n,segments:s}=Object.assign({},r,e);let o=ic.create();const a=new Map,i=new Map,c=ut.create(),l=ut.create();return ic.toPolygons(t).forEach((d,h)=>{const p=ut.scale(ut.create(),gn.plane(d),2*n),E=gn.transform(B0.fromTranslation(B0.create(),ut.scale(ut.create(),p,-.5)),d),g=BM(p,E);o=cc(o,g);const b=d.vertices;for(let S=0;S<b.length;S++){IM(a,b[S],gn.plane(d));const G=(S+1)%b.length,R=[b[S],b[G]];VM(i,R,gn.plane(d))}}),i.forEach(d=>{const h=d[0],p=d[1],E=h[0],g=h[1],b=ut.subtract(ut.create(),g,E);ut.normalize(b,b);const S=p[0],G=ut.cross(ut.create(),S,b);let R=[];for(let Q=0;Q<s;Q++)lc(R,Q*ac/s);for(let Q=0,Se=p.length;Q<Se;Q++){const qe=p[Q],$e=ut.dot(G,qe),Xe=ut.dot(S,qe);let Ne=Math.atan2($e,Xe);Ne<0&&(Ne+=ac),lc(R,Ne),Ne=Math.atan2(-$e,-Xe),Ne<0&&(Ne+=ac),lc(R,Ne)}R=R.sort(NM);const M=R.length;let F,L;const U=[],ee=[],oe=[];for(let Q=-1;Q<M;Q++){const Se=R[Q<0?Q+M:Q],qe=Math.sin(Se),$e=Math.cos(Se);ut.scale(c,S,$e*n),ut.scale(l,G,qe*n),ut.add(c,c,l);const Xe=ut.add(ut.create(),E,c),Ne=ut.add(ut.create(),g,c);let Ct=!1;if(Q>=0&&ut.distance(Xe,F)<GM&&(Ct=!0),!Ct){if(Q>=0){U.push(Xe),ee.push(Ne);const Rt=[L,Ne,Xe,F],Or=gn.create(Rt);oe.push(Or)}F=Xe,L=Ne}}ee.reverse(),oe.push(gn.create(U)),oe.push(gn.create(ee));const pe=ic.create(oe);o=cc(o,pe)}),a.forEach(d=>{const h=d[0],p=d[1],E=p[0];let g=null,b=0;for(let M=1;M<p.length;M++){const F=p[M],L=ut.cross(c,E,F),U=ut.length(L);U>.05&&U>b&&(b=U,g=F)}g||(g=ut.orthogonal(c,E));const S=ut.cross(c,E,g);ut.normalize(S,S);const G=ut.cross(l,S,E),R=DM({center:[h[0],h[1],h[2]],radius:n,segments:s,axes:[E,S,G]});o=cc(o,R)}),kM(o)};var UM=zM;const qM=Ke,XM=Al,jM=UM,HM=(e,t)=>{const r={delta:1,corners:"round",segments:12},{delta:n,corners:s,segments:o}=Object.assign({},r,e);if(s!=="round")throw new Error('corners must be "round" for 3D geometries');if(qM.toPolygons(t).length===0)throw new Error("the given geometry cannot be empty");e={delta:n,corners:s,segments:o};const i=jM(e,t);return XM(t,i)};var YM=HM;const WM=Sa,Ht=rt,Zn=Qe,qs=ct,I0=Fa,ZM=e=>{let{external:t,internal:r}=e;WM(t)<0?t=t.reverse():r=r.reverse();const n=qs.fromPoints({closed:!0},t),s=qs.fromPoints({closed:!0},r),o=Zn.toSides(Zn.fromPoints(qs.toPoints(n))),a=Zn.toSides(Zn.fromPoints(qs.toPoints(s)));return o.push(...a),Zn.create(o)},QM=(e,t,r,n)=>{const{points:s,external:o,internal:a}=e,i=Math.floor(t/2),c=[],l=[];if(r==="round"&&i>0){const d=Math.PI/i,h=s[s.length-1],p=Ht.angle(Ht.subtract(Ht.create(),o[o.length-1],h)),E=s[0],g=Ht.angle(Ht.subtract(Ht.create(),a[0],E));for(let b=1;b<i;b++){let S=p+d*b,G=Ht.fromAngleRadians(Ht.create(),S);Ht.scale(G,G,n),Ht.add(G,G,h),c.push(G),S=g+d*b,G=Ht.fromAngleRadians(Ht.create(),S),Ht.scale(G,G,n),Ht.add(G,G,E),l.push(G)}}const u=[];return u.push(...o,...c,...a.reverse(),...l),Zn.fromPoints(u)},KM=(e,t)=>{e=Object.assign({},{delta:1,corners:"edge",segments:16},e);const{delta:n,corners:s,segments:o}=e;if(n<=0)throw new Error("the given delta must be positive for paths");if(!(s==="edge"||s==="chamfer"||s==="round"))throw new Error('corners must be "edge", "chamfer", or "round"');const a=t.isClosed,i=qs.toPoints(t);if(i.length===0)throw new Error("the given geometry cannot be empty");const c={points:i,external:I0({delta:n,corners:s,segments:o,closed:a},i),internal:I0({delta:-n,corners:s,segments:o,closed:a},i)};return t.isClosed?ZM(c):QM(c,o,s,n)};var JM=KM;const e6=We,t6=Qe,r6=Ke,n6=ct,s6=OM,o6=YM,a6=JM,i6=(e,...t)=>{if(t=e6(t),t.length===0)throw new Error("wrong number of arguments");const r=t.map(n=>n6.isA(n)?a6(e,n):t6.isA(n)?s6(e,n):r6.isA(n)?o6(e,n):n);return r.length===1?r[0]:r};var Tl=i6;const ea=Qe,V0=cl,c6=Fa,l6=(e,t)=>{const r={delta:1,corners:"edge",segments:0},{delta:n,corners:s,segments:o}=Object.assign({},r,e);if(!(s==="edge"||s==="chamfer"||s==="round"))throw new Error('corners must be "edge", "chamfer", or "round"');const a=ea.toOutlines(t),c=a.map(l=>(e={delta:a.reduce((h,p)=>h+V0.arePointsInside(l,V0.create(p)),0)%2===0?n:-n,corners:s,closed:!0,segments:o},c6(e,l))).reduce((l,u)=>l.concat(ea.toSides(ea.fromPoints(u))),[]);return ea.create(c)};var f6=l6;const z0=ct,u6=Fa,d6=(e,t)=>{const r={delta:1,corners:"edge",closed:t.isClosed,segments:16},{delta:n,corners:s,closed:o,segments:a}=Object.assign({},r,e);if(!(s==="edge"||s==="chamfer"||s==="round"))throw new Error('corners must be "edge", "chamfer", or "round"');e={delta:n,corners:s,closed:o,segments:a};const i=u6(e,z0.toPoints(t));return z0.fromPoints({closed:o},i)};var h6=d6;const m6=We,p6=Qe,v6=ct,g6=f6,y6=h6,b6=(e,...t)=>{if(t=m6(t),t.length===0)throw new Error("wrong number of arguments");const r=t.map(n=>v6.isA(n)?y6(e,n):p6.isA(n)?g6(e,n):n);return r.length===1?r[0]:r};var w6=b6,_6={expand:Tl,offset:w6};const Ns=ft,fc=Ie,x6=Qe,uc=as,E6=Ma,$6=(e,t)=>{const r={offset:[0,0,1],twistAngle:0,twistSteps:12,repair:!0};let{offset:n,twistAngle:s,twistSteps:o,repair:a}=Object.assign({},r,e);if(o<1)throw new Error("twistSteps must be 1 or more");s===0&&(o=1);const i=fc.clone(n),c=x6.toSides(t);if(c.length===0)throw new Error("the given geometry cannot be empty");const l=uc.fromSides(c);i[2]<0&&uc.reverse(l,l);const u=Ns.create(),d=(h,p,E)=>{const g=p/o*s,b=fc.scale(fc.create(),i,p/o);return Ns.multiply(u,Ns.fromZRotation(u,g),Ns.fromTranslation(Ns.create(),b)),uc.transform(u,E)};return e={numberOfSlices:o+1,capStart:!0,capEnd:!0,repair:a,callback:d},E6(e,l)};var Ga=$6;const A6=Qe,T6=ct,S6=Ga,P6=(e,t)=>{if(!t.isClosed)throw new Error("extruded path must be closed");const r=T6.toPoints(t),n=A6.fromPoints(r);return S6(e,n)};var C6=P6;const O6=We,M6=Qe,R6=ct,L6=Ga,F6=C6,G6=(e,...t)=>{const r={height:1,twistAngle:0,twistSteps:1,repair:!0},{height:n,twistAngle:s,twistSteps:o,repair:a}=Object.assign({},r,e);if(t=O6(t),t.length===0)throw new Error("wrong number of arguments");e={offset:[0,0,n],twistAngle:s,twistSteps:o,repair:a};const i=t.map(c=>R6.isA(c)?F6(e,c):M6.isA(c)?L6(e,c):c);return i.length===1?i[0]:i};var N6=G6;const D6=ct,k6=Tl,B6=Ga,I6=(e,t)=>{const r={size:1,height:1},{size:n,height:s}=Object.assign({},r,e);if(e.delta=n,e.offset=[0,0,s],D6.toPoints(t).length===0)throw new Error("the given geometry cannot be empty");const a=k6(e,t);return B6(e,a)};var V6=I6;const{area:z6}=Zs,dc=Qe,U6=ct,q6=Tl,X6=Ga,j6=(e,t)=>{const r={size:1,height:1},{size:n,height:s}=Object.assign({},r,e);e.delta=n,e.offset=[0,0,s];const o=dc.toOutlines(t);if(o.length===0)throw new Error("the given geometry cannot be empty");const i=o.map(l=>(z6(l)<0&&l.reverse(),q6(e,U6.fromPoints({closed:!0},l)))).reduce((l,u)=>l.concat(dc.toSides(u)),[]),c=dc.create(i);return X6(e,c)};var H6=j6;const Y6=We,W6=Qe,Z6=ct,Q6=V6,K6=H6,J6=(e,...t)=>{const r={size:1,height:1},{size:n,height:s}=Object.assign({},r,e);if(t=Y6(t),t.length===0)throw new Error("wrong number of arguments");if(n<=0)throw new Error("size must be positive");if(s<=0)throw new Error("height must be positive");const o=t.map(a=>Z6.isA(a)?Q6(e,a):W6.isA(a)?K6(e,a):a);return o.length===1?o[0]:o};var eR=J6;const{TAU:Ds}=st,hc=as,yr=ft,tR=Ma,rR=Qe,nR=(e,t)=>{const r={angle:Ds,startAngle:0,pitch:10,endOffset:0,segmentsPerRotation:32},{angle:n,endOffset:s,segmentsPerRotation:o,startAngle:a}=Object.assign({},r,e);let i;if(!e.pitch&&e.height?i=e.height/(n/Ds):i=e.pitch?e.pitch:r.pitch,o<3)throw new Error("The number of segments per rotation needs to be at least 3.");const l=rR.toSides(t);if(l.length===0)throw new Error("the given geometry cannot be empty");const u=l.filter(S=>S[0][0]>=0);let d=hc.fromSides(l);u.length===0&&(d=hc.reverse(d));const h=Math.round(o/Ds*Math.abs(n)),p=h>=2?h:2,E=yr.create();let g;const b=(S,G,R)=>{const M=a+n/p*G,F=s/p*G,L=(M-a)/Ds*i;return yr.multiply(E,yr.fromTranslation(yr.create(),[F,0,L*Math.sign(n)]),yr.fromXRotation(yr.create(),-Ds/4*Math.sign(n))),g=yr.create(),yr.multiply(g,yr.fromZRotation(yr.create(),M),E),hc.transform(g,R)};return tR({numberOfSlices:p+1,callback:b},d)};var sR=nR;const oR=We,U0=dl,mc=xr,q0=ft,X0=Qe,$m=Ke,Hn=ot,aR=Zr,iR=Em,cR=(e,t)=>{const r=mc.fromNormalAndPoint(mc.create(),e.axis,e.origin);if(Number.isNaN(r[0])||Number.isNaN(r[1])||Number.isNaN(r[2])||Number.isNaN(r[3]))throw new Error("project: invalid axis or origin");const n=aR(t),s=n*n*Math.sqrt(3)/4;if(n===0)return X0.create();const o=$m.toPolygons(t);let a=[];for(let c=0;c<o.length;c++){const l=o[c].vertices.map(h=>mc.projectionOfPoint(r,h)),u=Hn.create(l),d=Hn.plane(u);U0(r,d)&&(Hn.measureArea(u)<s||a.push(u))}if(!U0(r,[0,0,1])){const c=q0.fromVectorRotation(q0.create(),r,[0,0,1]);a=a.map(l=>Hn.transform(c,l))}a=a.sort((c,l)=>Hn.measureArea(l)-Hn.measureArea(c));const i=a.map(c=>X0.fromPoints(c.vertices));return iR(i)},lR=(e,...t)=>{const r={axis:[0,0,1],origin:[0,0,0]},{axis:n,origin:s}=Object.assign({},r,e);if(t=oR(t),t.length===0)throw new Error("wrong number of arguments");e={axis:n,origin:s};const o=t.map(a=>$m.isA(a)?cR(e,a):a);return o.length===1?o[0]:o};var fR=lR,uR={extrudeFromSlices:Ma,extrudeLinear:N6,extrudeRectangular:eR,extrudeRotate:mm,extrudeHelical:sR,project:fR,slice:as};const j0=rt,dR=e=>{let t=j0.fromValues(1/0,1/0);e.forEach(s=>{(s[1]<t[1]||s[1]===t[1]&&s[0]<t[0])&&(t=s)});const r=[];e.forEach(s=>{const o=mR(s[1]-t[1],s[0]-t[0]),a=j0.squaredDistance(s,t);r.push({point:s,angle:o,distSq:a})}),r.sort((s,o)=>s.angle!==o.angle?s.angle-o.angle:s.distSq-o.distSq);const n=[];return r.forEach(s=>{let o=n.length;for(;o>1&&hR(n[o-2],n[o-1],s.point)<=Number.EPSILON;)n.pop(),o=n.length;n.push(s.point)}),n},hR=(e,t,r)=>(t[0]-e[0])*(r[1]-e[1])-(t[1]-e[1])*(r[0]-e[0]),mR=(e,t)=>e===0&&t===0?-1/0:-t/e;var Am=dR;const H0=Qe,Y0=Ke,W0=ct,pR=e=>{const t=new Set,r=[],n=s=>{const o=s.toString();t.has(o)||(r.push(s),t.add(o))};return e.forEach(s=>{H0.isA(s)?H0.toPoints(s).forEach(n):Y0.isA(s)?Y0.toPoints(s).forEach(o=>o.forEach(n)):W0.isA(s)&&W0.toPoints(s).forEach(n)}),r};var Sl=pR;const vR=We,gR=ct,yR=Am,bR=Sl,wR=(...e)=>{e=vR(e);const t=bR(e),r=yR(t);return gR.fromPoints({closed:!0},r)};var _R=wR;const xR=We,Z0=Qe,ER=Am,$R=Sl,AR=(...e)=>{e=xR(e);const t=$R(e),r=ER(t);return r.length<3?Z0.create():Z0.fromPoints(r)};var TR=AR;const SR=Ys,Q0=wa,K0=Kd,PR=(e,t,r)=>{const n=[],s=[],o=[];Q0(n,r,t),Q0(s,e,t);const a=K0(SR(o,s,n)),i=K0(n);if(i===0)throw Error("a and b are the same point");return a/i},CR=(e,t,r)=>Math.sqrt(PR(e,t,r));var OR=CR;const MR=Ys,RR=rl,J0=wa,LR=(e,t,r,n)=>{const s=[0,0,0];return J0(e,t,r),J0(s,r,n),MR(e,e,s),RR(e,e)};var FR=LR;let GR=class{constructor(){this.head=null,this.tail=null}clear(){this.head=this.tail=null}insertBefore(t,r){r.prev=t.prev,r.next=t,r.prev?r.prev.next=r:this.head=r,t.prev=r}insertAfter(t,r){r.prev=t,r.next=t.next,r.next?r.next.prev=r:this.tail=r,t.next=r}add(t){this.head?this.tail.next=t:this.head=t,t.prev=this.tail,t.next=null,this.tail=t}addAll(t){for(this.head?this.tail.next=t:this.head=t,t.prev=this.tail;t.next;)t=t.next;this.tail=t}remove(t){t.prev?t.prev.next=t.next:this.head=t.next,t.next?t.next.prev=t.prev:this.tail=t.prev}removeChain(t,r){t.prev?t.prev.next=r.next:this.head=r.next,r.next?r.next.prev=t.prev:this.tail=t.prev}first(){return this.head}isEmpty(){return!this.head}};var NR=GR;let DR=class{constructor(t,r){this.point=t,this.index=r,this.next=null,this.prev=null,this.face=null}};var kR=DR;const BR=jd,IR=Qd;let VR=class{constructor(t,r){this.vertex=t,this.face=r,this.next=null,this.prev=null,this.opposite=null}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){return this.tail()?BR(this.tail().point,this.head().point):-1}lengthSquared(){return this.tail()?IR(this.tail().point,this.head().point):-1}setOpposite(t){this.opposite=t,t.opposite=this}};var zR=VR;const pc=qd,UR=Xd,qR=Ys,vc=ya,XR=Hd,jR=rl,ta=Zd,gc=wa,yc=zR,Tm=0,HR=1,Wc=2;let YR=class Sm{constructor(){this.normal=[],this.centroid=[],this.offset=0,this.outside=null,this.mark=Tm,this.edge=null,this.nVertices=0}getEdge(t){if(typeof t!="number")throw Error("requires a number");let r=this.edge;for(;t>0;)r=r.next,t-=1;for(;t<0;)r=r.prev,t+=1;return r}computeNormal(){const t=this.edge,r=t.next;let n=r.next;const s=gc([],r.head().point,t.head().point),o=[],a=[];for(this.nVertices=2,this.normal=[0,0,0];n!==t;)UR(a,s),gc(s,n.head().point,t.head().point),pc(this.normal,this.normal,qR(o,a,s)),n=n.next,this.nVertices+=1;this.area=XR(this.normal),this.normal=ta(this.normal,this.normal,1/this.area)}computeNormalMinArea(t){if(this.computeNormal(),this.area<t){let r,n=0,s=this.edge;do{const u=s.lengthSquared();u>n&&(r=s,n=u),s=s.next}while(s!==this.edge);const o=r.tail().point,a=r.head().point,i=gc([],a,o),c=Math.sqrt(n);ta(i,i,1/c);const l=vc(this.normal,i);ta(i,i,-l),pc(this.normal,this.normal,i),jR(this.normal,this.normal)}}computeCentroid(){this.centroid=[0,0,0];let t=this.edge;do pc(this.centroid,this.centroid,t.head().point),t=t.next;while(t!==this.edge);ta(this.centroid,this.centroid,1/this.nVertices)}computeNormalAndCentroid(t){typeof t<"u"?this.computeNormalMinArea(t):this.computeNormal(),this.computeCentroid(),this.offset=vc(this.normal,this.centroid)}distanceToPlane(t){return vc(this.normal,t)-this.offset}connectHalfEdges(t,r){let n;if(t.opposite.face===r.opposite.face){const s=r.opposite.face;let o;t===this.edge&&(this.edge=r),s.nVertices===3?(o=r.opposite.prev.opposite,s.mark=Wc,n=s):(o=r.opposite.next,s.edge===o.prev&&(s.edge=o),o.prev=o.prev.prev,o.prev.next=o),r.prev=t.prev,r.prev.next=r,r.setOpposite(o),s.computeNormalAndCentroid()}else t.next=r,r.prev=t;return n}mergeAdjacentFaces(t,r){const n=t.opposite,s=n.face;r.push(s),s.mark=Wc;let o=t.prev,a=t.next,i=n.prev,c=n.next;for(;o.opposite.face===s;)o=o.prev,c=c.next;for(;a.opposite.face===s;)a=a.next,i=i.prev;let l;for(l=c;l!==i.next;l=l.next)l.face=this;this.edge=a;let u;return u=this.connectHalfEdges(i,a),u&&r.push(u),u=this.connectHalfEdges(o,c),u&&r.push(u),this.computeNormalAndCentroid(),r}collectIndices(){const t=[];let r=this.edge;do t.push(r.head().index),r=r.next;while(r!==this.edge);return t}static createTriangle(t,r,n,s=0){const o=new Sm,a=new yc(t,o),i=new yc(r,o),c=new yc(n,o);return a.next=c.prev=i,i.next=a.prev=c,c.next=i.prev=a,o.edge=a,o.computeNormalAndCentroid(s),o}};var WR={VISIBLE:Tm,NON_CONVEX:HR,DELETED:Wc,Face:YR};const bc=ya,ZR=OR,QR=FR,ed=NR,KR=kR,{Face:Cr,VISIBLE:Yn,NON_CONVEX:td,DELETED:JR}=WR,eL=1,rd=2;let tL=class{constructor(t){if(!Array.isArray(t))throw TypeError("input is not a valid array");if(t.length<4)throw Error("cannot build a simplex out of <4 points");this.tolerance=-1,this.nFaces=0,this.nPoints=t.length,this.faces=[],this.newFaces=[],this.claimed=new ed,this.unclaimed=new ed,this.vertices=[];for(let r=0;r<t.length;r+=1)this.vertices.push(new KR(t[r],r));this.discardedFaces=[],this.vertexPointIndices=[]}addVertexToFace(t,r){t.face=r,r.outside?this.claimed.insertBefore(r.outside,t):this.claimed.add(t),r.outside=t}removeVertexFromFace(t,r){t===r.outside&&(t.next&&t.next.face===r?r.outside=t.next:r.outside=null),this.claimed.remove(t)}removeAllVerticesFromFace(t){if(t.outside){let r=t.outside;for(;r.next&&r.next.face===t;)r=r.next;return this.claimed.removeChain(t.outside,r),r.next=null,t.outside}}deleteFaceVertices(t,r){const n=this.removeAllVerticesFromFace(t);if(n)if(!r)this.unclaimed.addAll(n);else{let s;for(let o=n;o;o=s)s=o.next,r.distanceToPlane(o.point)>this.tolerance?this.addVertexToFace(o,r):this.unclaimed.add(o)}}resolveUnclaimedPoints(t){let r=this.unclaimed.first();for(let n=r;n;n=r){r=n.next;let s=this.tolerance,o;for(let a=0;a<t.length;a+=1){const i=t[a];if(i.mark===Yn){const c=i.distanceToPlane(n.point);if(c>s&&(s=c,o=i),s>1e3*this.tolerance)break}}o&&this.addVertexToFace(n,o)}}computeExtremes(){const t=[],r=[],n=[],s=[];let o,a;for(o=0;o<3;o+=1)n[o]=s[o]=this.vertices[0];for(o=0;o<3;o+=1)t[o]=r[o]=this.vertices[0].point[o];for(o=1;o<this.vertices.length;o+=1){const i=this.vertices[o],c=i.point;for(a=0;a<3;a+=1)c[a]<t[a]&&(t[a]=c[a],n[a]=i);for(a=0;a<3;a+=1)c[a]>r[a]&&(r[a]=c[a],s[a]=i)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(t[0]),Math.abs(r[0]))+Math.max(Math.abs(t[1]),Math.abs(r[1]))+Math.max(Math.abs(t[2]),Math.abs(r[2]))),[n,s]}createInitialSimplex(){const t=this.vertices,[r,n]=this.computeExtremes();let s,o,a,i,c=0,l=0;for(a=0;a<3;a+=1){const g=n[a].point[a]-r[a].point[a];g>c&&(c=g,l=a)}const u=r[l],d=n[l];for(c=0,a=0;a<this.vertices.length;a+=1){const g=this.vertices[a];if(g!==u&&g!==d){const b=ZR(g.point,u.point,d.point);b>c&&(c=b,s=g)}}const h=QR([],u.point,d.point,s.point),p=bc(u.point,h);for(c=-1,a=0;a<this.vertices.length;a+=1){const g=this.vertices[a];if(g!==u&&g!==d&&g!==s){const b=Math.abs(bc(h,g.point)-p);b>c&&(c=b,o=g)}}const E=[];if(bc(o.point,h)-p<0)for(E.push(Cr.createTriangle(u,d,s),Cr.createTriangle(o,d,u),Cr.createTriangle(o,s,d),Cr.createTriangle(o,u,s)),a=0;a<3;a+=1){const g=(a+1)%3;E[a+1].getEdge(2).setOpposite(E[0].getEdge(g)),E[a+1].getEdge(1).setOpposite(E[g+1].getEdge(0))}else for(E.push(Cr.createTriangle(u,s,d),Cr.createTriangle(o,u,d),Cr.createTriangle(o,d,s),Cr.createTriangle(o,s,u)),a=0;a<3;a+=1){const g=(a+1)%3;E[a+1].getEdge(2).setOpposite(E[0].getEdge((3-a)%3)),E[a+1].getEdge(0).setOpposite(E[g+1].getEdge(1))}for(a=0;a<4;a+=1)this.faces.push(E[a]);for(a=0;a<t.length;a+=1){const g=t[a];if(g!==u&&g!==d&&g!==s&&g!==o){c=this.tolerance;let b;for(i=0;i<4;i+=1){const S=E[i].distanceToPlane(g.point);S>c&&(c=S,b=E[i])}b&&this.addVertexToFace(g,b)}}}reindexFaceAndVertices(){const t=[];for(let r=0;r<this.faces.length;r+=1){const n=this.faces[r];n.mark===Yn&&t.push(n)}this.faces=t}collectFaces(t){const r=[];for(let n=0;n<this.faces.length;n+=1){if(this.faces[n].mark!==Yn)throw Error("attempt to include a destroyed face in the hull");const s=this.faces[n].collectIndices();if(t)r.push(s);else for(let o=0;o<s.length-2;o+=1)r.push([s[0],s[o+1],s[o+2]])}return r}nextVertexToAdd(){if(!this.claimed.isEmpty()){let t,r,n=0;const s=this.claimed.first().face;for(r=s.outside;r&&r.face===s;r=r.next){const o=s.distanceToPlane(r.point);o>n&&(n=o,t=r)}return t}}computeHorizon(t,r,n,s){this.deleteFaceVertices(n),n.mark=JR;let o;r?o=r.next:o=r=n.getEdge(0);do{const a=o.opposite,i=a.face;i.mark===Yn&&(i.distanceToPlane(t)>this.tolerance?this.computeHorizon(t,a,i,s):s.push(o)),o=o.next}while(o!==r)}addAdjoiningFace(t,r){const n=Cr.createTriangle(t,r.tail(),r.head());return this.faces.push(n),n.getEdge(-1).setOpposite(r.opposite),n.getEdge(0)}addNewFaces(t,r){this.newFaces=[];let n,s;for(let o=0;o<r.length;o+=1){const a=r[o],i=this.addAdjoiningFace(t,a);n?i.next.setOpposite(s):n=i,this.newFaces.push(i.face),s=i}n.next.setOpposite(s)}oppositeFaceDistance(t){return t.face.distanceToPlane(t.opposite.face.centroid)}doAdjacentMerge(t,r){let n=t.edge,s=!0,o=0;do{if(o>=t.nVertices)throw Error("merge recursion limit exceeded");const a=n.opposite.face;let i=!1;if(r===rd?(this.oppositeFaceDistance(n)>-this.tolerance||this.oppositeFaceDistance(n.opposite)>-this.tolerance)&&(i=!0):t.area>a.area?this.oppositeFaceDistance(n)>-this.tolerance?i=!0:this.oppositeFaceDistance(n.opposite)>-this.tolerance&&(s=!1):this.oppositeFaceDistance(n.opposite)>-this.tolerance?i=!0:this.oppositeFaceDistance(n)>-this.tolerance&&(s=!1),i){const c=t.mergeAdjacentFaces(n,[]);for(let l=0;l<c.length;l+=1)this.deleteFaceVertices(c[l],t);return!0}n=n.next,o+=1}while(n!==t.edge);return s||(t.mark=td),!1}addVertexToHull(t){const r=[];this.unclaimed.clear(),this.removeVertexFromFace(t,t.face),this.computeHorizon(t.point,null,t.face,r),this.addNewFaces(t,r);for(let n=0;n<this.newFaces.length;n+=1){const s=this.newFaces[n];if(s.mark===Yn)for(;this.doAdjacentMerge(s,eL););}for(let n=0;n<this.newFaces.length;n+=1){const s=this.newFaces[n];if(s.mark===td)for(s.mark=Yn;this.doAdjacentMerge(s,rd););}this.resolveUnclaimedPoints(this.newFaces)}build(){let t;for(this.createInitialSimplex();t=this.nextVertexToAdd();)this.addVertexToHull(t);this.reindexFaceAndVertices()}};var rL=tL;const nL=rL,sL=(e,t={})=>{const r=new nL(e);return r.build(),r.collectFaces(t.skipTriangulation)};var oL=sL;const aL=We,iL=Ke,cL=ot,lL=oL,fL=Sl,uL=(...e)=>{if(e=aL(e),e.length===1)return e[0];const t=fL(e),n=lL(t,{skipTriangulation:!0}).map(s=>{const o=s.map(a=>t[a]);return cL.create(o)});return iL.create(n)};var dL=uL;const hL=We,mL=Ks,pL=Qe,vL=Ke,gL=ct,yL=_R,bL=TR,wL=dL,_L=(...e)=>{if(e=hL(e),e.length===0)throw new Error("wrong number of arguments");if(!mL(e))throw new Error("only hulls of the same type are supported");const t=e[0];return gL.isA(t)?yL(e):pL.isA(t)?bL(e):vL.isA(t)?wL(e):t};var Pm=_L;const xL=We,EL=Al,$L=Pm,AL=(...e)=>{if(e=xL(e),e.length<2)throw new Error("wrong number of arguments");const t=[];for(let r=1;r<e.length;r++)t.push($L(e[r-1],e[r]));return EL(t)};var TL=AL,SL={hull:Pm,hullChain:TL};const wc=Ie,Cm=ot,PL=(e,t)=>{const r=Math.abs(Cm.measureArea(t));return Number.isFinite(r)&&r>e},CL=(e,t)=>{let r=t.map(s=>{const o=s.vertices.map(c=>wc.snap(wc.create(),c,e)),a=[];for(let c=0;c<o.length;c++){const l=(c+1)%o.length;wc.equals(o[c],o[l])||a.push(o[c])}const i=Cm.create(a);return s.color&&(i.color=s.color),i});const n=e*e*Math.sqrt(3)/4;return r=r.filter(s=>PL(n,s)),r};var Om=CL;const OL=dl,Qn=Ie,pa=ot,ML=e=>{const t=pa.toPoints(e),r=[];for(let n=0;n<t.length;n++){const s=(n+1)%t.length,o={v1:t[n],v2:t[s]};r.push(o)}for(let n=0;n<r.length;n++){const s=(n+1)%t.length;r[n].next=r[s],r[s].prev=r[n]}return r},RL=(e,t)=>{const r=`${t.v1}:${t.v2}`;e.set(r,t)},_c=(e,t)=>{const r=`${t.v1}:${t.v2}`;e.delete(r)},LL=(e,t)=>{const r=`${t.v2}:${t.v1}`;return e.get(r)},FL=(e,t,r)=>{let n=e.prev.v1,s=e.prev.v2,o=t.next.v2;const a=nd(n,s,o,r);n=t.prev.v1,s=t.prev.v2,o=e.next.v2;const i=nd(n,s,o,r);return[a,i]},GL=Qn.create(),NL=Qn.create(),nd=(e,t,r,n)=>{const s=Qn.subtract(GL,t,e),o=Qn.subtract(NL,r,t);return Qn.cross(s,s,o),Qn.dot(s,n)},DL=e=>{let t;const r=[];for(;e.next;){const n=e.next;r.push(e.v1),e.v1=null,e.v2=null,e.next=null,e.prev=null,e=n}return r.length>0&&(t=pa.create(r)),t},kL=e=>{if(e.length<2)return e;const t=e[0].plane,r=e.slice(),n=new Map;for(;r.length>0;){const o=r.shift(),a=ML(o);for(let i=0;i<a.length;i++){const c=a[i],l=LL(n,c);if(l){const u=FL(c,l,t);if(u[0]>=0&&u[1]>=0){const d=l.next,h=c.next;c.prev.next=l.next,c.next.prev=l.prev,l.prev.next=c.next,l.next.prev=c.prev,c.v1=null,c.v2=null,c.next=null,c.prev=null,_c(n,l),l.v1=null,l.v2=null,l.next=null,l.prev=null;const p=(E,g,b)=>{const S={v1:b.v1,v2:g.v2,next:g.next,prev:b.prev};b.prev.next=S,g.next.prev=S,_c(E,g),g.v1=null,g.v2=null,g.next=null,g.prev=null,_c(E,b),b.v1=null,b.v2=null,b.next=null,b.prev=null};u[0]===0&&p(n,d,d.prev),u[1]===0&&p(n,h,h.prev)}}else c.next&&RL(n,c)}}const s=[];return n.forEach(o=>{const a=DL(o);a&&s.push(a)}),n.clear(),s},BL=(e,t)=>Math.abs(e[3]-t[3])<15e-8?OL(e,t):!1,IL=(e,t)=>{const r=[];t.forEach(s=>{const o=r.find(a=>BL(a[0],pa.plane(s)));o?o[1].push(s):r.push([pa.plane(s),[s]])});let n=[];return r.forEach(s=>{const o=s[1],a=kL(o);n=n.concat(a)}),n};var VL=IL;const sd=st,br=Ie,zL=ot,Ut=e=>`${e}`,od=(e,t,r,n,s,o)=>{const a=Ut(n),i=Ut(s),c=`${a}/${i}`,l=`${i}/${a}`;if(e.has(l))return la(e,t,r,s,n,null),null;const u={vertex0:n,vertex1:s,polygonindex:o};return e.has(c)?e.get(c).push(u):e.set(c,[u]),t.has(a)?t.get(a).push(c):t.set(a,[c]),r.has(i)?r.get(i).push(c):r.set(i,[c]),c},la=(e,t,r,n,s,o)=>{const a=Ut(n),i=Ut(s),c=`${a}/${i}`;let l=-1;const u=e.get(c);for(let d=0;d<u.length;d++){const h=u[d];let p=Ut(h.vertex0);if(p===a&&(p=Ut(h.vertex1),p===i&&!(o!==null&&h.polygonindex!==o))){l=d;break}}u.splice(l,1),u.length===0&&e.delete(c),l=t.get(a).indexOf(c),t.get(a).splice(l,1),t.get(a).length===0&&t.delete(a),l=r.get(i).indexOf(c),r.get(i).splice(l,1),r.get(i).length===0&&r.delete(i)},UL=e=>{const t=new Map;for(let r=0;r<e.length;r++){const n=e[r],s=n.vertices.length;if(s>=3){let o=n.vertices[0],a=Ut(o);for(let i=0;i<s;i++){let c=i+1;c===s&&(c=0);const l=n.vertices[c],u=Ut(l),d=`${a}/${u}`,h=`${u}/${a}`;if(t.has(h)){const p=t.get(h);p.splice(-1,1),p.length===0&&t.delete(h)}else{const p={vertex0:o,vertex1:l,polygonindex:r};t.has(d)?t.get(d).push(p):t.set(d,[p])}o=l,a=u}}else console.warn("warning: invalid polygon found during insertTjunctions")}if(t.size>0){const r=new Map,n=new Map,s=new Map;for(const[a,i]of t)s.set(a,!0),i.forEach(c=>{const l=Ut(c.vertex0),u=Ut(c.vertex1);r.has(l)?r.get(l).push(a):r.set(l,[a]),n.has(u)?n.get(u).push(a):n.set(u,[a])});const o=e.slice(0);for(;t.size!==0;){for(const i of t.keys())s.set(i,!0);let a=!1;for(;;){const i=Array.from(s.keys());if(i.length===0)break;const c=i[0];let l=!0;if(t.has(c)){const d=t.get(c)[0];for(let h=0;h<2;h++){const p=h===0?d.vertex0:d.vertex1,E=h===0?d.vertex1:d.vertex0,g=Ut(p),b=Ut(E);let S=[];h===0?n.has(g)&&(S=n.get(g)):r.has(g)&&(S=r.get(g));for(let G=0;G<S.length;G++){const R=S[G],M=t.get(R)[0],F=h===0?M.vertex0:M.vertex1;if(h===0?M.vertex1:M.vertex0,Ut(F)===b){la(t,r,n,p,E,null),la(t,r,n,E,p,null),l=!1,h=2,a=!0;break}else{const U=p,ee=E,oe=F,pe=br.subtract(br.create(),oe,U),Q=br.dot(br.subtract(br.create(),ee,U),pe)/br.dot(pe,pe);if(Q>0&&Q<1){const Se=br.scale(br.create(),pe,Q);if(br.add(Se,Se,U),br.squaredDistance(Se,ee)<sd.EPS*sd.EPS){const $e=M.polygonindex,Xe=o[$e],Ne=Ut(M.vertex1);let Ct=-1;for(let dr=0;dr<Xe.vertices.length;dr++)if(Ut(Xe.vertices[dr])===Ne){Ct=dr;break}const Rt=Xe.vertices.slice(0);Rt.splice(Ct,0,E);const Or=zL.create(Rt);o[$e]=Or,la(t,r,n,M.vertex0,M.vertex1,$e);const ur=od(t,r,n,M.vertex0,E,$e),Mr=od(t,r,n,E,M.vertex1,$e);ur!==null&&s.set(ur,!0),Mr!==null&&s.set(Mr,!0),l=!1,h=2,a=!0;break}}}}}}l&&s.delete(c)}if(!a)break}e=o}return t.clear(),e};var qL=UL;const xc=Ie,Ec=ot,XL=(e,t,r)=>{const n=t.vertices.length;if(n>3){if(n>4){const a=[0,0,0];t.vertices.forEach(i=>xc.add(a,a,i)),xc.snap(a,xc.divide(a,a,[n,n,n]),e);for(let i=0;i<n;i++){const c=Ec.create([a,t.vertices[i],t.vertices[(i+1)%n]]);t.color&&(c.color=t.color),r.push(c)}return}const s=Ec.create([t.vertices[0],t.vertices[1],t.vertices[2]]),o=Ec.create([t.vertices[0],t.vertices[2],t.vertices[3]]);t.color&&(s.color=t.color,o.color=t.color),r.push(s,o);return}r.push(t)},jL=(e,t)=>{const r=[];return t.forEach(n=>{XL(e,n,r)}),r};var HL=jL;const YL=We,WL=Zr,ZL=Qe,Mm=Ke,QL=ct,KL=Om,JL=VL,eF=qL,tF=HL,rF=(e,t)=>t,nF=(e,t)=>t,sF=(e,t)=>{const r={snap:!1,simplify:!1,triangulate:!1},{snap:n,simplify:s,triangulate:o}=Object.assign({},r,e),a=WL(t);let i=Mm.toPolygons(t);n&&(i=KL(a,i)),s&&(i=JL(a,i)),o&&(i=eF(i),i=tF(a,i));const c=Object.assign({},t);return c.polygons=i,c},oF=(e,...t)=>{if(t=YL(t),t.length===0)throw new Error("wrong number of arguments");const r=t.map(n=>{if(QL.isA(n))return rF(e,n);if(ZL.isA(n))return nF(e,n);if(Mm.isA(n))return sF(e,n);throw new Error("invalid geometry")});return r.length===1?r[0]:r};var aF=oF;const iF=We,bn=rt,Zc=Qe,Qc=Ke,Kc=ct,Pl=Zr,cF=Om,lF=e=>{const t=Pl(e),n=Kc.toPoints(e).map(s=>bn.snap(bn.create(),s,t));return Kc.create(n)},fF=e=>{const t=Pl(e);let n=Zc.toSides(e).map(s=>[bn.snap(bn.create(),s[0],t),bn.snap(bn.create(),s[1],t)]);return n=n.filter(s=>!bn.equals(s[0],s[1])),Zc.create(n)},uF=e=>{const t=Pl(e),r=Qc.toPolygons(e),n=cF(t,r);return Qc.create(n)},dF=(...e)=>{if(e=iF(e),e.length===0)throw new Error("wrong number of arguments");const t=e.map(r=>Kc.isA(r)?lF(r):Zc.isA(r)?fF(r):Qc.isA(r)?uF(r):r);return t.length===1?t[0]:t};var hF=dF,mF={generalize:aF,snap:hF,retessellate:Js};const pF=(e,t,r)=>{for(e=e.slice();e.length<r;)e.push(t);return e};var vF=pF;const gF=We,ad=vF,Rm=ml,{translate:yF}=wn,bF=e=>{if(!Array.isArray(e.modes)||e.modes.length>3)throw new Error("align(): modes must be an array of length <= 3");if(e.modes=ad(e.modes,"none",3),e.modes.filter(t=>["center","max","min","none"].includes(t)).length!==3)throw new Error('align(): all modes must be one of "center", "max" or "min"');if(!Array.isArray(e.relativeTo)||e.relativeTo.length>3)throw new Error("align(): relativeTo must be an array of length <= 3");if(e.relativeTo=ad(e.relativeTo,0,3),e.relativeTo.filter(t=>Number.isFinite(t)||t==null).length!==3)throw new Error("align(): all relativeTo values must be a number, or null.");if(typeof e.grouped!="boolean")throw new Error("align(): grouped must be a boolean value.");return e},wF=(e,t,r)=>{for(let n=0;n<3;n++)e[n]==null&&(t[n]==="center"?e[n]=(r[0][n]+r[1][n])/2:t[n]==="max"?e[n]=r[1][n]:t[n]==="min"&&(e[n]=r[0][n]));return e},id=(e,t,r)=>{const n=Rm(e),s=[0,0,0];for(let o=0;o<3;o++)t[o]==="center"?s[o]=r[o]-(n[0][o]+n[1][o])/2:t[o]==="max"?s[o]=r[o]-n[1][o]:t[o]==="min"&&(s[o]=r[o]-n[0][o]);return yF(s,e)},_F=(e,...t)=>{e=Object.assign({},{modes:["center","center","min"],relativeTo:[0,0,0],grouped:!1},e),e=bF(e);let{modes:n,relativeTo:s,grouped:o}=e;if(t=gF(t),t.length===0)throw new Error("align(): No geometries were provided to act upon");if(s.filter(a=>a==null).length){const a=Rm(t);s=wF(s,n,a)}return o?t=id(t,n,s):t=t.map(a=>id(a,n,s)),t.length===1?t[0]:t};var xF=_F;const EF=We,$F=Qe,AF=Ke,TF=ct,SF=En,{translate:PF}=wn,$c=(e,t)=>{const r={axes:[!0,!0,!0],relativeTo:[0,0,0]},{axes:n,relativeTo:s}=Object.assign({},r,e),o=SF(t),a=[0,0,0];return n[0]&&(a[0]=s[0]-(o[0][0]+(o[1][0]-o[0][0])/2)),n[1]&&(a[1]=s[1]-(o[0][1]+(o[1][1]-o[0][1])/2)),n[2]&&(a[2]=s[2]-(o[0][2]+(o[1][2]-o[0][2])/2)),PF(a,t)},Na=(e,...t)=>{const r={axes:[!0,!0,!0],relativeTo:[0,0,0]},{axes:n,relativeTo:s}=Object.assign({},r,e);if(t=EF(t),t.length===0)throw new Error("wrong number of arguments");if(s.length!==3)throw new Error("relativeTo must be an array of length 3");e={axes:n,relativeTo:s};const o=t.map(a=>TF.isA(a)||$F.isA(a)||AF.isA(a)?$c(e,a):a);return o.length===1?o[0]:o},CF=(...e)=>Na({axes:[!0,!1,!1]},e),OF=(...e)=>Na({axes:[!1,!0,!1]},e),MF=(...e)=>Na({axes:[!1,!1,!0]},e);var ra={center:Na,centerX:CF,centerY:OF,centerZ:MF};const RF=We,cd=ft,ld=Qe,fd=Ke,ud=ct,Da=(e,...t)=>{if(!Array.isArray(e))throw new Error("factors must be an array");if(t=RF(t),t.length===0)throw new Error("wrong number of arguments");for(e=e.slice();e.length<3;)e.push(1);if(e[0]<=0||e[1]<=0||e[2]<=0)throw new Error("factors must be positive");const r=cd.fromScaling(cd.create(),e),n=t.map(s=>ud.isA(s)?ud.transform(r,s):ld.isA(s)?ld.transform(r,s):fd.isA(s)?fd.transform(r,s):s);return n.length===1?n[0]:n},LF=(e,...t)=>Da([e,1,1],t),FF=(e,...t)=>Da([1,e,1],t),GF=(e,...t)=>Da([1,1,e],t);var na={scale:Da,scaleX:LF,scaleY:FF,scaleZ:GF};const NF=We,dd=Qe,hd=Ke,md=ct,DF=(e,...t)=>{if(t=NF(t),t.length===0)throw new Error("wrong number of arguments");const r=t.map(n=>md.isA(n)?md.transform(e,n):dd.isA(n)?dd.transform(e,n):hd.isA(n)?hd.transform(e,n):n);return r.length===1?r[0]:r};var kF=DF,Jc={align:xF,center:ra.center,centerX:ra.centerX,centerY:ra.centerY,centerZ:ra.centerZ,mirror:Is.mirror,mirrorX:Is.mirrorX,mirrorY:Is.mirrorY,mirrorZ:Is.mirrorZ,rotate:zs.rotate,rotateX:zs.rotateX,rotateY:zs.rotateY,rotateZ:zs.rotateZ,scale:na.scale,scaleX:na.scaleX,scaleY:na.scaleY,scaleZ:na.scaleZ,transform:kF,translate:wn.translate,translateX:wn.translateX,translateY:wn.translateY,translateZ:wn.translateZ},eo={colors:YE,curves:f$,geometries:ll,maths:XA,measurements:cT,primitives:Us,text:eC,utils:wl,booleans:ca,expansions:_6,extrusions:uR,hulls:SL,modifiers:mF,transforms:Jc};const Lm=e=>e.reduce((t,r)=>Array.isArray(r)?t.concat(Lm(r)):t.concat(r),[]);var BF=Lm;const IF=(e,t)=>e-t;var VF=IF;const zF=e=>{if(!(!Array.isArray(e)||e.length===0))return e[0]};var UF=zF;const qF=(e,t,r)=>{let n=0,s=e.length;for(;s>n;){const o=Math.floor((n+s)/2),a=e[o];r(t,a)>0?n=o+1:s=o}return e.splice(n,0,t),e};var XF=qF;const jF=(e,t)=>{if(!(!Array.isArray(e)||e.length<t))return e[t]};var HF=jF;const YF=(e,t,r)=>{for(e=e.slice();e.length<r;)e.push(t);return e};var WF=YF;const ZF=e=>Array.isArray(e)?e:e==null?[]:[e];var QF=ZF,Cl={flatten:BF,fnNumberSort:VF,head:UF,insertSorted:XF,nth:HF,padToLength:WF,toArray:QF};const{geometries:Ac}=eo,KF=(e,t)=>{t.statusCallback&&t.statusCallback({progress:0});const r=new ArrayBuffer(4),n=new Int32Array(r,0,1),s=new Int8Array(r,0,4);if(n[0]=287454020,s[0]!==68)throw new Error("Binary STL output is currently only supported on little-endian (Intel) processors");let o=0,a=0;e.forEach((b,S)=>{Ac.geom3.toPolygons(b).forEach(R=>{const M=R.vertices.length,F=M>=3?M-2:0;o+=F,a+=1})});const i=new Uint8Array(80);for(let b=0;b<80;b++)i[b]=65;const c=new Uint32Array(1);c[0]=o;const l=new ArrayBuffer(50*o),u=new Int8Array(l),d=new ArrayBuffer(50),h=new Int8Array(d),p=new Float32Array(d,0,12),E=new Uint16Array(d,48,1);let g=0;return e.forEach(b=>{Ac.geom3.toPolygons(b).forEach((G,R)=>{const M=G.vertices,F=M.length,L=Ac.poly3.plane(G);for(let U=0;U<F-2;U++){p[0]=L[0],p[1]=L[1],p[2]=L[2];let ee=3;for(let oe=0;oe<3;oe++){const pe=oe+(oe>0?U:0),Q=M[pe];p[ee++]=Q[0],p[ee++]=Q[1],p[ee++]=Q[2]}E[0]=0,u.set(h,g),g+=50}t.statusCallback&&t.statusCallback({progress:100*R/a})})}),t.statusCallback&&t.statusCallback({progress:100}),[i.buffer,c.buffer,l]};var JF={serializeBinary:KF};const{geometries:Fm}=eo,eG=(e,t)=>{t.statusCallback&&t.statusCallback({progress:0});const r=`solid JSCAD
${tG(e,t)}
endsolid JSCAD
`;return t.statusCallback&&t.statusCallback({progress:100}),[r]},tG=(e,t)=>{const r=[];return e.forEach((n,s)=>{r.push(rG(n)),t.statusCallback&&t.statusCallback({progress:100*s/e.length})}),r.join(`
`)},rG=(e,t)=>{const r=[];return Fm.geom3.toPolygons(e).forEach((s,o)=>{r.push(nG(s))}),r.join(`
`)},Gm=e=>`${e[0]} ${e[1]} ${e[2]}`,Tc=e=>`vertex ${Gm(e)}`,nG=e=>{const t=[];if(e.vertices.length>=3){const r=Tc(e.vertices[0]);for(let n=0;n<e.vertices.length-2;n++){const s=`facet normal ${Gm(Fm.poly3.plane(e))}
outer loop
${r}
${Tc(e.vertices[n+1])}
${Tc(e.vertices[n+2])}
endloop
endfacet`;t.push(s)}}return t.join(`
`)};var sG={serializeText:eG};const{geometries:oG,modifiers:aG}=eo,{flatten:iG,toArray:cG}=Cl,{serializeBinary:lG}=JF,{serializeText:fG}=sG,uG="application/sla",dG=(e,...t)=>{e=Object.assign({},{binary:!0,statusCallback:null},e),t=iG(t);let n=t.filter(s=>oG.geom3.isA(s));if(n.length===0)throw new Error("only 3D geometries can be serialized to STL");return t.length!==n.length&&console.warn("some objects could not be serialized to STL"),n=cG(aG.generalize({snap:!0,triangulate:!0},n)),e.binary?lG(n,e):fG(n,e)};var hG={mimeType:uG,serialize:dG};const{cylinder:pd,cuboid:ok}=eo.primitives,{hull:mG}=eo.hulls,vd=128,gd=({topRadius:e,bottomRadius:t,height:r,center:n})=>{const[s,o,a]=n??[0,0,0];return mG(pd({center:[s,o,a],height:.1,radius:t,segments:vd}),pd({center:[s,o,a+r],height:.1,radius:e,segments:vd}))},pG=()=>[Jc.translateZ(20,ca.union(ca.subtract(Us.cylinder({center:[0,0,35/2],radius:40,height:35,segments:64}),Us.cylinder({center:[0,0,35/2],radius:38,height:35,segments:64})),ca.subtract(gd({topRadius:40,bottomRadius:7,height:20,center:[0,0,-20]}),gd({topRadius:38,bottomRadius:5,height:20,center:[0,0,-20]})),Us.cuboid({center:[0,0,-19.5],size:[12,1,1]}),Jc.rotateZ(wl.degToRad(90),Us.cuboid({center:[0,0,-19.5],size:[12,1,1]}))))];var vG=gG;function gG(){var e=new Float32Array(16);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}var yG=bG;function bG(e){var t=new Float32Array(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}var wG=_G;function _G(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}var Nm=xG;function xG(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}var EG=$G;function $G(e,t){if(e===t){var r=t[1],n=t[2],s=t[3],o=t[6],a=t[7],i=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=r,e[6]=t[9],e[7]=t[13],e[8]=n,e[9]=o,e[11]=t[14],e[12]=s,e[13]=a,e[14]=i}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}var AG=TG;function TG(e,t){var r=t[0],n=t[1],s=t[2],o=t[3],a=t[4],i=t[5],c=t[6],l=t[7],u=t[8],d=t[9],h=t[10],p=t[11],E=t[12],g=t[13],b=t[14],S=t[15],G=r*i-n*a,R=r*c-s*a,M=r*l-o*a,F=n*c-s*i,L=n*l-o*i,U=s*l-o*c,ee=u*g-d*E,oe=u*b-h*E,pe=u*S-p*E,Q=d*b-h*g,Se=d*S-p*g,qe=h*S-p*b,$e=G*qe-R*Se+M*Q+F*pe-L*oe+U*ee;return $e?($e=1/$e,e[0]=(i*qe-c*Se+l*Q)*$e,e[1]=(s*Se-n*qe-o*Q)*$e,e[2]=(g*U-b*L+S*F)*$e,e[3]=(h*L-d*U-p*F)*$e,e[4]=(c*pe-a*qe-l*oe)*$e,e[5]=(r*qe-s*pe+o*oe)*$e,e[6]=(b*M-E*U-S*R)*$e,e[7]=(u*U-h*M+p*R)*$e,e[8]=(a*Se-i*pe+l*ee)*$e,e[9]=(n*pe-r*Se-o*ee)*$e,e[10]=(E*L-g*M+S*G)*$e,e[11]=(d*M-u*L-p*G)*$e,e[12]=(i*oe-a*Q-c*ee)*$e,e[13]=(r*Q-n*oe+s*ee)*$e,e[14]=(g*R-E*F-b*G)*$e,e[15]=(u*F-d*R+h*G)*$e,e):null}var SG=PG;function PG(e,t){var r=t[0],n=t[1],s=t[2],o=t[3],a=t[4],i=t[5],c=t[6],l=t[7],u=t[8],d=t[9],h=t[10],p=t[11],E=t[12],g=t[13],b=t[14],S=t[15];return e[0]=i*(h*S-p*b)-d*(c*S-l*b)+g*(c*p-l*h),e[1]=-(n*(h*S-p*b)-d*(s*S-o*b)+g*(s*p-o*h)),e[2]=n*(c*S-l*b)-i*(s*S-o*b)+g*(s*l-o*c),e[3]=-(n*(c*p-l*h)-i*(s*p-o*h)+d*(s*l-o*c)),e[4]=-(a*(h*S-p*b)-u*(c*S-l*b)+E*(c*p-l*h)),e[5]=r*(h*S-p*b)-u*(s*S-o*b)+E*(s*p-o*h),e[6]=-(r*(c*S-l*b)-a*(s*S-o*b)+E*(s*l-o*c)),e[7]=r*(c*p-l*h)-a*(s*p-o*h)+u*(s*l-o*c),e[8]=a*(d*S-p*g)-u*(i*S-l*g)+E*(i*p-l*d),e[9]=-(r*(d*S-p*g)-u*(n*S-o*g)+E*(n*p-o*d)),e[10]=r*(i*S-l*g)-a*(n*S-o*g)+E*(n*l-o*i),e[11]=-(r*(i*p-l*d)-a*(n*p-o*d)+u*(n*l-o*i)),e[12]=-(a*(d*b-h*g)-u*(i*b-c*g)+E*(i*h-c*d)),e[13]=r*(d*b-h*g)-u*(n*b-s*g)+E*(n*h-s*d),e[14]=-(r*(i*b-c*g)-a*(n*b-s*g)+E*(n*c-s*i)),e[15]=r*(i*h-c*d)-a*(n*h-s*d)+u*(n*c-s*i),e}var CG=OG;function OG(e){var t=e[0],r=e[1],n=e[2],s=e[3],o=e[4],a=e[5],i=e[6],c=e[7],l=e[8],u=e[9],d=e[10],h=e[11],p=e[12],E=e[13],g=e[14],b=e[15],S=t*a-r*o,G=t*i-n*o,R=t*c-s*o,M=r*i-n*a,F=r*c-s*a,L=n*c-s*i,U=l*E-u*p,ee=l*g-d*p,oe=l*b-h*p,pe=u*g-d*E,Q=u*b-h*E,Se=d*b-h*g;return S*Se-G*Q+R*pe+M*oe-F*ee+L*U}var MG=RG;function RG(e,t,r){var n=t[0],s=t[1],o=t[2],a=t[3],i=t[4],c=t[5],l=t[6],u=t[7],d=t[8],h=t[9],p=t[10],E=t[11],g=t[12],b=t[13],S=t[14],G=t[15],R=r[0],M=r[1],F=r[2],L=r[3];return e[0]=R*n+M*i+F*d+L*g,e[1]=R*s+M*c+F*h+L*b,e[2]=R*o+M*l+F*p+L*S,e[3]=R*a+M*u+F*E+L*G,R=r[4],M=r[5],F=r[6],L=r[7],e[4]=R*n+M*i+F*d+L*g,e[5]=R*s+M*c+F*h+L*b,e[6]=R*o+M*l+F*p+L*S,e[7]=R*a+M*u+F*E+L*G,R=r[8],M=r[9],F=r[10],L=r[11],e[8]=R*n+M*i+F*d+L*g,e[9]=R*s+M*c+F*h+L*b,e[10]=R*o+M*l+F*p+L*S,e[11]=R*a+M*u+F*E+L*G,R=r[12],M=r[13],F=r[14],L=r[15],e[12]=R*n+M*i+F*d+L*g,e[13]=R*s+M*c+F*h+L*b,e[14]=R*o+M*l+F*p+L*S,e[15]=R*a+M*u+F*E+L*G,e}var LG=FG;function FG(e,t,r){var n=r[0],s=r[1],o=r[2],a,i,c,l,u,d,h,p,E,g,b,S;return t===e?(e[12]=t[0]*n+t[4]*s+t[8]*o+t[12],e[13]=t[1]*n+t[5]*s+t[9]*o+t[13],e[14]=t[2]*n+t[6]*s+t[10]*o+t[14],e[15]=t[3]*n+t[7]*s+t[11]*o+t[15]):(a=t[0],i=t[1],c=t[2],l=t[3],u=t[4],d=t[5],h=t[6],p=t[7],E=t[8],g=t[9],b=t[10],S=t[11],e[0]=a,e[1]=i,e[2]=c,e[3]=l,e[4]=u,e[5]=d,e[6]=h,e[7]=p,e[8]=E,e[9]=g,e[10]=b,e[11]=S,e[12]=a*n+u*s+E*o+t[12],e[13]=i*n+d*s+g*o+t[13],e[14]=c*n+h*s+b*o+t[14],e[15]=l*n+p*s+S*o+t[15]),e}var GG=NG;function NG(e,t,r){var n=r[0],s=r[1],o=r[2];return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*s,e[5]=t[5]*s,e[6]=t[6]*s,e[7]=t[7]*s,e[8]=t[8]*o,e[9]=t[9]*o,e[10]=t[10]*o,e[11]=t[11]*o,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}var DG=kG;function kG(e,t,r,n){var s=n[0],o=n[1],a=n[2],i=Math.sqrt(s*s+o*o+a*a),c,l,u,d,h,p,E,g,b,S,G,R,M,F,L,U,ee,oe,pe,Q,Se,qe,$e,Xe;return Math.abs(i)<1e-6?null:(i=1/i,s*=i,o*=i,a*=i,c=Math.sin(r),l=Math.cos(r),u=1-l,d=t[0],h=t[1],p=t[2],E=t[3],g=t[4],b=t[5],S=t[6],G=t[7],R=t[8],M=t[9],F=t[10],L=t[11],U=s*s*u+l,ee=o*s*u+a*c,oe=a*s*u-o*c,pe=s*o*u-a*c,Q=o*o*u+l,Se=a*o*u+s*c,qe=s*a*u+o*c,$e=o*a*u-s*c,Xe=a*a*u+l,e[0]=d*U+g*ee+R*oe,e[1]=h*U+b*ee+M*oe,e[2]=p*U+S*ee+F*oe,e[3]=E*U+G*ee+L*oe,e[4]=d*pe+g*Q+R*Se,e[5]=h*pe+b*Q+M*Se,e[6]=p*pe+S*Q+F*Se,e[7]=E*pe+G*Q+L*Se,e[8]=d*qe+g*$e+R*Xe,e[9]=h*qe+b*$e+M*Xe,e[10]=p*qe+S*$e+F*Xe,e[11]=E*qe+G*$e+L*Xe,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}var BG=IG;function IG(e,t,r){var n=Math.sin(r),s=Math.cos(r),o=t[4],a=t[5],i=t[6],c=t[7],l=t[8],u=t[9],d=t[10],h=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=o*s+l*n,e[5]=a*s+u*n,e[6]=i*s+d*n,e[7]=c*s+h*n,e[8]=l*s-o*n,e[9]=u*s-a*n,e[10]=d*s-i*n,e[11]=h*s-c*n,e}var VG=zG;function zG(e,t,r){var n=Math.sin(r),s=Math.cos(r),o=t[0],a=t[1],i=t[2],c=t[3],l=t[8],u=t[9],d=t[10],h=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=o*s-l*n,e[1]=a*s-u*n,e[2]=i*s-d*n,e[3]=c*s-h*n,e[8]=o*n+l*s,e[9]=a*n+u*s,e[10]=i*n+d*s,e[11]=c*n+h*s,e}var UG=qG;function qG(e,t,r){var n=Math.sin(r),s=Math.cos(r),o=t[0],a=t[1],i=t[2],c=t[3],l=t[4],u=t[5],d=t[6],h=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=o*s+l*n,e[1]=a*s+u*n,e[2]=i*s+d*n,e[3]=c*s+h*n,e[4]=l*s-o*n,e[5]=u*s-a*n,e[6]=d*s-i*n,e[7]=h*s-c*n,e}var XG=jG;function jG(e,t,r){var n,s,o,a=r[0],i=r[1],c=r[2],l=Math.sqrt(a*a+i*i+c*c);return Math.abs(l)<1e-6?null:(l=1/l,a*=l,i*=l,c*=l,n=Math.sin(t),s=Math.cos(t),o=1-s,e[0]=a*a*o+s,e[1]=i*a*o+c*n,e[2]=c*a*o-i*n,e[3]=0,e[4]=a*i*o-c*n,e[5]=i*i*o+s,e[6]=c*i*o+a*n,e[7]=0,e[8]=a*c*o+i*n,e[9]=i*c*o-a*n,e[10]=c*c*o+s,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}var HG=YG;function YG(e,t,r){var n=t[0],s=t[1],o=t[2],a=t[3],i=n+n,c=s+s,l=o+o,u=n*i,d=n*c,h=n*l,p=s*c,E=s*l,g=o*l,b=a*i,S=a*c,G=a*l;return e[0]=1-(p+g),e[1]=d+G,e[2]=h-S,e[3]=0,e[4]=d-G,e[5]=1-(u+g),e[6]=E+b,e[7]=0,e[8]=h+S,e[9]=E-b,e[10]=1-(u+p),e[11]=0,e[12]=r[0],e[13]=r[1],e[14]=r[2],e[15]=1,e}var WG=ZG;function ZG(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}var QG=KG;function KG(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}var JG=eN;function eN(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=n,e[6]=r,e[7]=0,e[8]=0,e[9]=-r,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}var tN=rN;function rN(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=n,e[1]=0,e[2]=-r,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=r,e[9]=0,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}var nN=sN;function sN(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=n,e[1]=r,e[2]=0,e[3]=0,e[4]=-r,e[5]=n,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}var oN=aN;function aN(e,t){var r=t[0],n=t[1],s=t[2],o=t[3],a=r+r,i=n+n,c=s+s,l=r*a,u=n*a,d=n*i,h=s*a,p=s*i,E=s*c,g=o*a,b=o*i,S=o*c;return e[0]=1-d-E,e[1]=u+S,e[2]=h-b,e[3]=0,e[4]=u-S,e[5]=1-l-E,e[6]=p+g,e[7]=0,e[8]=h+b,e[9]=p-g,e[10]=1-l-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}var iN=cN;function cN(e,t,r,n,s,o,a){var i=1/(r-t),c=1/(s-n),l=1/(o-a);return e[0]=o*2*i,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o*2*c,e[6]=0,e[7]=0,e[8]=(r+t)*i,e[9]=(s+n)*c,e[10]=(a+o)*l,e[11]=-1,e[12]=0,e[13]=0,e[14]=a*o*2*l,e[15]=0,e}var lN=fN;function fN(e,t,r,n,s){var o=1/Math.tan(t/2),a=1/(n-s);return e[0]=o/r,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=(s+n)*a,e[11]=-1,e[12]=0,e[13]=0,e[14]=2*s*n*a,e[15]=0,e}var uN=dN;function dN(e,t,r,n){var s=Math.tan(t.upDegrees*Math.PI/180),o=Math.tan(t.downDegrees*Math.PI/180),a=Math.tan(t.leftDegrees*Math.PI/180),i=Math.tan(t.rightDegrees*Math.PI/180),c=2/(a+i),l=2/(s+o);return e[0]=c,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=l,e[6]=0,e[7]=0,e[8]=-((a-i)*c*.5),e[9]=(s-o)*l*.5,e[10]=n/(r-n),e[11]=-1,e[12]=0,e[13]=0,e[14]=n*r/(r-n),e[15]=0,e}var hN=mN;function mN(e,t,r,n,s,o,a){var i=1/(t-r),c=1/(n-s),l=1/(o-a);return e[0]=-2*i,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*c,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*l,e[11]=0,e[12]=(t+r)*i,e[13]=(s+n)*c,e[14]=(a+o)*l,e[15]=1,e}var pN=Nm,vN=gN;function gN(e,t,r,n){var s,o,a,i,c,l,u,d,h,p,E=t[0],g=t[1],b=t[2],S=n[0],G=n[1],R=n[2],M=r[0],F=r[1],L=r[2];return Math.abs(E-M)<1e-6&&Math.abs(g-F)<1e-6&&Math.abs(b-L)<1e-6?pN(e):(u=E-M,d=g-F,h=b-L,p=1/Math.sqrt(u*u+d*d+h*h),u*=p,d*=p,h*=p,s=G*h-R*d,o=R*u-S*h,a=S*d-G*u,p=Math.sqrt(s*s+o*o+a*a),p?(p=1/p,s*=p,o*=p,a*=p):(s=0,o=0,a=0),i=d*a-h*o,c=h*s-u*a,l=u*o-d*s,p=Math.sqrt(i*i+c*c+l*l),p?(p=1/p,i*=p,c*=p,l*=p):(i=0,c=0,l=0),e[0]=s,e[1]=i,e[2]=u,e[3]=0,e[4]=o,e[5]=c,e[6]=d,e[7]=0,e[8]=a,e[9]=l,e[10]=h,e[11]=0,e[12]=-(s*E+o*g+a*b),e[13]=-(i*E+c*g+l*b),e[14]=-(u*E+d*g+h*b),e[15]=1,e)}var yN=bN;function bN(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"}var ir={create:vG,clone:yG,copy:wG,identity:Nm,transpose:EG,invert:AG,adjoint:SG,determinant:CG,multiply:MG,translate:LG,scale:GG,rotate:DG,rotateX:BG,rotateY:VG,rotateZ:UG,fromRotation:XG,fromRotationTranslation:HG,fromScaling:WG,fromTranslation:QG,fromXRotation:JG,fromYRotation:tN,fromZRotation:nN,fromQuat:oN,frustum:iN,perspective:lN,perspectiveFromFieldOfView:uN,ortho:hN,lookAt:vN,str:yN};const Sc=ir,wN=(e,t={})=>{const{fbo:r}=t,n={cull:{enable:!0},context:{lightDirection:[.2,.2,1]},uniforms:{view:(s,o)=>o.camera.view,eye:(s,o)=>o.camera.position,projection:(s,o)=>o.camera.projection,camNear:(s,o)=>o.camera.near,camFar:(s,o)=>o.camera.far,invertedView:(s,o)=>Sc.invert([],o.camera.view),lightPosition:(s,o)=>o&&o.rendering&&o.rendering.lightPosition?o.rendering.lightPosition:[100,200,100],lightDirection:(s,o)=>o&&o.rendering&&o.rendering.lightDirection?o.rendering.lightDirection:s.lightDirection||[0,0,0],lightView:s=>Sc.lookAt([],s.lightDirection,[0,0,0],[0,0,1]),lightProjection:Sc.ortho([],-25,-25,-20,20,-25,25),lightColor:(s,o)=>o&&o.rendering&&o.rendering.lightColor?o.rendering.lightColor:[1,.8,0],ambientLightAmount:(s,o)=>o&&o.rendering&&o.rendering.ambientLightAmount?o.rendering.ambientLightAmount:.3,diffuseLightAmount:(s,o)=>o&&o.rendering&&o.rendering.diffuseLightAmount?o&&o.rendering&&o.rendering.diffuseLightAmount:.89,specularLightAmount:(s,o)=>o&&o.rendering&&o.rendering.specularLightAmount?o.rendering.specularLightAmount:.16,uMaterialShininess:(s,o)=>o&&o.rendering&&o.rendering.materialShininess?o.rendering.materialShininess:8,materialAmbient:[.5,.8,.3],materialDiffuse:[.5,.8,.3],materialSpecular:[.5,.8,.3]},framebuffer:r};return e(Object.assign({},n,t.extras))};var _N=wN,ka={background:[1,1,1,1],meshColor:[0,.6,1,1],lightColor:[1,1,1,1],lightDirection:[.2,.2,1],lightPosition:[100,200,100],ambientLightAmount:.3,diffuseLightAmount:.89,specularLightAmount:.16,materialShininess:8},Pc={exports:{}},yd;function xN(){return yd||(yd=1,function(e,t){(function(r,n){e.exports=n()})(Ag,function(){var r=function(f){return f instanceof Uint8Array||f instanceof Uint16Array||f instanceof Uint32Array||f instanceof Int8Array||f instanceof Int16Array||f instanceof Int32Array||f instanceof Float32Array||f instanceof Float64Array||f instanceof Uint8ClampedArray},n=function(f,v){for(var T=Object.keys(v),X=0;X<T.length;++X)f[T[X]]=v[T[X]];return f},s=`
`;function o(f){return typeof atob<"u"?atob(f):"base64:"+f}function a(f){var v=new Error("(regl) "+f);throw console.error(v),v}function i(f,v){f||a(v)}function c(f){return f?": "+f:""}function l(f,v,T){f in v||a("unknown parameter ("+f+")"+c(T)+". possible values: "+Object.keys(v).join())}function u(f,v){r(f)||a("invalid parameter type"+c(v)+". must be a typed array")}function d(f,v){switch(v){case"number":return typeof f=="number";case"object":return typeof f=="object";case"string":return typeof f=="string";case"boolean":return typeof f=="boolean";case"function":return typeof f=="function";case"undefined":return typeof f>"u";case"symbol":return typeof f=="symbol"}}function h(f,v,T){d(f,v)||a("invalid parameter type"+c(T)+". expected "+v+", got "+typeof f)}function p(f,v){f>=0&&(f|0)===f||a("invalid parameter type, ("+f+")"+c(v)+". must be a nonnegative integer")}function E(f,v,T){v.indexOf(f)<0&&a("invalid value"+c(T)+". must be one of: "+v)}var g=["gl","canvas","container","attributes","pixelRatio","extensions","optionalExtensions","profile","onDone"];function b(f){Object.keys(f).forEach(function(v){g.indexOf(v)<0&&a('invalid regl constructor argument "'+v+'". must be one of '+g)})}function S(f,v){for(f=f+"";f.length<v;)f=" "+f;return f}function G(){this.name="unknown",this.lines=[],this.index={},this.hasErrors=!1}function R(f,v){this.number=f,this.line=v,this.errors=[]}function M(f,v,T){this.file=f,this.line=v,this.message=T}function F(){var f=new Error,v=(f.stack||f).toString(),T=/compileProcedure.*\n\s*at.*\((.*)\)/.exec(v);if(T)return T[1];var X=/compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(v);return X?X[1]:"unknown"}function L(){var f=new Error,v=(f.stack||f).toString(),T=/at REGLCommand.*\n\s+at.*\((.*)\)/.exec(v);if(T)return T[1];var X=/at REGLCommand.*\n\s+at\s+(.*)\n/.exec(v);return X?X[1]:"unknown"}function U(f,v){var T=f.split(`
`),X=1,J=0,q={unknown:new G,0:new G};q.unknown.name=q[0].name=v||F(),q.unknown.lines.push(new R(0,""));for(var Y=0;Y<T.length;++Y){var ie=T[Y],ae=/^\s*#\s*(\w+)\s+(.+)\s*$/.exec(ie);if(ae)switch(ae[1]){case"line":var de=/(\d+)(\s+\d+)?/.exec(ae[2]);de&&(X=de[1]|0,de[2]&&(J=de[2]|0,J in q||(q[J]=new G)));break;case"define":var me=/SHADER_NAME(_B64)?\s+(.*)$/.exec(ae[2]);me&&(q[J].name=me[1]?o(me[2]):me[2]);break}q[J].lines.push(new R(X++,ie))}return Object.keys(q).forEach(function(he){var ge=q[he];ge.lines.forEach(function(ce){ge.index[ce.number]=ce})}),q}function ee(f){var v=[];return f.split(`
`).forEach(function(T){if(!(T.length<5)){var X=/^ERROR:\s+(\d+):(\d+):\s*(.*)$/.exec(T);X?v.push(new M(X[1]|0,X[2]|0,X[3].trim())):T.length>0&&v.push(new M("unknown",0,T))}}),v}function oe(f,v){v.forEach(function(T){var X=f[T.file];if(X){var J=X.index[T.line];if(J){J.errors.push(T),X.hasErrors=!0;return}}f.unknown.hasErrors=!0,f.unknown.lines[0].errors.push(T)})}function pe(f,v,T,X,J){if(!f.getShaderParameter(v,f.COMPILE_STATUS)){var q=f.getShaderInfoLog(v),Y=X===f.FRAGMENT_SHADER?"fragment":"vertex";Ct(T,"string",Y+" shader source must be a string",J);var ie=U(T,J),ae=ee(q);oe(ie,ae),Object.keys(ie).forEach(function(de){var me=ie[de];if(!me.hasErrors)return;var he=[""],ge=[""];function ce(ue,k){he.push(ue),ge.push(k||"")}ce("file number "+de+": "+me.name+`
`,"color:red;text-decoration:underline;font-weight:bold"),me.lines.forEach(function(ue){if(ue.errors.length>0){ce(S(ue.number,4)+"|  ","background-color:yellow; font-weight:bold"),ce(ue.line+s,"color:red; background-color:yellow; font-weight:bold");var k=0;ue.errors.forEach(function(H){var fe=H.message,Te=/^\s*'(.*)'\s*:\s*(.*)$/.exec(fe);if(Te){var se=Te[1];switch(fe=Te[2],se){case"assign":se="=";break}k=Math.max(ue.line.indexOf(se,k),0)}else k=0;ce(S("| ",6)),ce(S("^^^",k+3)+s,"font-weight:bold"),ce(S("| ",6)),ce(fe+s,"font-weight:bold")}),ce(S("| ",6)+s)}else ce(S(ue.number,4)+"|  "),ce(ue.line+s,"color:red")}),typeof document<"u"&&!window.chrome?(ge[0]=he.join("%c"),console.log.apply(console,ge)):console.log(he.join(""))}),i.raise("Error compiling "+Y+" shader, "+ie[0].name)}}function Q(f,v,T,X,J){if(!f.getProgramParameter(v,f.LINK_STATUS)){var q=f.getProgramInfoLog(v),Y=U(T,J),ie=U(X,J),ae='Error linking program with vertex shader, "'+ie[0].name+'", and fragment shader "'+Y[0].name+'"';typeof document<"u"?console.log("%c"+ae+s+"%c"+q,"color:red;text-decoration:underline;font-weight:bold","color:red"):console.log(ae+s+q),i.raise(ae)}}function Se(f){f._commandRef=F()}function qe(f,v,T,X){Se(f);function J(ae){return ae?X.id(ae):0}f._fragId=J(f.static.frag),f._vertId=J(f.static.vert);function q(ae,de){Object.keys(de).forEach(function(me){ae[X.id(me)]=!0})}var Y=f._uniformSet={};q(Y,v.static),q(Y,v.dynamic);var ie=f._attributeSet={};q(ie,T.static),q(ie,T.dynamic),f._hasCount="count"in f.static||"count"in f.dynamic||"elements"in f.static||"elements"in f.dynamic}function $e(f,v){var T=L();a(f+" in command "+(v||F())+(T==="unknown"?"":" called from "+T))}function Xe(f,v,T){f||$e(v,T||F())}function Ne(f,v,T,X){f in v||$e("unknown parameter ("+f+")"+c(T)+". possible values: "+Object.keys(v).join(),X||F())}function Ct(f,v,T,X){d(f,v)||$e("invalid parameter type"+c(T)+". expected "+v+", got "+typeof f,X||F())}function Rt(f){f()}function Or(f,v,T){f.texture?E(f.texture._texture.internalformat,v,"unsupported texture format for attachment"):E(f.renderbuffer._renderbuffer.format,T,"unsupported renderbuffer format for attachment")}var ur=33071,Mr=9728,dr=9984,Jm=9985,ep=9986,tp=9987,rp=5120,np=5121,sp=5122,op=5123,ap=5124,ip=5125,Ml=5126,Rl=32819,Ll=32820,Fl=33635,Gl=34042,cp=36193,Zt={};Zt[rp]=Zt[np]=1,Zt[sp]=Zt[op]=Zt[cp]=Zt[Fl]=Zt[Rl]=Zt[Ll]=2,Zt[ap]=Zt[ip]=Zt[Ml]=Zt[Gl]=4;function Nl(f,v){return f===Ll||f===Rl||f===Fl?2:f===Gl?4:Zt[f]*v}function ro(f){return!(f&f-1)&&!!f}function lp(f,v,T){var X,J=v.width,q=v.height,Y=v.channels;i(J>0&&J<=T.maxTextureSize&&q>0&&q<=T.maxTextureSize,"invalid texture shape"),(f.wrapS!==ur||f.wrapT!==ur)&&i(ro(J)&&ro(q),"incompatible wrap mode for texture, both width and height must be power of 2"),v.mipmask===1?J!==1&&q!==1&&i(f.minFilter!==dr&&f.minFilter!==ep&&f.minFilter!==Jm&&f.minFilter!==tp,"min filter requires mipmap"):(i(ro(J)&&ro(q),"texture must be a square power of 2 to support mipmapping"),i(v.mipmask===(J<<1)-1,"missing or incomplete mipmap data")),v.type===Ml&&(T.extensions.indexOf("oes_texture_float_linear")<0&&i(f.minFilter===Mr&&f.magFilter===Mr,"filter not supported, must enable oes_texture_float_linear"),i(!f.genMipmaps,"mipmap generation not supported with float textures"));var ie=v.images;for(X=0;X<16;++X)if(ie[X]){var ae=J>>X,de=q>>X;i(v.mipmask&1<<X,"missing mipmap data");var me=ie[X];if(i(me.width===ae&&me.height===de,"invalid shape for mip images"),i(me.format===v.format&&me.internalformat===v.internalformat&&me.type===v.type,"incompatible type for mip image"),!me.compressed)if(me.data){var he=Math.ceil(Nl(me.type,Y)*ae/me.unpackAlignment)*me.unpackAlignment;i(me.data.byteLength===he*de,"invalid data for image, buffer size is inconsistent with image format")}else me.element||me.copy}else f.genMipmaps||i((v.mipmask&1<<X)===0,"extra mipmap data");v.compressed&&i(!f.genMipmaps,"mipmap generation for compressed images not supported")}function fp(f,v,T,X){var J=f.width,q=f.height,Y=f.channels;i(J>0&&J<=X.maxTextureSize&&q>0&&q<=X.maxTextureSize,"invalid texture shape"),i(J===q,"cube map must be square"),i(v.wrapS===ur&&v.wrapT===ur,"wrap mode not supported by cube map");for(var ie=0;ie<T.length;++ie){var ae=T[ie];i(ae.width===J&&ae.height===q,"inconsistent cube map face shape"),v.genMipmaps&&(i(!ae.compressed,"can not generate mipmap for compressed textures"),i(ae.mipmask===1,"can not specify mipmaps and generate mipmaps"));for(var de=ae.images,me=0;me<16;++me){var he=de[me];if(he){var ge=J>>me,ce=q>>me;i(ae.mipmask&1<<me,"missing mipmap data"),i(he.width===ge&&he.height===ce,"invalid shape for mip images"),i(he.format===f.format&&he.internalformat===f.internalformat&&he.type===f.type,"incompatible type for mip image"),he.compressed||(he.data?i(he.data.byteLength===ge*ce*Math.max(Nl(he.type,Y),he.unpackAlignment),"invalid data for image, buffer size is inconsistent with image format"):he.element||he.copy)}}}}var y=n(i,{optional:Rt,raise:a,commandRaise:$e,command:Xe,parameter:l,commandParameter:Ne,constructor:b,type:h,commandType:Ct,isTypedArray:u,nni:p,oneOf:E,shaderError:pe,linkError:Q,callSite:L,saveCommandRef:Se,saveDrawInfo:qe,framebufferFormat:Or,guessCommand:F,texture2D:lp,textureCube:fp}),up=0,dp=0,hp=5,mp=6;function Qr(f,v){this.id=up++,this.type=f,this.data=v}function Dl(f){return f.replace(/\\/g,"\\\\").replace(/"/g,'\\"')}function cs(f){if(f.length===0)return[];var v=f.charAt(0),T=f.charAt(f.length-1);if(f.length>1&&v===T&&(v==='"'||v==="'"))return['"'+Dl(f.substr(1,f.length-2))+'"'];var X=/\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(f);if(X)return cs(f.substr(0,X.index)).concat(cs(X[1])).concat(cs(f.substr(X.index+X[0].length)));var J=f.split(".");if(J.length===1)return['"'+Dl(f)+'"'];for(var q=[],Y=0;Y<J.length;++Y)q=q.concat(cs(J[Y]));return q}function kl(f){return"["+cs(f).join("][")+"]"}function pp(f,v){return new Qr(f,kl(v+""))}function vp(f){return typeof f=="function"&&!f._reglType||f instanceof Qr}function Bl(f,v){if(typeof f=="function")return new Qr(dp,f);if(typeof f=="number"||typeof f=="boolean")return new Qr(hp,f);if(Array.isArray(f))return new Qr(mp,f.map(function(T,X){return Bl(T,v+"["+X+"]")}));if(f instanceof Qr)return f;y(!1,"invalid option type in uniform "+v)}var Qt={DynamicVariable:Qr,define:pp,isDynamic:vp,unbox:Bl,accessor:kl},Ba={next:typeof requestAnimationFrame=="function"?function(f){return requestAnimationFrame(f)}:function(f){return setTimeout(f,16)},cancel:typeof cancelAnimationFrame=="function"?function(f){return cancelAnimationFrame(f)}:clearTimeout},Il=typeof performance<"u"&&performance.now?function(){return performance.now()}:function(){return+new Date};function gp(){var f={"":0},v=[""];return{id:function(T){var X=f[T];return X||(X=f[T]=v.length,v.push(T),X)},str:function(T){return v[T]}}}function yp(f,v,T){var X=document.createElement("canvas");n(X.style,{border:0,margin:0,padding:0,top:0,left:0,width:"100%",height:"100%"}),f.appendChild(X),f===document.body&&(X.style.position="absolute",n(f.style,{margin:0,padding:0}));function J(){var ie=window.innerWidth,ae=window.innerHeight;if(f!==document.body){var de=X.getBoundingClientRect();ie=de.right-de.left,ae=de.bottom-de.top}X.width=T*ie,X.height=T*ae}var q;f!==document.body&&typeof ResizeObserver=="function"?(q=new ResizeObserver(function(){setTimeout(J)}),q.observe(f)):window.addEventListener("resize",J,!1);function Y(){q?q.disconnect():window.removeEventListener("resize",J),f.removeChild(X)}return J(),{canvas:X,onDestroy:Y}}function bp(f,v){function T(X){try{return f.getContext(X,v)}catch{return null}}return T("webgl")||T("experimental-webgl")||T("webgl-experimental")}function wp(f){return typeof f.nodeName=="string"&&typeof f.appendChild=="function"&&typeof f.getBoundingClientRect=="function"}function _p(f){return typeof f.drawArrays=="function"||typeof f.drawElements=="function"}function Vl(f){return typeof f=="string"?f.split():(y(Array.isArray(f),"invalid extension array"),f)}function zl(f){return typeof f=="string"?(y(typeof document<"u","not supported outside of DOM"),document.querySelector(f)):f}function xp(f){var v=f||{},T,X,J,q,Y={},ie=[],ae=[],de=typeof window>"u"?1:window.devicePixelRatio,me=!1,he=function(ue){ue&&y.raise(ue)},ge=function(){};if(typeof v=="string"?(y(typeof document<"u","selector queries only supported in DOM enviroments"),T=document.querySelector(v),y(T,"invalid query string for element")):typeof v=="object"?wp(v)?T=v:_p(v)?(q=v,J=q.canvas):(y.constructor(v),"gl"in v?q=v.gl:"canvas"in v?J=zl(v.canvas):"container"in v&&(X=zl(v.container)),"attributes"in v&&(Y=v.attributes,y.type(Y,"object","invalid context attributes")),"extensions"in v&&(ie=Vl(v.extensions)),"optionalExtensions"in v&&(ae=Vl(v.optionalExtensions)),"onDone"in v&&(y.type(v.onDone,"function","invalid or missing onDone callback"),he=v.onDone),"profile"in v&&(me=!!v.profile),"pixelRatio"in v&&(de=+v.pixelRatio,y(de>0,"invalid pixel ratio"))):y.raise("invalid arguments to regl"),T&&(T.nodeName.toLowerCase()==="canvas"?J=T:X=T),!q){if(!J){y(typeof document<"u","must manually specify webgl context outside of DOM environments");var ce=yp(X||document.body,he,de);if(!ce)return null;J=ce.canvas,ge=ce.onDestroy}Y.premultipliedAlpha===void 0&&(Y.premultipliedAlpha=!0),q=bp(J,Y)}return q?{gl:q,canvas:J,container:X,extensions:ie,optionalExtensions:ae,pixelRatio:de,profile:me,onDone:he,onDestroy:ge}:(ge(),he("webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org"),null)}function Ep(f,v){var T={};function X(Y){y.type(Y,"string","extension name must be string");var ie=Y.toLowerCase(),ae;try{ae=T[ie]=f.getExtension(ie)}catch{}return!!ae}for(var J=0;J<v.extensions.length;++J){var q=v.extensions[J];if(!X(q))return v.onDestroy(),v.onDone('"'+q+'" extension is not supported by the current WebGL context, try upgrading your system or a different browser'),null}return v.optionalExtensions.forEach(X),{extensions:T,restore:function(){Object.keys(T).forEach(function(Y){if(T[Y]&&!X(Y))throw new Error("(regl): error restoring extension "+Y)})}}}function Kt(f,v){for(var T=Array(f),X=0;X<f;++X)T[X]=v(X);return T}var $p=5120,Ap=5121,Tp=5122,Sp=5123,Pp=5124,Cp=5125,Op=5126;function Mp(f){for(var v=16;v<=1<<28;v*=16)if(f<=v)return v;return 0}function Ul(f){var v,T;return v=(f>65535)<<4,f>>>=v,T=(f>255)<<3,f>>>=T,v|=T,T=(f>15)<<2,f>>>=T,v|=T,T=(f>3)<<1,f>>>=T,v|=T,v|f>>1}function ql(){var f=Kt(8,function(){return[]});function v(q){var Y=Mp(q),ie=f[Ul(Y)>>2];return ie.length>0?ie.pop():new ArrayBuffer(Y)}function T(q){f[Ul(q.byteLength)>>2].push(q)}function X(q,Y){var ie=null;switch(q){case $p:ie=new Int8Array(v(Y),0,Y);break;case Ap:ie=new Uint8Array(v(Y),0,Y);break;case Tp:ie=new Int16Array(v(2*Y),0,Y);break;case Sp:ie=new Uint16Array(v(2*Y),0,Y);break;case Pp:ie=new Int32Array(v(4*Y),0,Y);break;case Cp:ie=new Uint32Array(v(4*Y),0,Y);break;case Op:ie=new Float32Array(v(4*Y),0,Y);break;default:return null}return ie.length!==Y?ie.subarray(0,Y):ie}function J(q){T(q.buffer)}return{alloc:v,free:T,allocType:X,freeType:J}}var bt=ql();bt.zero=ql();var Rp=3408,Lp=3410,Fp=3411,Gp=3412,Np=3413,Dp=3414,kp=3415,Bp=33901,Ip=33902,Vp=3379,zp=3386,Up=34921,qp=36347,Xp=36348,jp=35661,Hp=35660,Yp=34930,Wp=36349,Zp=34076,Qp=34024,Kp=7936,Jp=7937,ev=7938,tv=35724,rv=34047,nv=36063,sv=34852,no=3553,Xl=34067,ov=34069,av=33984,ls=6408,Ia=5126,jl=5121,Va=36160,iv=36053,cv=36064,lv=16384,fv=function(f,v){var T=1;v.ext_texture_filter_anisotropic&&(T=f.getParameter(rv));var X=1,J=1;v.webgl_draw_buffers&&(X=f.getParameter(sv),J=f.getParameter(nv));var q=!!v.oes_texture_float;if(q){var Y=f.createTexture();f.bindTexture(no,Y),f.texImage2D(no,0,ls,1,1,0,ls,Ia,null);var ie=f.createFramebuffer();if(f.bindFramebuffer(Va,ie),f.framebufferTexture2D(Va,cv,no,Y,0),f.bindTexture(no,null),f.checkFramebufferStatus(Va)!==iv)q=!1;else{f.viewport(0,0,1,1),f.clearColor(1,0,0,1),f.clear(lv);var ae=bt.allocType(Ia,4);f.readPixels(0,0,1,1,ls,Ia,ae),f.getError()?q=!1:(f.deleteFramebuffer(ie),f.deleteTexture(Y),q=ae[0]===1),bt.freeType(ae)}}var de=typeof navigator<"u"&&(/MSIE/.test(navigator.userAgent)||/Trident\//.test(navigator.appVersion)||/Edge/.test(navigator.userAgent)),me=!0;if(!de){var he=f.createTexture(),ge=bt.allocType(jl,36);f.activeTexture(av),f.bindTexture(Xl,he),f.texImage2D(ov,0,ls,3,3,0,ls,jl,ge),bt.freeType(ge),f.bindTexture(Xl,null),f.deleteTexture(he),me=!f.getError()}return{colorBits:[f.getParameter(Lp),f.getParameter(Fp),f.getParameter(Gp),f.getParameter(Np)],depthBits:f.getParameter(Dp),stencilBits:f.getParameter(kp),subpixelBits:f.getParameter(Rp),extensions:Object.keys(v).filter(function(ce){return!!v[ce]}),maxAnisotropic:T,maxDrawbuffers:X,maxColorAttachments:J,pointSizeDims:f.getParameter(Bp),lineWidthDims:f.getParameter(Ip),maxViewportDims:f.getParameter(zp),maxCombinedTextureUnits:f.getParameter(jp),maxCubeMapSize:f.getParameter(Zp),maxRenderbufferSize:f.getParameter(Qp),maxTextureUnits:f.getParameter(Yp),maxTextureSize:f.getParameter(Vp),maxAttributes:f.getParameter(Up),maxVertexUniforms:f.getParameter(qp),maxVertexTextureUnits:f.getParameter(Hp),maxVaryingVectors:f.getParameter(Xp),maxFragmentUniforms:f.getParameter(Wp),glsl:f.getParameter(tv),renderer:f.getParameter(Jp),vendor:f.getParameter(Kp),version:f.getParameter(ev),readFloat:q,npotTextureCube:me}};function cr(f){return!!f&&typeof f=="object"&&Array.isArray(f.shape)&&Array.isArray(f.stride)&&typeof f.offset=="number"&&f.shape.length===f.stride.length&&(Array.isArray(f.data)||r(f.data))}var Jt=function(f){return Object.keys(f).map(function(v){return f[v]})},so={shape:mv,flatten:hv};function uv(f,v,T){for(var X=0;X<v;++X)T[X]=f[X]}function dv(f,v,T,X){for(var J=0,q=0;q<v;++q)for(var Y=f[q],ie=0;ie<T;++ie)X[J++]=Y[ie]}function Hl(f,v,T,X,J,q){for(var Y=q,ie=0;ie<v;++ie)for(var ae=f[ie],de=0;de<T;++de)for(var me=ae[de],he=0;he<X;++he)J[Y++]=me[he]}function Yl(f,v,T,X,J){for(var q=1,Y=T+1;Y<v.length;++Y)q*=v[Y];var ie=v[T];if(v.length-T===4){var ae=v[T+1],de=v[T+2],me=v[T+3];for(Y=0;Y<ie;++Y)Hl(f[Y],ae,de,me,X,J),J+=q}else for(Y=0;Y<ie;++Y)Yl(f[Y],v,T+1,X,J),J+=q}function hv(f,v,T,X){var J=1;if(v.length)for(var q=0;q<v.length;++q)J*=v[q];else J=0;var Y=X||bt.allocType(T,J);switch(v.length){case 0:break;case 1:uv(f,v[0],Y);break;case 2:dv(f,v[0],v[1],Y);break;case 3:Hl(f,v[0],v[1],v[2],Y,0);break;default:Yl(f,v,0,Y,0)}return Y}function mv(f){for(var v=[],T=f;T.length;T=T[0])v.push(T.length);return v}var za={"[object Int8Array]":5120,"[object Int16Array]":5122,"[object Int32Array]":5124,"[object Uint8Array]":5121,"[object Uint8ClampedArray]":5121,"[object Uint16Array]":5123,"[object Uint32Array]":5125,"[object Float32Array]":5126,"[object Float64Array]":5121,"[object ArrayBuffer]":5121},pv=5120,vv=5122,gv=5124,yv=5121,bv=5123,wv=5125,_v=5126,xv=5126,Kr={int8:pv,int16:vv,int32:gv,uint8:yv,uint16:bv,uint32:wv,float:_v,float32:xv},Ev=35048,$v=35040,oo={dynamic:Ev,stream:$v,static:35044},Ua=so.flatten,Wl=so.shape,Zl=35044,Av=35040,qa=5121,Xa=5126,Rr=[];Rr[5120]=1,Rr[5122]=2,Rr[5124]=4,Rr[5121]=1,Rr[5123]=2,Rr[5125]=4,Rr[5126]=4;function ao(f){return za[Object.prototype.toString.call(f)]|0}function Ql(f,v){for(var T=0;T<v.length;++T)f[T]=v[T]}function Kl(f,v,T,X,J,q,Y){for(var ie=0,ae=0;ae<T;++ae)for(var de=0;de<X;++de)f[ie++]=v[J*ae+q*de+Y]}function Tv(f,v,T,X){var J=0,q={};function Y(k){this.id=J++,this.buffer=f.createBuffer(),this.type=k,this.usage=Zl,this.byteLength=0,this.dimension=1,this.dtype=qa,this.persistentData=null,T.profile&&(this.stats={size:0})}Y.prototype.bind=function(){f.bindBuffer(this.type,this.buffer)},Y.prototype.destroy=function(){ge(this)};var ie=[];function ae(k,H){var fe=ie.pop();return fe||(fe=new Y(k)),fe.bind(),he(fe,H,Av,0,1,!1),fe}function de(k){ie.push(k)}function me(k,H,fe){k.byteLength=H.byteLength,f.bufferData(k.type,H,fe)}function he(k,H,fe,Te,se,Ee){var _e;if(k.usage=fe,Array.isArray(H)){if(k.dtype=Te||Xa,H.length>0){var Ge;if(Array.isArray(H[0])){_e=Wl(H);for(var te=1,K=1;K<_e.length;++K)te*=_e[K];k.dimension=te,Ge=Ua(H,_e,k.dtype),me(k,Ge,fe),Ee?k.persistentData=Ge:bt.freeType(Ge)}else if(typeof H[0]=="number"){k.dimension=se;var Oe=bt.allocType(k.dtype,H.length);Ql(Oe,H),me(k,Oe,fe),Ee?k.persistentData=Oe:bt.freeType(Oe)}else r(H[0])?(k.dimension=H[0].length,k.dtype=Te||ao(H[0])||Xa,Ge=Ua(H,[H.length,H[0].length],k.dtype),me(k,Ge,fe),Ee?k.persistentData=Ge:bt.freeType(Ge)):y.raise("invalid buffer data")}}else if(r(H))k.dtype=Te||ao(H),k.dimension=se,me(k,H,fe),Ee&&(k.persistentData=new Uint8Array(new Uint8Array(H.buffer)));else if(cr(H)){_e=H.shape;var ye=H.stride,le=H.offset,be=0,we=0,je=0,Ue=0;_e.length===1?(be=_e[0],we=1,je=ye[0],Ue=0):_e.length===2?(be=_e[0],we=_e[1],je=ye[0],Ue=ye[1]):y.raise("invalid shape"),k.dtype=Te||ao(H.data)||Xa,k.dimension=we;var xe=bt.allocType(k.dtype,be*we);Kl(xe,H.data,be,we,je,Ue,le),me(k,xe,fe),Ee?k.persistentData=xe:bt.freeType(xe)}else H instanceof ArrayBuffer?(k.dtype=qa,k.dimension=se,me(k,H,fe),Ee&&(k.persistentData=new Uint8Array(new Uint8Array(H)))):y.raise("invalid buffer data")}function ge(k){v.bufferCount--,X(k);var H=k.buffer;y(H,"buffer must not be deleted already"),f.deleteBuffer(H),k.buffer=null,delete q[k.id]}function ce(k,H,fe,Te){v.bufferCount++;var se=new Y(H);q[se.id]=se;function Ee(te){var K=Zl,Oe=null,ye=0,le=0,be=1;return Array.isArray(te)||r(te)||cr(te)||te instanceof ArrayBuffer?Oe=te:typeof te=="number"?ye=te|0:te&&(y.type(te,"object","buffer arguments must be an object, a number or an array"),"data"in te&&(y(Oe===null||Array.isArray(Oe)||r(Oe)||cr(Oe),"invalid data for buffer"),Oe=te.data),"usage"in te&&(y.parameter(te.usage,oo,"invalid buffer usage"),K=oo[te.usage]),"type"in te&&(y.parameter(te.type,Kr,"invalid buffer type"),le=Kr[te.type]),"dimension"in te&&(y.type(te.dimension,"number","invalid dimension"),be=te.dimension|0),"length"in te&&(y.nni(ye,"buffer length must be a nonnegative integer"),ye=te.length|0)),se.bind(),Oe?he(se,Oe,K,le,be,Te):(ye&&f.bufferData(se.type,ye,K),se.dtype=le||qa,se.usage=K,se.dimension=be,se.byteLength=ye),T.profile&&(se.stats.size=se.byteLength*Rr[se.dtype]),Ee}function _e(te,K){y(K+te.byteLength<=se.byteLength,"invalid buffer subdata call, buffer is too small.  Can't write data of size "+te.byteLength+" starting from offset "+K+" to a buffer of size "+se.byteLength),f.bufferSubData(se.type,K,te)}function Ge(te,K){var Oe=(K||0)|0,ye;if(se.bind(),r(te)||te instanceof ArrayBuffer)_e(te,Oe);else if(Array.isArray(te)){if(te.length>0)if(typeof te[0]=="number"){var le=bt.allocType(se.dtype,te.length);Ql(le,te),_e(le,Oe),bt.freeType(le)}else if(Array.isArray(te[0])||r(te[0])){ye=Wl(te);var be=Ua(te,ye,se.dtype);_e(be,Oe),bt.freeType(be)}else y.raise("invalid buffer data")}else if(cr(te)){ye=te.shape;var we=te.stride,je=0,Ue=0,xe=0,Ae=0;ye.length===1?(je=ye[0],Ue=1,xe=we[0],Ae=0):ye.length===2?(je=ye[0],Ue=ye[1],xe=we[0],Ae=we[1]):y.raise("invalid shape");var ke=Array.isArray(te.data)?se.dtype:ao(te.data),He=bt.allocType(ke,je*Ue);Kl(He,te.data,je,Ue,xe,Ae,te.offset),_e(He,Oe),bt.freeType(He)}else y.raise("invalid data for buffer subdata");return Ee}return fe||Ee(k),Ee._reglType="buffer",Ee._buffer=se,Ee.subdata=Ge,T.profile&&(Ee.stats=se.stats),Ee.destroy=function(){ge(se)},Ee}function ue(){Jt(q).forEach(function(k){k.buffer=f.createBuffer(),f.bindBuffer(k.type,k.buffer),f.bufferData(k.type,k.persistentData||k.byteLength,k.usage)})}return T.profile&&(v.getTotalBufferSize=function(){var k=0;return Object.keys(q).forEach(function(H){k+=q[H].stats.size}),k}),{create:ce,createStream:ae,destroyStream:de,clear:function(){Jt(q).forEach(ge),ie.forEach(ge)},getBuffer:function(k){return k&&k._buffer instanceof Y?k._buffer:null},restore:ue,_initBuffer:he}}var Sv=0,Pv=0,Cv=1,Ov=1,Mv=4,Rv=4,Lr={points:Sv,point:Pv,lines:Cv,line:Ov,triangles:Mv,triangle:Rv,"line loop":2,"line strip":3,"triangle strip":5,"triangle fan":6},Lv=0,Fv=1,fs=4,Gv=5120,An=5121,Jl=5122,Tn=5123,ef=5124,Jr=5125,ja=34963,Nv=35040,Dv=35044;function kv(f,v,T,X){var J={},q=0,Y={uint8:An,uint16:Tn};v.oes_element_index_uint&&(Y.uint32=Jr);function ie(ue){this.id=q++,J[this.id]=this,this.buffer=ue,this.primType=fs,this.vertCount=0,this.type=0}ie.prototype.bind=function(){this.buffer.bind()};var ae=[];function de(ue){var k=ae.pop();return k||(k=new ie(T.create(null,ja,!0,!1)._buffer)),he(k,ue,Nv,-1,-1,0,0),k}function me(ue){ae.push(ue)}function he(ue,k,H,fe,Te,se,Ee){ue.buffer.bind();var _e;if(k){var Ge=Ee;!Ee&&(!r(k)||cr(k)&&!r(k.data))&&(Ge=v.oes_element_index_uint?Jr:Tn),T._initBuffer(ue.buffer,k,H,Ge,3)}else f.bufferData(ja,se,H),ue.buffer.dtype=_e||An,ue.buffer.usage=H,ue.buffer.dimension=3,ue.buffer.byteLength=se;if(_e=Ee,!Ee){switch(ue.buffer.dtype){case An:case Gv:_e=An;break;case Tn:case Jl:_e=Tn;break;case Jr:case ef:_e=Jr;break;default:y.raise("unsupported type for element array")}ue.buffer.dtype=_e}ue.type=_e,y(_e!==Jr||!!v.oes_element_index_uint,"32 bit element buffers not supported, enable oes_element_index_uint first");var te=Te;te<0&&(te=ue.buffer.byteLength,_e===Tn?te>>=1:_e===Jr&&(te>>=2)),ue.vertCount=te;var K=fe;if(fe<0){K=fs;var Oe=ue.buffer.dimension;Oe===1&&(K=Lv),Oe===2&&(K=Fv),Oe===3&&(K=fs)}ue.primType=K}function ge(ue){X.elementsCount--,y(ue.buffer!==null,"must not double destroy elements"),delete J[ue.id],ue.buffer.destroy(),ue.buffer=null}function ce(ue,k){var H=T.create(null,ja,!0),fe=new ie(H._buffer);X.elementsCount++;function Te(se){if(!se)H(),fe.primType=fs,fe.vertCount=0,fe.type=An;else if(typeof se=="number")H(se),fe.primType=fs,fe.vertCount=se|0,fe.type=An;else{var Ee=null,_e=Dv,Ge=-1,te=-1,K=0,Oe=0;Array.isArray(se)||r(se)||cr(se)?Ee=se:(y.type(se,"object","invalid arguments for elements"),"data"in se&&(Ee=se.data,y(Array.isArray(Ee)||r(Ee)||cr(Ee),"invalid data for element buffer")),"usage"in se&&(y.parameter(se.usage,oo,"invalid element buffer usage"),_e=oo[se.usage]),"primitive"in se&&(y.parameter(se.primitive,Lr,"invalid element buffer primitive"),Ge=Lr[se.primitive]),"count"in se&&(y(typeof se.count=="number"&&se.count>=0,"invalid vertex count for elements"),te=se.count|0),"type"in se&&(y.parameter(se.type,Y,"invalid buffer type"),Oe=Y[se.type]),"length"in se?K=se.length|0:(K=te,Oe===Tn||Oe===Jl?K*=2:(Oe===Jr||Oe===ef)&&(K*=4))),he(fe,Ee,_e,Ge,te,K,Oe)}return Te}return Te(ue),Te._reglType="elements",Te._elements=fe,Te.subdata=function(se,Ee){return H.subdata(se,Ee),Te},Te.destroy=function(){ge(fe)},Te}return{create:ce,createStream:de,destroyStream:me,getElements:function(ue){return typeof ue=="function"&&ue._elements instanceof ie?ue._elements:null},clear:function(){Jt(J).forEach(ge)}}}var tf=new Float32Array(1),Bv=new Uint32Array(tf.buffer),Iv=5123;function rf(f){for(var v=bt.allocType(Iv,f.length),T=0;T<f.length;++T)if(isNaN(f[T]))v[T]=65535;else if(f[T]===1/0)v[T]=31744;else if(f[T]===-1/0)v[T]=64512;else{tf[0]=f[T];var X=Bv[0],J=X>>>31<<15,q=(X<<1>>>24)-127,Y=X>>13&1023;if(q<-24)v[T]=J;else if(q<-14){var ie=-14-q;v[T]=J+(Y+1024>>ie)}else q>15?v[T]=J+31744:v[T]=J+(q+15<<10)+Y}return v}function dt(f){return Array.isArray(f)||r(f)}var nf=function(f){return!(f&f-1)&&!!f},Vv=34467,hr=3553,Ha=34067,io=34069,en=6408,Ya=6406,co=6407,us=6409,lo=6410,sf=32854,Wa=32855,of=36194,zv=32819,Uv=32820,qv=33635,Xv=34042,Za=6402,fo=34041,Qa=35904,Ka=35906,Sn=36193,Ja=33776,ei=33777,ti=33778,ri=33779,af=35986,cf=35987,lf=34798,ff=35840,uf=35841,df=35842,hf=35843,mf=36196,Pn=5121,ni=5123,si=5125,ds=5126,jv=10242,Hv=10243,Yv=10497,oi=33071,Wv=33648,Zv=10240,Qv=10241,ai=9728,Kv=9729,ii=9984,pf=9985,vf=9986,ci=9987,Jv=33170,uo=4352,e2=4353,t2=4354,r2=34046,n2=3317,s2=37440,o2=37441,a2=37443,gf=37444,hs=33984,i2=[ii,vf,pf,ci],ho=[0,us,lo,co,en],or={};or[us]=or[Ya]=or[Za]=1,or[fo]=or[lo]=2,or[co]=or[Qa]=3,or[en]=or[Ka]=4;function Cn(f){return"[object "+f+"]"}var yf=Cn("HTMLCanvasElement"),bf=Cn("OffscreenCanvas"),wf=Cn("CanvasRenderingContext2D"),_f=Cn("ImageBitmap"),xf=Cn("HTMLImageElement"),Ef=Cn("HTMLVideoElement"),c2=Object.keys(za).concat([yf,bf,wf,_f,xf,Ef]),On=[];On[Pn]=1,On[ds]=4,On[Sn]=2,On[ni]=2,On[si]=4;var Lt=[];Lt[sf]=2,Lt[Wa]=2,Lt[of]=2,Lt[fo]=4,Lt[Ja]=.5,Lt[ei]=.5,Lt[ti]=1,Lt[ri]=1,Lt[af]=.5,Lt[cf]=1,Lt[lf]=1,Lt[ff]=.5,Lt[uf]=.25,Lt[df]=.5,Lt[hf]=.25,Lt[mf]=.5;function $f(f){return Array.isArray(f)&&(f.length===0||typeof f[0]=="number")}function Af(f){if(!Array.isArray(f))return!1;var v=f.length;return!(v===0||!dt(f[0]))}function tn(f){return Object.prototype.toString.call(f)}function Tf(f){return tn(f)===yf}function Sf(f){return tn(f)===bf}function l2(f){return tn(f)===wf}function f2(f){return tn(f)===_f}function u2(f){return tn(f)===xf}function d2(f){return tn(f)===Ef}function li(f){if(!f)return!1;var v=tn(f);return c2.indexOf(v)>=0?!0:$f(f)||Af(f)||cr(f)}function Pf(f){return za[Object.prototype.toString.call(f)]|0}function h2(f,v){var T=v.length;switch(f.type){case Pn:case ni:case si:case ds:var X=bt.allocType(f.type,T);X.set(v),f.data=X;break;case Sn:f.data=rf(v);break;default:y.raise("unsupported texture type, must specify a typed array")}}function Cf(f,v){return bt.allocType(f.type===Sn?ds:f.type,v)}function Of(f,v){f.type===Sn?(f.data=rf(v),bt.freeType(v)):f.data=v}function m2(f,v,T,X,J,q){for(var Y=f.width,ie=f.height,ae=f.channels,de=Y*ie*ae,me=Cf(f,de),he=0,ge=0;ge<ie;++ge)for(var ce=0;ce<Y;++ce)for(var ue=0;ue<ae;++ue)me[he++]=v[T*ce+X*ge+J*ue+q];Of(f,me)}function mo(f,v,T,X,J,q){var Y;if(typeof Lt[f]<"u"?Y=Lt[f]:Y=or[f]*On[v],q&&(Y*=6),J){for(var ie=0,ae=T;ae>=1;)ie+=Y*ae*ae,ae/=2;return ie}else return Y*T*X}function p2(f,v,T,X,J,q,Y){var ie={"don't care":uo,"dont care":uo,nice:t2,fast:e2},ae={repeat:Yv,clamp:oi,mirror:Wv},de={nearest:ai,linear:Kv},me=n({mipmap:ci,"nearest mipmap nearest":ii,"linear mipmap nearest":pf,"nearest mipmap linear":vf,"linear mipmap linear":ci},de),he={none:0,browser:gf},ge={uint8:Pn,rgba4:zv,rgb565:qv,"rgb5 a1":Uv},ce={alpha:Ya,luminance:us,"luminance alpha":lo,rgb:co,rgba:en,rgba4:sf,"rgb5 a1":Wa,rgb565:of},ue={};v.ext_srgb&&(ce.srgb=Qa,ce.srgba=Ka),v.oes_texture_float&&(ge.float32=ge.float=ds),v.oes_texture_half_float&&(ge.float16=ge["half float"]=Sn),v.webgl_depth_texture&&(n(ce,{depth:Za,"depth stencil":fo}),n(ge,{uint16:ni,uint32:si,"depth stencil":Xv})),v.webgl_compressed_texture_s3tc&&n(ue,{"rgb s3tc dxt1":Ja,"rgba s3tc dxt1":ei,"rgba s3tc dxt3":ti,"rgba s3tc dxt5":ri}),v.webgl_compressed_texture_atc&&n(ue,{"rgb atc":af,"rgba atc explicit alpha":cf,"rgba atc interpolated alpha":lf}),v.webgl_compressed_texture_pvrtc&&n(ue,{"rgb pvrtc 4bppv1":ff,"rgb pvrtc 2bppv1":uf,"rgba pvrtc 4bppv1":df,"rgba pvrtc 2bppv1":hf}),v.webgl_compressed_texture_etc1&&(ue["rgb etc1"]=mf);var k=Array.prototype.slice.call(f.getParameter(Vv));Object.keys(ue).forEach(function($){var j=ue[$];k.indexOf(j)>=0&&(ce[$]=j)});var H=Object.keys(ce);T.textureFormats=H;var fe=[];Object.keys(ce).forEach(function($){var j=ce[$];fe[j]=$});var Te=[];Object.keys(ge).forEach(function($){var j=ge[$];Te[j]=$});var se=[];Object.keys(de).forEach(function($){var j=de[$];se[j]=$});var Ee=[];Object.keys(me).forEach(function($){var j=me[$];Ee[j]=$});var _e=[];Object.keys(ae).forEach(function($){var j=ae[$];_e[j]=$});var Ge=H.reduce(function($,j){var z=ce[j];return z===us||z===Ya||z===us||z===lo||z===Za||z===fo||v.ext_srgb&&(z===Qa||z===Ka)?$[z]=z:z===Wa||j.indexOf("rgba")>=0?$[z]=en:$[z]=co,$},{});function te(){this.internalformat=en,this.format=en,this.type=Pn,this.compressed=!1,this.premultiplyAlpha=!1,this.flipY=!1,this.unpackAlignment=1,this.colorSpace=gf,this.width=0,this.height=0,this.channels=0}function K($,j){$.internalformat=j.internalformat,$.format=j.format,$.type=j.type,$.compressed=j.compressed,$.premultiplyAlpha=j.premultiplyAlpha,$.flipY=j.flipY,$.unpackAlignment=j.unpackAlignment,$.colorSpace=j.colorSpace,$.width=j.width,$.height=j.height,$.channels=j.channels}function Oe($,j){if(!(typeof j!="object"||!j)){if("premultiplyAlpha"in j&&(y.type(j.premultiplyAlpha,"boolean","invalid premultiplyAlpha"),$.premultiplyAlpha=j.premultiplyAlpha),"flipY"in j&&(y.type(j.flipY,"boolean","invalid texture flip"),$.flipY=j.flipY),"alignment"in j&&(y.oneOf(j.alignment,[1,2,4,8],"invalid texture unpack alignment"),$.unpackAlignment=j.alignment),"colorSpace"in j&&(y.parameter(j.colorSpace,he,"invalid colorSpace"),$.colorSpace=he[j.colorSpace]),"type"in j){var z=j.type;y(v.oes_texture_float||!(z==="float"||z==="float32"),"you must enable the OES_texture_float extension in order to use floating point textures."),y(v.oes_texture_half_float||!(z==="half float"||z==="float16"),"you must enable the OES_texture_half_float extension in order to use 16-bit floating point textures."),y(v.webgl_depth_texture||!(z==="uint16"||z==="uint32"||z==="depth stencil"),"you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures."),y.parameter(z,ge,"invalid texture type"),$.type=ge[z]}var Ce=$.width,Ze=$.height,w=$.channels,m=!1;"shape"in j?(y(Array.isArray(j.shape)&&j.shape.length>=2,"shape must be an array"),Ce=j.shape[0],Ze=j.shape[1],j.shape.length===3&&(w=j.shape[2],y(w>0&&w<=4,"invalid number of channels"),m=!0),y(Ce>=0&&Ce<=T.maxTextureSize,"invalid width"),y(Ze>=0&&Ze<=T.maxTextureSize,"invalid height")):("radius"in j&&(Ce=Ze=j.radius,y(Ce>=0&&Ce<=T.maxTextureSize,"invalid radius")),"width"in j&&(Ce=j.width,y(Ce>=0&&Ce<=T.maxTextureSize,"invalid width")),"height"in j&&(Ze=j.height,y(Ze>=0&&Ze<=T.maxTextureSize,"invalid height")),"channels"in j&&(w=j.channels,y(w>0&&w<=4,"invalid number of channels"),m=!0)),$.width=Ce|0,$.height=Ze|0,$.channels=w|0;var P=!1;if("format"in j){var D=j.format;y(v.webgl_depth_texture||!(D==="depth"||D==="depth stencil"),"you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures."),y.parameter(D,ce,"invalid texture format");var B=$.internalformat=ce[D];$.format=Ge[B],D in ge&&("type"in j||($.type=ge[D])),D in ue&&($.compressed=!0),P=!0}!m&&P?$.channels=or[$.format]:m&&!P?$.channels!==ho[$.format]&&($.format=$.internalformat=ho[$.channels]):P&&m&&y($.channels===or[$.format],"number of channels inconsistent with specified format")}}function ye($){f.pixelStorei(s2,$.flipY),f.pixelStorei(o2,$.premultiplyAlpha),f.pixelStorei(a2,$.colorSpace),f.pixelStorei(n2,$.unpackAlignment)}function le(){te.call(this),this.xOffset=0,this.yOffset=0,this.data=null,this.needsFree=!1,this.element=null,this.needsCopy=!1}function be($,j){var z=null;if(li(j)?z=j:j&&(y.type(j,"object","invalid pixel data type"),Oe($,j),"x"in j&&($.xOffset=j.x|0),"y"in j&&($.yOffset=j.y|0),li(j.data)&&(z=j.data)),y(!$.compressed||z instanceof Uint8Array,"compressed texture data must be stored in a uint8array"),j.copy){y(!z,"can not specify copy and data field for the same texture");var Ce=J.viewportWidth,Ze=J.viewportHeight;$.width=$.width||Ce-$.xOffset,$.height=$.height||Ze-$.yOffset,$.needsCopy=!0,y($.xOffset>=0&&$.xOffset<Ce&&$.yOffset>=0&&$.yOffset<Ze&&$.width>0&&$.width<=Ce&&$.height>0&&$.height<=Ze,"copy texture read out of bounds")}else if(!z)$.width=$.width||1,$.height=$.height||1,$.channels=$.channels||4;else if(r(z))$.channels=$.channels||4,$.data=z,!("type"in j)&&$.type===Pn&&($.type=Pf(z));else if($f(z))$.channels=$.channels||4,h2($,z),$.alignment=1,$.needsFree=!0;else if(cr(z)){var w=z.data;!Array.isArray(w)&&$.type===Pn&&($.type=Pf(w));var m=z.shape,P=z.stride,D,B,O,C,N,_;m.length===3?(O=m[2],_=P[2]):(y(m.length===2,"invalid ndarray pixel data, must be 2 or 3D"),O=1,_=1),D=m[0],B=m[1],C=P[0],N=P[1],$.alignment=1,$.width=D,$.height=B,$.channels=O,$.format=$.internalformat=ho[O],$.needsFree=!0,m2($,w,C,N,_,z.offset)}else if(Tf(z)||Sf(z)||l2(z))Tf(z)||Sf(z)?$.element=z:$.element=z.canvas,$.width=$.element.width,$.height=$.element.height,$.channels=4;else if(f2(z))$.element=z,$.width=z.width,$.height=z.height,$.channels=4;else if(u2(z))$.element=z,$.width=z.naturalWidth,$.height=z.naturalHeight,$.channels=4;else if(d2(z))$.element=z,$.width=z.videoWidth,$.height=z.videoHeight,$.channels=4;else if(Af(z)){var A=$.width||z[0].length,x=$.height||z.length,V=$.channels;dt(z[0][0])?V=V||z[0][0].length:V=V||1;for(var I=so.shape(z),Z=1,re=0;re<I.length;++re)Z*=I[re];var ve=Cf($,Z);so.flatten(z,I,"",ve),Of($,ve),$.alignment=1,$.width=A,$.height=x,$.channels=V,$.format=$.internalformat=ho[V],$.needsFree=!0}$.type===ds?y(T.extensions.indexOf("oes_texture_float")>=0,"oes_texture_float extension not enabled"):$.type===Sn&&y(T.extensions.indexOf("oes_texture_half_float")>=0,"oes_texture_half_float extension not enabled")}function we($,j,z){var Ce=$.element,Ze=$.data,w=$.internalformat,m=$.format,P=$.type,D=$.width,B=$.height;ye($),Ce?f.texImage2D(j,z,m,m,P,Ce):$.compressed?f.compressedTexImage2D(j,z,w,D,B,0,Ze):$.needsCopy?(X(),f.copyTexImage2D(j,z,m,$.xOffset,$.yOffset,D,B,0)):f.texImage2D(j,z,m,D,B,0,m,P,Ze||null)}function je($,j,z,Ce,Ze){var w=$.element,m=$.data,P=$.internalformat,D=$.format,B=$.type,O=$.width,C=$.height;ye($),w?f.texSubImage2D(j,Ze,z,Ce,D,B,w):$.compressed?f.compressedTexSubImage2D(j,Ze,z,Ce,P,O,C,m):$.needsCopy?(X(),f.copyTexSubImage2D(j,Ze,z,Ce,$.xOffset,$.yOffset,O,C)):f.texSubImage2D(j,Ze,z,Ce,O,C,D,B,m)}var Ue=[];function xe(){return Ue.pop()||new le}function Ae($){$.needsFree&&bt.freeType($.data),le.call($),Ue.push($)}function ke(){te.call(this),this.genMipmaps=!1,this.mipmapHint=uo,this.mipmask=0,this.images=Array(16)}function He($,j,z){var Ce=$.images[0]=xe();$.mipmask=1,Ce.width=$.width=j,Ce.height=$.height=z,Ce.channels=$.channels=4}function Je($,j){var z=null;if(li(j))z=$.images[0]=xe(),K(z,$),be(z,j),$.mipmask=1;else if(Oe($,j),Array.isArray(j.mipmap))for(var Ce=j.mipmap,Ze=0;Ze<Ce.length;++Ze)z=$.images[Ze]=xe(),K(z,$),z.width>>=Ze,z.height>>=Ze,be(z,Ce[Ze]),$.mipmask|=1<<Ze;else z=$.images[0]=xe(),K(z,$),be(z,j),$.mipmask=1;K($,$.images[0]),$.compressed&&($.internalformat===Ja||$.internalformat===ei||$.internalformat===ti||$.internalformat===ri)&&y($.width%4===0&&$.height%4===0,"for compressed texture formats, mipmap level 0 must have width and height that are a multiple of 4")}function ht($,j){for(var z=$.images,Ce=0;Ce<z.length;++Ce){if(!z[Ce])return;we(z[Ce],j,Ce)}}var mt=[];function tt(){var $=mt.pop()||new ke;te.call($),$.mipmask=0;for(var j=0;j<16;++j)$.images[j]=null;return $}function xt($){for(var j=$.images,z=0;z<j.length;++z)j[z]&&Ae(j[z]),j[z]=null;mt.push($)}function lt(){this.minFilter=ai,this.magFilter=ai,this.wrapS=oi,this.wrapT=oi,this.anisotropic=1,this.genMipmaps=!1,this.mipmapHint=uo}function _t($,j){if("min"in j){var z=j.min;y.parameter(z,me),$.minFilter=me[z],i2.indexOf($.minFilter)>=0&&!("faces"in j)&&($.genMipmaps=!0)}if("mag"in j){var Ce=j.mag;y.parameter(Ce,de),$.magFilter=de[Ce]}var Ze=$.wrapS,w=$.wrapT;if("wrap"in j){var m=j.wrap;typeof m=="string"?(y.parameter(m,ae),Ze=w=ae[m]):Array.isArray(m)&&(y.parameter(m[0],ae),y.parameter(m[1],ae),Ze=ae[m[0]],w=ae[m[1]])}else{if("wrapS"in j){var P=j.wrapS;y.parameter(P,ae),Ze=ae[P]}if("wrapT"in j){var D=j.wrapT;y.parameter(D,ae),w=ae[D]}}if($.wrapS=Ze,$.wrapT=w,"anisotropic"in j){var B=j.anisotropic;y(typeof B=="number"&&B>=1&&B<=T.maxAnisotropic,"aniso samples must be between 1 and "),$.anisotropic=j.anisotropic}if("mipmap"in j){var O=!1;switch(typeof j.mipmap){case"string":y.parameter(j.mipmap,ie,"invalid mipmap hint"),$.mipmapHint=ie[j.mipmap],$.genMipmaps=!0,O=!0;break;case"boolean":O=$.genMipmaps=j.mipmap;break;case"object":y(Array.isArray(j.mipmap),"invalid mipmap type"),$.genMipmaps=!1,O=!0;break;default:y.raise("invalid mipmap type")}O&&!("min"in j)&&($.minFilter=ii)}}function Et($,j){f.texParameteri(j,Qv,$.minFilter),f.texParameteri(j,Zv,$.magFilter),f.texParameteri(j,jv,$.wrapS),f.texParameteri(j,Hv,$.wrapT),v.ext_texture_filter_anisotropic&&f.texParameteri(j,r2,$.anisotropic),$.genMipmaps&&(f.hint(Jv,$.mipmapHint),f.generateMipmap(j))}var $t=0,Ot={},Ft=T.maxTextureUnits,vt=Array(Ft).map(function(){return null});function Ye($){te.call(this),this.mipmask=0,this.internalformat=en,this.id=$t++,this.refCount=1,this.target=$,this.texture=f.createTexture(),this.unit=-1,this.bindCount=0,this.texInfo=new lt,Y.profile&&(this.stats={size:0})}function Gt($){f.activeTexture(hs),f.bindTexture($.target,$.texture)}function at(){var $=vt[0];$?f.bindTexture($.target,$.texture):f.bindTexture(hr,null)}function De($){var j=$.texture;y(j,"must not double destroy texture");var z=$.unit,Ce=$.target;z>=0&&(f.activeTexture(hs+z),f.bindTexture(Ce,null),vt[z]=null),f.deleteTexture(j),$.texture=null,$.params=null,$.pixels=null,$.refCount=0,delete Ot[$.id],q.textureCount--}n(Ye.prototype,{bind:function(){var $=this;$.bindCount+=1;var j=$.unit;if(j<0){for(var z=0;z<Ft;++z){var Ce=vt[z];if(Ce){if(Ce.bindCount>0)continue;Ce.unit=-1}vt[z]=$,j=z;break}j>=Ft&&y.raise("insufficient number of texture units"),Y.profile&&q.maxTextureUnits<j+1&&(q.maxTextureUnits=j+1),$.unit=j,f.activeTexture(hs+j),f.bindTexture($.target,$.texture)}return j},unbind:function(){this.bindCount-=1},decRef:function(){--this.refCount<=0&&De(this)}});function et($,j){var z=new Ye(hr);Ot[z.id]=z,q.textureCount++;function Ce(m,P){var D=z.texInfo;lt.call(D);var B=tt();return typeof m=="number"?typeof P=="number"?He(B,m|0,P|0):He(B,m|0,m|0):m?(y.type(m,"object","invalid arguments to regl.texture"),_t(D,m),Je(B,m)):He(B,1,1),D.genMipmaps&&(B.mipmask=(B.width<<1)-1),z.mipmask=B.mipmask,K(z,B),y.texture2D(D,B,T),z.internalformat=B.internalformat,Ce.width=B.width,Ce.height=B.height,Gt(z),ht(B,hr),Et(D,hr),at(),xt(B),Y.profile&&(z.stats.size=mo(z.internalformat,z.type,B.width,B.height,D.genMipmaps,!1)),Ce.format=fe[z.internalformat],Ce.type=Te[z.type],Ce.mag=se[D.magFilter],Ce.min=Ee[D.minFilter],Ce.wrapS=_e[D.wrapS],Ce.wrapT=_e[D.wrapT],Ce}function Ze(m,P,D,B){y(!!m,"must specify image data");var O=P|0,C=D|0,N=B|0,_=xe();return K(_,z),_.width=0,_.height=0,be(_,m),_.width=_.width||(z.width>>N)-O,_.height=_.height||(z.height>>N)-C,y(z.type===_.type&&z.format===_.format&&z.internalformat===_.internalformat,"incompatible format for texture.subimage"),y(O>=0&&C>=0&&O+_.width<=z.width&&C+_.height<=z.height,"texture.subimage write out of bounds"),y(z.mipmask&1<<N,"missing mipmap data"),y(_.data||_.element||_.needsCopy,"missing image data"),Gt(z),je(_,hr,O,C,N),at(),Ae(_),Ce}function w(m,P){var D=m|0,B=P|0||D;if(D===z.width&&B===z.height)return Ce;Ce.width=z.width=D,Ce.height=z.height=B,Gt(z);for(var O=0;z.mipmask>>O;++O){var C=D>>O,N=B>>O;if(!C||!N)break;f.texImage2D(hr,O,z.format,C,N,0,z.format,z.type,null)}return at(),Y.profile&&(z.stats.size=mo(z.internalformat,z.type,D,B,!1,!1)),Ce}return Ce($,j),Ce.subimage=Ze,Ce.resize=w,Ce._reglType="texture2d",Ce._texture=z,Y.profile&&(Ce.stats=z.stats),Ce.destroy=function(){z.decRef()},Ce}function nt($,j,z,Ce,Ze,w){var m=new Ye(Ha);Ot[m.id]=m,q.cubeCount++;var P=new Array(6);function D(C,N,_,A,x,V){var I,Z=m.texInfo;for(lt.call(Z),I=0;I<6;++I)P[I]=tt();if(typeof C=="number"||!C){var re=C|0||1;for(I=0;I<6;++I)He(P[I],re,re)}else if(typeof C=="object")if(N)Je(P[0],C),Je(P[1],N),Je(P[2],_),Je(P[3],A),Je(P[4],x),Je(P[5],V);else if(_t(Z,C),Oe(m,C),"faces"in C){var ve=C.faces;for(y(Array.isArray(ve)&&ve.length===6,"cube faces must be a length 6 array"),I=0;I<6;++I)y(typeof ve[I]=="object"&&!!ve[I],"invalid input for cube map face"),K(P[I],m),Je(P[I],ve[I])}else for(I=0;I<6;++I)Je(P[I],C);else y.raise("invalid arguments to cube map");for(K(m,P[0]),y.optional(function(){T.npotTextureCube||y(nf(m.width)&&nf(m.height),"your browser does not support non power or two texture dimensions")}),Z.genMipmaps?m.mipmask=(P[0].width<<1)-1:m.mipmask=P[0].mipmask,y.textureCube(m,Z,P,T),m.internalformat=P[0].internalformat,D.width=P[0].width,D.height=P[0].height,Gt(m),I=0;I<6;++I)ht(P[I],io+I);for(Et(Z,Ha),at(),Y.profile&&(m.stats.size=mo(m.internalformat,m.type,D.width,D.height,Z.genMipmaps,!0)),D.format=fe[m.internalformat],D.type=Te[m.type],D.mag=se[Z.magFilter],D.min=Ee[Z.minFilter],D.wrapS=_e[Z.wrapS],D.wrapT=_e[Z.wrapT],I=0;I<6;++I)xt(P[I]);return D}function B(C,N,_,A,x){y(!!N,"must specify image data"),y(typeof C=="number"&&C===(C|0)&&C>=0&&C<6,"invalid face");var V=_|0,I=A|0,Z=x|0,re=xe();return K(re,m),re.width=0,re.height=0,be(re,N),re.width=re.width||(m.width>>Z)-V,re.height=re.height||(m.height>>Z)-I,y(m.type===re.type&&m.format===re.format&&m.internalformat===re.internalformat,"incompatible format for texture.subimage"),y(V>=0&&I>=0&&V+re.width<=m.width&&I+re.height<=m.height,"texture.subimage write out of bounds"),y(m.mipmask&1<<Z,"missing mipmap data"),y(re.data||re.element||re.needsCopy,"missing image data"),Gt(m),je(re,io+C,V,I,Z),at(),Ae(re),D}function O(C){var N=C|0;if(N!==m.width){D.width=m.width=N,D.height=m.height=N,Gt(m);for(var _=0;_<6;++_)for(var A=0;m.mipmask>>A;++A)f.texImage2D(io+_,A,m.format,N>>A,N>>A,0,m.format,m.type,null);return at(),Y.profile&&(m.stats.size=mo(m.internalformat,m.type,D.width,D.height,!1,!0)),D}}return D($,j,z,Ce,Ze,w),D.subimage=B,D.resize=O,D._reglType="textureCube",D._texture=m,Y.profile&&(D.stats=m.stats),D.destroy=function(){m.decRef()},D}function gt(){for(var $=0;$<Ft;++$)f.activeTexture(hs+$),f.bindTexture(hr,null),vt[$]=null;Jt(Ot).forEach(De),q.cubeCount=0,q.textureCount=0}Y.profile&&(q.getTotalTextureSize=function(){var $=0;return Object.keys(Ot).forEach(function(j){$+=Ot[j].stats.size}),$});function pr(){for(var $=0;$<Ft;++$){var j=vt[$];j&&(j.bindCount=0,j.unit=-1,vt[$]=null)}Jt(Ot).forEach(function(z){z.texture=f.createTexture(),f.bindTexture(z.target,z.texture);for(var Ce=0;Ce<32;++Ce)if(z.mipmask&1<<Ce)if(z.target===hr)f.texImage2D(hr,Ce,z.internalformat,z.width>>Ce,z.height>>Ce,0,z.internalformat,z.type,null);else for(var Ze=0;Ze<6;++Ze)f.texImage2D(io+Ze,Ce,z.internalformat,z.width>>Ce,z.height>>Ce,0,z.internalformat,z.type,null);Et(z.texInfo,z.target)})}function ln(){for(var $=0;$<Ft;++$){var j=vt[$];j&&(j.bindCount=0,j.unit=-1,vt[$]=null),f.activeTexture(hs+$),f.bindTexture(hr,null),f.bindTexture(Ha,null)}}return{create2D:et,createCube:nt,clear:gt,getTexture:function($){return null},restore:pr,refresh:ln}}var Fr=36161,po=32854,Mf=32855,Rf=36194,Lf=33189,Ff=36168,Gf=34041,Nf=35907,Df=34836,kf=34842,Bf=34843,lr=[];lr[po]=2,lr[Mf]=2,lr[Rf]=2,lr[Lf]=2,lr[Ff]=1,lr[Gf]=4,lr[Nf]=4,lr[Df]=16,lr[kf]=8,lr[Bf]=6;function If(f,v,T){return lr[f]*v*T}var v2=function(f,v,T,X,J){var q={rgba4:po,rgb565:Rf,"rgb5 a1":Mf,depth:Lf,stencil:Ff,"depth stencil":Gf};v.ext_srgb&&(q.srgba=Nf),v.ext_color_buffer_half_float&&(q.rgba16f=kf,q.rgb16f=Bf),v.webgl_color_buffer_float&&(q.rgba32f=Df);var Y=[];Object.keys(q).forEach(function(ce){var ue=q[ce];Y[ue]=ce});var ie=0,ae={};function de(ce){this.id=ie++,this.refCount=1,this.renderbuffer=ce,this.format=po,this.width=0,this.height=0,J.profile&&(this.stats={size:0})}de.prototype.decRef=function(){--this.refCount<=0&&me(this)};function me(ce){var ue=ce.renderbuffer;y(ue,"must not double destroy renderbuffer"),f.bindRenderbuffer(Fr,null),f.deleteRenderbuffer(ue),ce.renderbuffer=null,ce.refCount=0,delete ae[ce.id],X.renderbufferCount--}function he(ce,ue){var k=new de(f.createRenderbuffer());ae[k.id]=k,X.renderbufferCount++;function H(Te,se){var Ee=0,_e=0,Ge=po;if(typeof Te=="object"&&Te){var te=Te;if("shape"in te){var K=te.shape;y(Array.isArray(K)&&K.length>=2,"invalid renderbuffer shape"),Ee=K[0]|0,_e=K[1]|0}else"radius"in te&&(Ee=_e=te.radius|0),"width"in te&&(Ee=te.width|0),"height"in te&&(_e=te.height|0);"format"in te&&(y.parameter(te.format,q,"invalid renderbuffer format"),Ge=q[te.format])}else typeof Te=="number"?(Ee=Te|0,typeof se=="number"?_e=se|0:_e=Ee):Te?y.raise("invalid arguments to renderbuffer constructor"):Ee=_e=1;if(y(Ee>0&&_e>0&&Ee<=T.maxRenderbufferSize&&_e<=T.maxRenderbufferSize,"invalid renderbuffer size"),!(Ee===k.width&&_e===k.height&&Ge===k.format))return H.width=k.width=Ee,H.height=k.height=_e,k.format=Ge,f.bindRenderbuffer(Fr,k.renderbuffer),f.renderbufferStorage(Fr,Ge,Ee,_e),y(f.getError()===0,"invalid render buffer format"),J.profile&&(k.stats.size=If(k.format,k.width,k.height)),H.format=Y[k.format],H}function fe(Te,se){var Ee=Te|0,_e=se|0||Ee;return Ee===k.width&&_e===k.height||(y(Ee>0&&_e>0&&Ee<=T.maxRenderbufferSize&&_e<=T.maxRenderbufferSize,"invalid renderbuffer size"),H.width=k.width=Ee,H.height=k.height=_e,f.bindRenderbuffer(Fr,k.renderbuffer),f.renderbufferStorage(Fr,k.format,Ee,_e),y(f.getError()===0,"invalid render buffer format"),J.profile&&(k.stats.size=If(k.format,k.width,k.height))),H}return H(ce,ue),H.resize=fe,H._reglType="renderbuffer",H._renderbuffer=k,J.profile&&(H.stats=k.stats),H.destroy=function(){k.decRef()},H}J.profile&&(X.getTotalRenderbufferSize=function(){var ce=0;return Object.keys(ae).forEach(function(ue){ce+=ae[ue].stats.size}),ce});function ge(){Jt(ae).forEach(function(ce){ce.renderbuffer=f.createRenderbuffer(),f.bindRenderbuffer(Fr,ce.renderbuffer),f.renderbufferStorage(Fr,ce.format,ce.width,ce.height)}),f.bindRenderbuffer(Fr,null)}return{create:he,clear:function(){Jt(ae).forEach(me)},restore:ge}},Er=36160,fi=36161,rn=3553,vo=34069,Vf=36064,zf=36096,Uf=36128,qf=33306,Xf=36053,g2=36054,y2=36055,b2=36057,w2=36061,_2=36193,x2=5121,E2=5126,jf=6407,Hf=6408,$2=6402,A2=[jf,Hf],ui=[];ui[Hf]=4,ui[jf]=3;var go=[];go[x2]=1,go[E2]=4,go[_2]=2;var T2=32854,S2=32855,P2=36194,C2=33189,O2=36168,Yf=34041,M2=35907,R2=34836,L2=34842,F2=34843,G2=[T2,S2,P2,M2,L2,F2,R2],Mn={};Mn[Xf]="complete",Mn[g2]="incomplete attachment",Mn[b2]="incomplete dimensions",Mn[y2]="incomplete, missing attachment",Mn[w2]="unsupported";function N2(f,v,T,X,J,q){var Y={cur:null,next:null,dirty:!1,setFBO:null},ie=["rgba"],ae=["rgba4","rgb565","rgb5 a1"];v.ext_srgb&&ae.push("srgba"),v.ext_color_buffer_half_float&&ae.push("rgba16f","rgb16f"),v.webgl_color_buffer_float&&ae.push("rgba32f");var de=["uint8"];v.oes_texture_half_float&&de.push("half float","float16"),v.oes_texture_float&&de.push("float","float32");function me(le,be,we){this.target=le,this.texture=be,this.renderbuffer=we;var je=0,Ue=0;be?(je=be.width,Ue=be.height):we&&(je=we.width,Ue=we.height),this.width=je,this.height=Ue}function he(le){le&&(le.texture&&le.texture._texture.decRef(),le.renderbuffer&&le.renderbuffer._renderbuffer.decRef())}function ge(le,be,we){if(le)if(le.texture){var je=le.texture._texture,Ue=Math.max(1,je.width),xe=Math.max(1,je.height);y(Ue===be&&xe===we,"inconsistent width/height for supplied texture"),je.refCount+=1}else{var Ae=le.renderbuffer._renderbuffer;y(Ae.width===be&&Ae.height===we,"inconsistent width/height for renderbuffer"),Ae.refCount+=1}}function ce(le,be){be&&(be.texture?f.framebufferTexture2D(Er,le,be.target,be.texture._texture.texture,0):f.framebufferRenderbuffer(Er,le,fi,be.renderbuffer._renderbuffer.renderbuffer))}function ue(le){var be=rn,we=null,je=null,Ue=le;typeof le=="object"&&(Ue=le.data,"target"in le&&(be=le.target|0)),y.type(Ue,"function","invalid attachment data");var xe=Ue._reglType;return xe==="texture2d"?(we=Ue,y(be===rn)):xe==="textureCube"?(we=Ue,y(be>=vo&&be<vo+6,"invalid cube map target")):xe==="renderbuffer"?(je=Ue,be=fi):y.raise("invalid regl object for attachment"),new me(be,we,je)}function k(le,be,we,je,Ue){if(we){var xe=X.create2D({width:le,height:be,format:je,type:Ue});return xe._texture.refCount=0,new me(rn,xe,null)}else{var Ae=J.create({width:le,height:be,format:je});return Ae._renderbuffer.refCount=0,new me(fi,null,Ae)}}function H(le){return le&&(le.texture||le.renderbuffer)}function fe(le,be,we){le&&(le.texture?le.texture.resize(be,we):le.renderbuffer&&le.renderbuffer.resize(be,we),le.width=be,le.height=we)}var Te=0,se={};function Ee(){this.id=Te++,se[this.id]=this,this.framebuffer=f.createFramebuffer(),this.width=0,this.height=0,this.colorAttachments=[],this.depthAttachment=null,this.stencilAttachment=null,this.depthStencilAttachment=null}function _e(le){le.colorAttachments.forEach(he),he(le.depthAttachment),he(le.stencilAttachment),he(le.depthStencilAttachment)}function Ge(le){var be=le.framebuffer;y(be,"must not double destroy framebuffer"),f.deleteFramebuffer(be),le.framebuffer=null,q.framebufferCount--,delete se[le.id]}function te(le){var be;f.bindFramebuffer(Er,le.framebuffer);var we=le.colorAttachments;for(be=0;be<we.length;++be)ce(Vf+be,we[be]);for(be=we.length;be<T.maxColorAttachments;++be)f.framebufferTexture2D(Er,Vf+be,rn,null,0);f.framebufferTexture2D(Er,qf,rn,null,0),f.framebufferTexture2D(Er,zf,rn,null,0),f.framebufferTexture2D(Er,Uf,rn,null,0),ce(zf,le.depthAttachment),ce(Uf,le.stencilAttachment),ce(qf,le.depthStencilAttachment);var je=f.checkFramebufferStatus(Er);!f.isContextLost()&&je!==Xf&&y.raise("framebuffer configuration not supported, status = "+Mn[je]),f.bindFramebuffer(Er,Y.next?Y.next.framebuffer:null),Y.cur=Y.next,f.getError()}function K(le,be){var we=new Ee;q.framebufferCount++;function je(xe,Ae){var ke;y(Y.next!==we,"can not update framebuffer which is currently in use");var He=0,Je=0,ht=!0,mt=!0,tt=null,xt=!0,lt="rgba",_t="uint8",Et=1,$t=null,Ot=null,Ft=null,vt=!1;if(typeof xe=="number")He=xe|0,Je=Ae|0||He;else if(!xe)He=Je=1;else{y.type(xe,"object","invalid arguments for framebuffer");var Ye=xe;if("shape"in Ye){var Gt=Ye.shape;y(Array.isArray(Gt)&&Gt.length>=2,"invalid shape for framebuffer"),He=Gt[0],Je=Gt[1]}else"radius"in Ye&&(He=Je=Ye.radius),"width"in Ye&&(He=Ye.width),"height"in Ye&&(Je=Ye.height);("color"in Ye||"colors"in Ye)&&(tt=Ye.color||Ye.colors,Array.isArray(tt)&&y(tt.length===1||v.webgl_draw_buffers,"multiple render targets not supported")),tt||("colorCount"in Ye&&(Et=Ye.colorCount|0,y(Et>0,"invalid color buffer count")),"colorTexture"in Ye&&(xt=!!Ye.colorTexture,lt="rgba4"),"colorType"in Ye&&(_t=Ye.colorType,xt?(y(v.oes_texture_float||!(_t==="float"||_t==="float32"),"you must enable OES_texture_float in order to use floating point framebuffer objects"),y(v.oes_texture_half_float||!(_t==="half float"||_t==="float16"),"you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects")):_t==="half float"||_t==="float16"?(y(v.ext_color_buffer_half_float,"you must enable EXT_color_buffer_half_float to use 16-bit render buffers"),lt="rgba16f"):(_t==="float"||_t==="float32")&&(y(v.webgl_color_buffer_float,"you must enable WEBGL_color_buffer_float in order to use 32-bit floating point renderbuffers"),lt="rgba32f"),y.oneOf(_t,de,"invalid color type")),"colorFormat"in Ye&&(lt=Ye.colorFormat,ie.indexOf(lt)>=0?xt=!0:ae.indexOf(lt)>=0?xt=!1:y.optional(function(){xt?y.oneOf(Ye.colorFormat,ie,"invalid color format for texture"):y.oneOf(Ye.colorFormat,ae,"invalid color format for renderbuffer")}))),("depthTexture"in Ye||"depthStencilTexture"in Ye)&&(vt=!!(Ye.depthTexture||Ye.depthStencilTexture),y(!vt||v.webgl_depth_texture,"webgl_depth_texture extension not supported")),"depth"in Ye&&(typeof Ye.depth=="boolean"?ht=Ye.depth:($t=Ye.depth,mt=!1)),"stencil"in Ye&&(typeof Ye.stencil=="boolean"?mt=Ye.stencil:(Ot=Ye.stencil,ht=!1)),"depthStencil"in Ye&&(typeof Ye.depthStencil=="boolean"?ht=mt=Ye.depthStencil:(Ft=Ye.depthStencil,ht=!1,mt=!1))}var at=null,De=null,et=null,nt=null;if(Array.isArray(tt))at=tt.map(ue);else if(tt)at=[ue(tt)];else for(at=new Array(Et),ke=0;ke<Et;++ke)at[ke]=k(He,Je,xt,lt,_t);y(v.webgl_draw_buffers||at.length<=1,"you must enable the WEBGL_draw_buffers extension in order to use multiple color buffers."),y(at.length<=T.maxColorAttachments,"too many color attachments, not supported"),He=He||at[0].width,Je=Je||at[0].height,$t?De=ue($t):ht&&!mt&&(De=k(He,Je,vt,"depth","uint32")),Ot?et=ue(Ot):mt&&!ht&&(et=k(He,Je,!1,"stencil","uint8")),Ft?nt=ue(Ft):!$t&&!Ot&&mt&&ht&&(nt=k(He,Je,vt,"depth stencil","depth stencil")),y(!!$t+!!Ot+!!Ft<=1,"invalid framebuffer configuration, can specify exactly one depth/stencil attachment");var gt=null;for(ke=0;ke<at.length;++ke)if(ge(at[ke],He,Je),y(!at[ke]||at[ke].texture&&A2.indexOf(at[ke].texture._texture.format)>=0||at[ke].renderbuffer&&G2.indexOf(at[ke].renderbuffer._renderbuffer.format)>=0,"framebuffer color attachment "+ke+" is invalid"),at[ke]&&at[ke].texture){var pr=ui[at[ke].texture._texture.format]*go[at[ke].texture._texture.type];gt===null?gt=pr:y(gt===pr,"all color attachments much have the same number of bits per pixel.")}return ge(De,He,Je),y(!De||De.texture&&De.texture._texture.format===$2||De.renderbuffer&&De.renderbuffer._renderbuffer.format===C2,"invalid depth attachment for framebuffer object"),ge(et,He,Je),y(!et||et.renderbuffer&&et.renderbuffer._renderbuffer.format===O2,"invalid stencil attachment for framebuffer object"),ge(nt,He,Je),y(!nt||nt.texture&&nt.texture._texture.format===Yf||nt.renderbuffer&&nt.renderbuffer._renderbuffer.format===Yf,"invalid depth-stencil attachment for framebuffer object"),_e(we),we.width=He,we.height=Je,we.colorAttachments=at,we.depthAttachment=De,we.stencilAttachment=et,we.depthStencilAttachment=nt,je.color=at.map(H),je.depth=H(De),je.stencil=H(et),je.depthStencil=H(nt),je.width=we.width,je.height=we.height,te(we),je}function Ue(xe,Ae){y(Y.next!==we,"can not resize a framebuffer which is currently in use");var ke=Math.max(xe|0,1),He=Math.max(Ae|0||ke,1);if(ke===we.width&&He===we.height)return je;for(var Je=we.colorAttachments,ht=0;ht<Je.length;++ht)fe(Je[ht],ke,He);return fe(we.depthAttachment,ke,He),fe(we.stencilAttachment,ke,He),fe(we.depthStencilAttachment,ke,He),we.width=je.width=ke,we.height=je.height=He,te(we),je}return je(le,be),n(je,{resize:Ue,_reglType:"framebuffer",_framebuffer:we,destroy:function(){Ge(we),_e(we)},use:function(xe){Y.setFBO({framebuffer:je},xe)}})}function Oe(le){var be=Array(6);function we(Ue){var xe;y(be.indexOf(Y.next)<0,"can not update framebuffer which is currently in use");var Ae={color:null},ke=0,He=null,Je="rgba",ht="uint8",mt=1;if(typeof Ue=="number")ke=Ue|0;else if(!Ue)ke=1;else{y.type(Ue,"object","invalid arguments for framebuffer");var tt=Ue;if("shape"in tt){var xt=tt.shape;y(Array.isArray(xt)&&xt.length>=2,"invalid shape for framebuffer"),y(xt[0]===xt[1],"cube framebuffer must be square"),ke=xt[0]}else"radius"in tt&&(ke=tt.radius|0),"width"in tt?(ke=tt.width|0,"height"in tt&&y(tt.height===ke,"must be square")):"height"in tt&&(ke=tt.height|0);("color"in tt||"colors"in tt)&&(He=tt.color||tt.colors,Array.isArray(He)&&y(He.length===1||v.webgl_draw_buffers,"multiple render targets not supported")),He||("colorCount"in tt&&(mt=tt.colorCount|0,y(mt>0,"invalid color buffer count")),"colorType"in tt&&(y.oneOf(tt.colorType,de,"invalid color type"),ht=tt.colorType),"colorFormat"in tt&&(Je=tt.colorFormat,y.oneOf(tt.colorFormat,ie,"invalid color format for texture"))),"depth"in tt&&(Ae.depth=tt.depth),"stencil"in tt&&(Ae.stencil=tt.stencil),"depthStencil"in tt&&(Ae.depthStencil=tt.depthStencil)}var lt;if(He)if(Array.isArray(He))for(lt=[],xe=0;xe<He.length;++xe)lt[xe]=He[xe];else lt=[He];else{lt=Array(mt);var _t={radius:ke,format:Je,type:ht};for(xe=0;xe<mt;++xe)lt[xe]=X.createCube(_t)}for(Ae.color=Array(lt.length),xe=0;xe<lt.length;++xe){var Et=lt[xe];y(typeof Et=="function"&&Et._reglType==="textureCube","invalid cube map"),ke=ke||Et.width,y(Et.width===ke&&Et.height===ke,"invalid cube map shape"),Ae.color[xe]={target:vo,data:lt[xe]}}for(xe=0;xe<6;++xe){for(var $t=0;$t<lt.length;++$t)Ae.color[$t].target=vo+xe;xe>0&&(Ae.depth=be[0].depth,Ae.stencil=be[0].stencil,Ae.depthStencil=be[0].depthStencil),be[xe]?be[xe](Ae):be[xe]=K(Ae)}return n(we,{width:ke,height:ke,color:lt})}function je(Ue){var xe,Ae=Ue|0;if(y(Ae>0&&Ae<=T.maxCubeMapSize,"invalid radius for cube fbo"),Ae===we.width)return we;var ke=we.color;for(xe=0;xe<ke.length;++xe)ke[xe].resize(Ae);for(xe=0;xe<6;++xe)be[xe].resize(Ae);return we.width=we.height=Ae,we}return we(le),n(we,{faces:be,resize:je,_reglType:"framebufferCube",destroy:function(){be.forEach(function(Ue){Ue.destroy()})}})}function ye(){Y.cur=null,Y.next=null,Y.dirty=!0,Jt(se).forEach(function(le){le.framebuffer=f.createFramebuffer(),te(le)})}return n(Y,{getFramebuffer:function(le){if(typeof le=="function"&&le._reglType==="framebuffer"){var be=le._framebuffer;if(be instanceof Ee)return be}return null},create:K,createCube:Oe,clear:function(){Jt(se).forEach(Ge)},restore:ye})}var D2=5126,Wf=34962,yo=34963,Zf=["attributes","elements","offset","count","primitive","instances"];function di(){this.state=0,this.x=0,this.y=0,this.z=0,this.w=0,this.buffer=null,this.size=0,this.normalized=!1,this.type=D2,this.offset=0,this.stride=0,this.divisor=0}function k2(f,v,T,X,J,q,Y){for(var ie=T.maxAttributes,ae=new Array(ie),de=0;de<ie;++de)ae[de]=new di;var me=0,he={},ge={Record:di,scope:{},state:ae,currentVAO:null,targetVAO:null,restore:ue()?_e:function(){},createVAO:Ge,getVAO:H,destroyBuffer:ce,setVAO:ue()?fe:Te,clear:ue()?se:function(){}};function ce(te){for(var K=0;K<ae.length;++K){var Oe=ae[K];Oe.buffer===te&&(f.disableVertexAttribArray(K),Oe.buffer=null)}}function ue(){return v.oes_vertex_array_object}function k(){return v.angle_instanced_arrays}function H(te){return typeof te=="function"&&te._vao?te._vao:null}function fe(te){if(te!==ge.currentVAO){var K=ue();te?K.bindVertexArrayOES(te.vao):K.bindVertexArrayOES(null),ge.currentVAO=te}}function Te(te){if(te!==ge.currentVAO){if(te)te.bindAttrs();else{for(var K=k(),Oe=0;Oe<ae.length;++Oe){var ye=ae[Oe];ye.buffer?(f.enableVertexAttribArray(Oe),ye.buffer.bind(),f.vertexAttribPointer(Oe,ye.size,ye.type,ye.normalized,ye.stride,ye.offfset),K&&ye.divisor&&K.vertexAttribDivisorANGLE(Oe,ye.divisor)):(f.disableVertexAttribArray(Oe),f.vertexAttrib4f(Oe,ye.x,ye.y,ye.z,ye.w))}Y.elements?f.bindBuffer(yo,Y.elements.buffer.buffer):f.bindBuffer(yo,null)}ge.currentVAO=te}}function se(){Jt(he).forEach(function(te){te.destroy()})}function Ee(){this.id=++me,this.attributes=[],this.elements=null,this.ownsElements=!1,this.count=0,this.offset=0,this.instances=-1,this.primitive=4;var te=ue();te?this.vao=te.createVertexArrayOES():this.vao=null,he[this.id]=this,this.buffers=[]}Ee.prototype.bindAttrs=function(){for(var te=k(),K=this.attributes,Oe=0;Oe<K.length;++Oe){var ye=K[Oe];ye.buffer?(f.enableVertexAttribArray(Oe),f.bindBuffer(Wf,ye.buffer.buffer),f.vertexAttribPointer(Oe,ye.size,ye.type,ye.normalized,ye.stride,ye.offset),te&&ye.divisor&&te.vertexAttribDivisorANGLE(Oe,ye.divisor)):(f.disableVertexAttribArray(Oe),f.vertexAttrib4f(Oe,ye.x,ye.y,ye.z,ye.w))}for(var le=K.length;le<ie;++le)f.disableVertexAttribArray(le);var be=q.getElements(this.elements);be?f.bindBuffer(yo,be.buffer.buffer):f.bindBuffer(yo,null)},Ee.prototype.refresh=function(){var te=ue();te&&(te.bindVertexArrayOES(this.vao),this.bindAttrs(),ge.currentVAO=null,te.bindVertexArrayOES(null))},Ee.prototype.destroy=function(){if(this.vao){var te=ue();this===ge.currentVAO&&(ge.currentVAO=null,te.bindVertexArrayOES(null)),te.deleteVertexArrayOES(this.vao),this.vao=null}this.ownsElements&&(this.elements.destroy(),this.elements=null,this.ownsElements=!1),he[this.id]&&(delete he[this.id],X.vaoCount-=1)};function _e(){var te=ue();te&&Jt(he).forEach(function(K){K.refresh()})}function Ge(te){var K=new Ee;X.vaoCount+=1;function Oe(ye){var le;if(Array.isArray(ye))le=ye,K.elements&&K.ownsElements&&K.elements.destroy(),K.elements=null,K.ownsElements=!1,K.offset=0,K.count=0,K.instances=-1,K.primitive=4;else{if(y(typeof ye=="object","invalid arguments for create vao"),y("attributes"in ye,"must specify attributes for vao"),ye.elements){var be=ye.elements;K.ownsElements?typeof be=="function"&&be._reglType==="elements"?(K.elements.destroy(),K.ownsElements=!1):(K.elements(be),K.ownsElements=!1):q.getElements(ye.elements)?(K.elements=ye.elements,K.ownsElements=!1):(K.elements=q.create(ye.elements),K.ownsElements=!0)}else K.elements=null,K.ownsElements=!1;le=ye.attributes,K.offset=0,K.count=-1,K.instances=-1,K.primitive=4,K.elements&&(K.count=K.elements._elements.vertCount,K.primitive=K.elements._elements.primType),"offset"in ye&&(K.offset=ye.offset|0),"count"in ye&&(K.count=ye.count|0),"instances"in ye&&(K.instances=ye.instances|0),"primitive"in ye&&(y(ye.primitive in Lr,"bad primitive type: "+ye.primitive),K.primitive=Lr[ye.primitive]),y.optional(()=>{for(var ht=Object.keys(ye),mt=0;mt<ht.length;++mt)y(Zf.indexOf(ht[mt])>=0,'invalid option for vao: "'+ht[mt]+'" valid options are '+Zf)}),y(Array.isArray(le),"attributes must be an array")}y(le.length<ie,"too many attributes"),y(le.length>0,"must specify at least one attribute");var we={},je=K.attributes;je.length=le.length;for(var Ue=0;Ue<le.length;++Ue){var xe=le[Ue],Ae=je[Ue]=new di,ke=xe.data||xe;if(Array.isArray(ke)||r(ke)||cr(ke)){var He;K.buffers[Ue]&&(He=K.buffers[Ue],r(ke)&&He._buffer.byteLength>=ke.byteLength?He.subdata(ke):(He.destroy(),K.buffers[Ue]=null)),K.buffers[Ue]||(He=K.buffers[Ue]=J.create(xe,Wf,!1,!0)),Ae.buffer=J.getBuffer(He),Ae.size=Ae.buffer.dimension|0,Ae.normalized=!1,Ae.type=Ae.buffer.dtype,Ae.offset=0,Ae.stride=0,Ae.divisor=0,Ae.state=1,we[Ue]=1}else J.getBuffer(xe)?(Ae.buffer=J.getBuffer(xe),Ae.size=Ae.buffer.dimension|0,Ae.normalized=!1,Ae.type=Ae.buffer.dtype,Ae.offset=0,Ae.stride=0,Ae.divisor=0,Ae.state=1):J.getBuffer(xe.buffer)?(Ae.buffer=J.getBuffer(xe.buffer),Ae.size=(+xe.size||Ae.buffer.dimension)|0,Ae.normalized=!!xe.normalized||!1,"type"in xe?(y.parameter(xe.type,Kr,"invalid buffer type"),Ae.type=Kr[xe.type]):Ae.type=Ae.buffer.dtype,Ae.offset=(xe.offset||0)|0,Ae.stride=(xe.stride||0)|0,Ae.divisor=(xe.divisor||0)|0,Ae.state=1,y(Ae.size>=1&&Ae.size<=4,"size must be between 1 and 4"),y(Ae.offset>=0,"invalid offset"),y(Ae.stride>=0&&Ae.stride<=255,"stride must be between 0 and 255"),y(Ae.divisor>=0,"divisor must be positive"),y(!Ae.divisor||!!v.angle_instanced_arrays,"ANGLE_instanced_arrays must be enabled to use divisor")):"x"in xe?(y(Ue>0,"first attribute must not be a constant"),Ae.x=+xe.x||0,Ae.y=+xe.y||0,Ae.z=+xe.z||0,Ae.w=+xe.w||0,Ae.state=2):y(!1,"invalid attribute spec for location "+Ue)}for(var Je=0;Je<K.buffers.length;++Je)!we[Je]&&K.buffers[Je]&&(K.buffers[Je].destroy(),K.buffers[Je]=null);return K.refresh(),Oe}return Oe.destroy=function(){for(var ye=0;ye<K.buffers.length;++ye)K.buffers[ye]&&K.buffers[ye].destroy();K.buffers.length=0,K.ownsElements&&(K.elements.destroy(),K.elements=null,K.ownsElements=!1),K.destroy()},Oe._vao=K,Oe._reglType="vao",Oe(te)}return ge}var Qf=35632,B2=35633,I2=35718,V2=35721;function z2(f,v,T,X){var J={},q={};function Y(k,H,fe,Te){this.name=k,this.id=H,this.location=fe,this.info=Te}function ie(k,H){for(var fe=0;fe<k.length;++fe)if(k[fe].id===H.id){k[fe].location=H.location;return}k.push(H)}function ae(k,H,fe){var Te=k===Qf?J:q,se=Te[H];if(!se){var Ee=v.str(H);se=f.createShader(k),f.shaderSource(se,Ee),f.compileShader(se),y.shaderError(f,se,Ee,k,fe),Te[H]=se}return se}var de={},me=[],he=0;function ge(k,H){this.id=he++,this.fragId=k,this.vertId=H,this.program=null,this.uniforms=[],this.attributes=[],this.refCount=1,X.profile&&(this.stats={uniformsCount:0,attributesCount:0})}function ce(k,H,fe){var Te,se,Ee=ae(Qf,k.fragId),_e=ae(B2,k.vertId),Ge=k.program=f.createProgram();if(f.attachShader(Ge,Ee),f.attachShader(Ge,_e),fe)for(Te=0;Te<fe.length;++Te){var te=fe[Te];f.bindAttribLocation(Ge,te[0],te[1])}f.linkProgram(Ge),y.linkError(f,Ge,v.str(k.fragId),v.str(k.vertId),H);var K=f.getProgramParameter(Ge,I2);X.profile&&(k.stats.uniformsCount=K);var Oe=k.uniforms;for(Te=0;Te<K;++Te)if(se=f.getActiveUniform(Ge,Te),se){if(se.size>1)for(var ye=0;ye<se.size;++ye){var le=se.name.replace("[0]","["+ye+"]");ie(Oe,new Y(le,v.id(le),f.getUniformLocation(Ge,le),se))}var be=se.name;se.size>1&&(be=be.replace("[0]","")),ie(Oe,new Y(be,v.id(be),f.getUniformLocation(Ge,be),se))}var we=f.getProgramParameter(Ge,V2);X.profile&&(k.stats.attributesCount=we);var je=k.attributes;for(Te=0;Te<we;++Te)se=f.getActiveAttrib(Ge,Te),se&&ie(je,new Y(se.name,v.id(se.name),f.getAttribLocation(Ge,se.name),se))}X.profile&&(T.getMaxUniformsCount=function(){var k=0;return me.forEach(function(H){H.stats.uniformsCount>k&&(k=H.stats.uniformsCount)}),k},T.getMaxAttributesCount=function(){var k=0;return me.forEach(function(H){H.stats.attributesCount>k&&(k=H.stats.attributesCount)}),k});function ue(){J={},q={};for(var k=0;k<me.length;++k)ce(me[k],null,me[k].attributes.map(function(H){return[H.location,H.name]}))}return{clear:function(){var k=f.deleteShader.bind(f);Jt(J).forEach(k),J={},Jt(q).forEach(k),q={},me.forEach(function(H){f.deleteProgram(H.program)}),me.length=0,de={},T.shaderCount=0},program:function(k,H,fe,Te){y.command(k>=0,"missing vertex shader",fe),y.command(H>=0,"missing fragment shader",fe);var se=de[H];se||(se=de[H]={});var Ee=se[k];if(Ee&&(Ee.refCount++,!Te))return Ee;var _e=new ge(H,k);return T.shaderCount++,ce(_e,fe,Te),Ee||(se[k]=_e),me.push(_e),n(_e,{destroy:function(){if(_e.refCount--,_e.refCount<=0){f.deleteProgram(_e.program);var Ge=me.indexOf(_e);me.splice(Ge,1),T.shaderCount--}se[_e.vertId].refCount<=0&&(f.deleteShader(q[_e.vertId]),delete q[_e.vertId],delete de[_e.fragId][_e.vertId]),Object.keys(de[_e.fragId]).length||(f.deleteShader(J[_e.fragId]),delete J[_e.fragId],delete de[_e.fragId])}})},restore:ue,shader:ae,frag:-1,vert:-1}}var U2=6408,ms=5121,q2=3333,bo=5126;function X2(f,v,T,X,J,q,Y){function ie(me){var he;v.next===null?(y(J.preserveDrawingBuffer,'you must create a webgl context with "preserveDrawingBuffer":true in order to read pixels from the drawing buffer'),he=ms):(y(v.next.colorAttachments[0].texture!==null,"You cannot read from a renderbuffer"),he=v.next.colorAttachments[0].texture._texture.type,y.optional(function(){q.oes_texture_float?(y(he===ms||he===bo,"Reading from a framebuffer is only allowed for the types 'uint8' and 'float'"),he===bo&&y(Y.readFloat,"Reading 'float' values is not permitted in your browser. For a fallback, please see: https://www.npmjs.com/package/glsl-read-float")):y(he===ms,"Reading from a framebuffer is only allowed for the type 'uint8'")}));var ge=0,ce=0,ue=X.framebufferWidth,k=X.framebufferHeight,H=null;r(me)?H=me:me&&(y.type(me,"object","invalid arguments to regl.read()"),ge=me.x|0,ce=me.y|0,y(ge>=0&&ge<X.framebufferWidth,"invalid x offset for regl.read"),y(ce>=0&&ce<X.framebufferHeight,"invalid y offset for regl.read"),ue=(me.width||X.framebufferWidth-ge)|0,k=(me.height||X.framebufferHeight-ce)|0,H=me.data||null),H&&(he===ms?y(H instanceof Uint8Array,"buffer must be 'Uint8Array' when reading from a framebuffer of type 'uint8'"):he===bo&&y(H instanceof Float32Array,"buffer must be 'Float32Array' when reading from a framebuffer of type 'float'")),y(ue>0&&ue+ge<=X.framebufferWidth,"invalid width for read pixels"),y(k>0&&k+ce<=X.framebufferHeight,"invalid height for read pixels"),T();var fe=ue*k*4;return H||(he===ms?H=new Uint8Array(fe):he===bo&&(H=H||new Float32Array(fe))),y.isTypedArray(H,"data buffer for regl.read() must be a typedarray"),y(H.byteLength>=fe,"data buffer for regl.read() too small"),f.pixelStorei(q2,4),f.readPixels(ge,ce,ue,k,U2,he,H),H}function ae(me){var he;return v.setFBO({framebuffer:me.framebuffer},function(){he=ie(me)}),he}function de(me){return!me||!("framebuffer"in me)?ie(me):ae(me)}return de}function Rn(f){return Array.prototype.slice.call(f)}function Ln(f){return Rn(f).join("")}function j2(){var f=0,v=[],T=[];function X(he){for(var ge=0;ge<T.length;++ge)if(T[ge]===he)return v[ge];var ce="g"+f++;return v.push(ce),T.push(he),ce}function J(){var he=[];function ge(){he.push.apply(he,Rn(arguments))}var ce=[];function ue(){var k="v"+f++;return ce.push(k),arguments.length>0&&(he.push(k,"="),he.push.apply(he,Rn(arguments)),he.push(";")),k}return n(ge,{def:ue,toString:function(){return Ln([ce.length>0?"var "+ce.join(",")+";":"",Ln(he)])}})}function q(){var he=J(),ge=J(),ce=he.toString,ue=ge.toString;function k(H,fe){ge(H,fe,"=",he.def(H,fe),";")}return n(function(){he.apply(he,Rn(arguments))},{def:he.def,entry:he,exit:ge,save:k,set:function(H,fe,Te){k(H,fe),he(H,fe,"=",Te,";")},toString:function(){return ce()+ue()}})}function Y(){var he=Ln(arguments),ge=q(),ce=q(),ue=ge.toString,k=ce.toString;return n(ge,{then:function(){return ge.apply(ge,Rn(arguments)),this},else:function(){return ce.apply(ce,Rn(arguments)),this},toString:function(){var H=k();return H&&(H="else{"+H+"}"),Ln(["if(",he,"){",ue(),"}",H])}})}var ie=J(),ae={};function de(he,ge){var ce=[];function ue(){var se="a"+ce.length;return ce.push(se),se}ge=ge||0;for(var k=0;k<ge;++k)ue();var H=q(),fe=H.toString,Te=ae[he]=n(H,{arg:ue,toString:function(){return Ln(["function(",ce.join(),"){",fe(),"}"])}});return Te}function me(){var he=['"use strict";',ie,"return {"];Object.keys(ae).forEach(function(ue){he.push('"',ue,'":',ae[ue].toString(),",")}),he.push("}");var ge=Ln(he).replace(/;/g,`;
`).replace(/}/g,`}
`).replace(/{/g,`{
`),ce=Function.apply(null,v.concat(ge));return ce.apply(null,T)}return{global:ie,link:X,block:J,proc:de,scope:q,cond:Y,compile:me}}var Fn="xyzw".split(""),Kf=5121,Gn=1,hi=2,mi=0,pi=1,vi=2,gi=3,wo=4,Jf=5,e1=6,t1="dither",r1="blend.enable",n1="blend.color",yi="blend.equation",bi="blend.func",s1="depth.enable",o1="depth.func",a1="depth.range",i1="depth.mask",wi="colorMask",c1="cull.enable",l1="cull.face",_i="frontFace",xi="lineWidth",f1="polygonOffset.enable",Ei="polygonOffset.offset",u1="sample.alpha",d1="sample.enable",$i="sample.coverage",h1="stencil.enable",m1="stencil.mask",Ai="stencil.func",Ti="stencil.opFront",ps="stencil.opBack",p1="scissor.enable",_o="scissor.box",$r="viewport",vs="profile",nn="framebuffer",gs="vert",ys="frag",sn="elements",on="primitive",an="count",xo="offset",Eo="instances",bs="vao",Si="Width",Pi="Height",Nn=nn+Si,Dn=nn+Pi,H2=$r+Si,Y2=$r+Pi,v1="drawingBuffer",g1=v1+Si,y1=v1+Pi,W2=[bi,yi,Ai,Ti,ps,$i,$r,_o,Ei],kn=34962,Ci=34963,Z2=35632,Q2=35633,b1=3553,K2=34067,J2=2884,eg=3042,tg=3024,rg=2960,ng=2929,sg=3089,og=32823,ag=32926,ig=32928,Oi=5126,$o=35664,Ao=35665,To=35666,Mi=5124,So=35667,Po=35668,Co=35669,Ri=35670,Oo=35671,Mo=35672,Ro=35673,ws=35674,_s=35675,xs=35676,Es=35678,$s=35680,Li=4,As=1028,cn=1029,w1=2304,Fi=2305,cg=32775,lg=32776,fg=519,Gr=7680,_1=0,x1=1,E1=32774,ug=513,$1=36160,dg=36064,mr={0:0,1:1,zero:0,one:1,"src color":768,"one minus src color":769,"src alpha":770,"one minus src alpha":771,"dst color":774,"one minus dst color":775,"dst alpha":772,"one minus dst alpha":773,"constant color":32769,"one minus constant color":32770,"constant alpha":32771,"one minus constant alpha":32772,"src alpha saturate":776},A1=["constant color, constant alpha","one minus constant color, constant alpha","constant color, one minus constant alpha","one minus constant color, one minus constant alpha","constant alpha, constant color","constant alpha, one minus constant color","one minus constant alpha, constant color","one minus constant alpha, one minus constant color"],Bn={never:512,less:513,"<":513,equal:514,"=":514,"==":514,"===":514,lequal:515,"<=":515,greater:516,">":516,notequal:517,"!=":517,"!==":517,gequal:518,">=":518,always:519},Nr={0:0,zero:0,keep:7680,replace:7681,increment:7682,decrement:7683,"increment wrap":34055,"decrement wrap":34056,invert:5386},T1={frag:Z2,vert:Q2},Gi={cw:w1,ccw:Fi};function Lo(f){return Array.isArray(f)||r(f)||cr(f)}function S1(f){return f.sort(function(v,T){return v===$r?-1:T===$r?1:v<T?-1:1})}function Tt(f,v,T,X){this.thisDep=f,this.contextDep=v,this.propDep=T,this.append=X}function Dr(f){return f&&!(f.thisDep||f.contextDep||f.propDep)}function wt(f){return new Tt(!1,!1,!1,f)}function Xt(f,v){var T=f.type;if(T===mi){var X=f.data.length;return new Tt(!0,X>=1,X>=2,v)}else if(T===wo){var J=f.data;return new Tt(J.thisDep,J.contextDep,J.propDep,v)}else{if(T===Jf)return new Tt(!1,!1,!1,v);if(T===e1){for(var q=!1,Y=!1,ie=!1,ae=0;ae<f.data.length;++ae){var de=f.data[ae];if(de.type===pi)ie=!0;else if(de.type===vi)Y=!0;else if(de.type===gi)q=!0;else if(de.type===mi){q=!0;var me=de.data;me>=1&&(Y=!0),me>=2&&(ie=!0)}else de.type===wo&&(q=q||de.data.thisDep,Y=Y||de.data.contextDep,ie=ie||de.data.propDep)}return new Tt(q,Y,ie,v)}else return new Tt(T===gi,T===vi,T===pi,v)}}var P1=new Tt(!1,!1,!1,function(){});function hg(f,v,T,X,J,q,Y,ie,ae,de,me,he,ge,ce,ue){var k=de.Record,H={add:32774,subtract:32778,"reverse subtract":32779};T.ext_blend_minmax&&(H.min=cg,H.max=lg);var fe=T.angle_instanced_arrays,Te=T.webgl_draw_buffers,se=T.oes_vertex_array_object,Ee={dirty:!0,profile:ue.profile},_e={},Ge=[],te={},K={};function Oe(w){return w.replace(".","_")}function ye(w,m,P){var D=Oe(w);Ge.push(w),_e[D]=Ee[D]=!!P,te[D]=m}function le(w,m,P){var D=Oe(w);Ge.push(w),Array.isArray(P)?(Ee[D]=P.slice(),_e[D]=P.slice()):Ee[D]=_e[D]=P,K[D]=m}ye(t1,tg),ye(r1,eg),le(n1,"blendColor",[0,0,0,0]),le(yi,"blendEquationSeparate",[E1,E1]),le(bi,"blendFuncSeparate",[x1,_1,x1,_1]),ye(s1,ng,!0),le(o1,"depthFunc",ug),le(a1,"depthRange",[0,1]),le(i1,"depthMask",!0),le(wi,wi,[!0,!0,!0,!0]),ye(c1,J2),le(l1,"cullFace",cn),le(_i,_i,Fi),le(xi,xi,1),ye(f1,og),le(Ei,"polygonOffset",[0,0]),ye(u1,ag),ye(d1,ig),le($i,"sampleCoverage",[1,!1]),ye(h1,rg),le(m1,"stencilMask",-1),le(Ai,"stencilFunc",[fg,0,-1]),le(Ti,"stencilOpSeparate",[As,Gr,Gr,Gr]),le(ps,"stencilOpSeparate",[cn,Gr,Gr,Gr]),ye(p1,sg),le(_o,"scissor",[0,0,f.drawingBufferWidth,f.drawingBufferHeight]),le($r,$r,[0,0,f.drawingBufferWidth,f.drawingBufferHeight]);var be={gl:f,context:ge,strings:v,next:_e,current:Ee,draw:he,elements:q,buffer:J,shader:me,attributes:de.state,vao:de,uniforms:ae,framebuffer:ie,extensions:T,timer:ce,isBufferArgs:Lo},we={primTypes:Lr,compareFuncs:Bn,blendFuncs:mr,blendEquations:H,stencilOps:Nr,glTypes:Kr,orientationType:Gi};y.optional(function(){be.isArrayLike=dt}),Te&&(we.backBuffer=[cn],we.drawBuffer=Kt(X.maxDrawbuffers,function(w){return w===0?[0]:Kt(w,function(m){return dg+m})}));var je=0;function Ue(){var w=j2(),m=w.link,P=w.global;w.id=je++,w.batchId="0";var D=m(be),B=w.shared={props:"a0"};Object.keys(be).forEach(function(A){B[A]=P.def(D,".",A)}),y.optional(function(){w.CHECK=m(y),w.commandStr=y.guessCommand(),w.command=m(w.commandStr),w.assert=function(A,x,V){A("if(!(",x,"))",this.CHECK,".commandRaise(",m(V),",",this.command,");")},we.invalidBlendCombinations=A1});var O=w.next={},C=w.current={};Object.keys(K).forEach(function(A){Array.isArray(Ee[A])&&(O[A]=P.def(B.next,".",A),C[A]=P.def(B.current,".",A))});var N=w.constants={};Object.keys(we).forEach(function(A){N[A]=P.def(JSON.stringify(we[A]))}),w.invoke=function(A,x){switch(x.type){case mi:var V=["this",B.context,B.props,w.batchId];return A.def(m(x.data),".call(",V.slice(0,Math.max(x.data.length+1,4)),")");case pi:return A.def(B.props,x.data);case vi:return A.def(B.context,x.data);case gi:return A.def("this",x.data);case wo:return x.data.append(w,A),x.data.ref;case Jf:return x.data.toString();case e1:return x.data.map(function(I){return w.invoke(A,I)})}},w.attribCache={};var _={};return w.scopeAttrib=function(A){var x=v.id(A);if(x in _)return _[x];var V=de.scope[x];V||(V=de.scope[x]=new k);var I=_[x]=m(V);return I},w}function xe(w){var m=w.static,P=w.dynamic,D;if(vs in m){var B=!!m[vs];D=wt(function(C,N){return B}),D.enable=B}else if(vs in P){var O=P[vs];D=Xt(O,function(C,N){return C.invoke(N,O)})}return D}function Ae(w,m){var P=w.static,D=w.dynamic;if(nn in P){var B=P[nn];return B?(B=ie.getFramebuffer(B),y.command(B,"invalid framebuffer object"),wt(function(C,N){var _=C.link(B),A=C.shared;N.set(A.framebuffer,".next",_);var x=A.context;return N.set(x,"."+Nn,_+".width"),N.set(x,"."+Dn,_+".height"),_})):wt(function(C,N){var _=C.shared;N.set(_.framebuffer,".next","null");var A=_.context;return N.set(A,"."+Nn,A+"."+g1),N.set(A,"."+Dn,A+"."+y1),"null"})}else if(nn in D){var O=D[nn];return Xt(O,function(C,N){var _=C.invoke(N,O),A=C.shared,x=A.framebuffer,V=N.def(x,".getFramebuffer(",_,")");y.optional(function(){C.assert(N,"!"+_+"||"+V,"invalid framebuffer object")}),N.set(x,".next",V);var I=A.context;return N.set(I,"."+Nn,V+"?"+V+".width:"+I+"."+g1),N.set(I,"."+Dn,V+"?"+V+".height:"+I+"."+y1),V})}else return null}function ke(w,m,P){var D=w.static,B=w.dynamic;function O(_){if(_ in D){var A=D[_];y.commandType(A,"object","invalid "+_,P.commandStr);var x=!0,V=A.x|0,I=A.y|0,Z,re;return"width"in A?(Z=A.width|0,y.command(Z>=0,"invalid "+_,P.commandStr)):x=!1,"height"in A?(re=A.height|0,y.command(re>=0,"invalid "+_,P.commandStr)):x=!1,new Tt(!x&&m&&m.thisDep,!x&&m&&m.contextDep,!x&&m&&m.propDep,function(Fe,Pe){var ne=Fe.shared.context,W=Z;"width"in A||(W=Pe.def(ne,".",Nn,"-",V));var Le=re;return"height"in A||(Le=Pe.def(ne,".",Dn,"-",I)),[V,I,W,Le]})}else if(_ in B){var ve=B[_],Ve=Xt(ve,function(Fe,Pe){var ne=Fe.invoke(Pe,ve);y.optional(function(){Fe.assert(Pe,ne+"&&typeof "+ne+'==="object"',"invalid "+_)});var W=Fe.shared.context,Le=Pe.def(ne,".x|0"),Me=Pe.def(ne,".y|0"),Be=Pe.def('"width" in ',ne,"?",ne,".width|0:","(",W,".",Nn,"-",Le,")"),it=Pe.def('"height" in ',ne,"?",ne,".height|0:","(",W,".",Dn,"-",Me,")");return y.optional(function(){Fe.assert(Pe,Be+">=0&&"+it+">=0","invalid "+_)}),[Le,Me,Be,it]});return m&&(Ve.thisDep=Ve.thisDep||m.thisDep,Ve.contextDep=Ve.contextDep||m.contextDep,Ve.propDep=Ve.propDep||m.propDep),Ve}else return m?new Tt(m.thisDep,m.contextDep,m.propDep,function(Fe,Pe){var ne=Fe.shared.context;return[0,0,Pe.def(ne,".",Nn),Pe.def(ne,".",Dn)]}):null}var C=O($r);if(C){var N=C;C=new Tt(C.thisDep,C.contextDep,C.propDep,function(_,A){var x=N.append(_,A),V=_.shared.context;return A.set(V,"."+H2,x[2]),A.set(V,"."+Y2,x[3]),x})}return{viewport:C,scissor_box:O(_o)}}function He(w,m){var P=w.static,D=typeof P[ys]=="string"&&typeof P[gs]=="string";if(D){if(Object.keys(m.dynamic).length>0)return null;var B=m.static,O=Object.keys(B);if(O.length>0&&typeof B[O[0]]=="number"){for(var C=[],N=0;N<O.length;++N)y(typeof B[O[N]]=="number","must specify all vertex attribute locations when using vaos"),C.push([B[O[N]]|0,O[N]]);return C}}return null}function Je(w,m,P){var D=w.static,B=w.dynamic;function O(x){if(x in D){var V=v.id(D[x]);y.optional(function(){me.shader(T1[x],V,y.guessCommand())});var I=wt(function(){return V});return I.id=V,I}else if(x in B){var Z=B[x];return Xt(Z,function(re,ve){var Ve=re.invoke(ve,Z),Fe=ve.def(re.shared.strings,".id(",Ve,")");return y.optional(function(){ve(re.shared.shader,".shader(",T1[x],",",Fe,",",re.command,");")}),Fe})}return null}var C=O(ys),N=O(gs),_=null,A;return Dr(C)&&Dr(N)?(_=me.program(N.id,C.id,null,P),A=wt(function(x,V){return x.link(_)})):A=new Tt(C&&C.thisDep||N&&N.thisDep,C&&C.contextDep||N&&N.contextDep,C&&C.propDep||N&&N.propDep,function(x,V){var I=x.shared.shader,Z;C?Z=C.append(x,V):Z=V.def(I,".",ys);var re;N?re=N.append(x,V):re=V.def(I,".",gs);var ve=I+".program("+re+","+Z;return y.optional(function(){ve+=","+x.command}),V.def(ve+")")}),{frag:C,vert:N,progVar:A,program:_}}function ht(w,m){var P=w.static,D=w.dynamic,B={},O=!1;function C(){if(bs in P){var Pe=P[bs];return Pe!==null&&de.getVAO(Pe)===null&&(Pe=de.createVAO(Pe)),O=!0,B.vao=Pe,wt(function(W){var Le=de.getVAO(Pe);return Le?W.link(Le):"null"})}else if(bs in D){O=!0;var ne=D[bs];return Xt(ne,function(W,Le){var Me=W.invoke(Le,ne);return Le.def(W.shared.vao+".getVAO("+Me+")")})}return null}var N=C(),_=!1;function A(){if(sn in P){var Pe=P[sn];if(B.elements=Pe,Lo(Pe)){var ne=B.elements=q.create(Pe,!0);Pe=q.getElements(ne),_=!0}else Pe&&(Pe=q.getElements(Pe),_=!0,y.command(Pe,"invalid elements",m.commandStr));var W=wt(function(Me,Be){if(Pe){var it=Me.link(Pe);return Me.ELEMENTS=it,it}return Me.ELEMENTS=null,null});return W.value=Pe,W}else if(sn in D){_=!0;var Le=D[sn];return Xt(Le,function(Me,Be){var it=Me.shared,Nt=it.isBufferArgs,fn=it.elements,Ar=Me.invoke(Be,Le),vr=Be.def("null"),kr=Be.def(Nt,"(",Ar,")"),un=Me.cond(kr).then(vr,"=",fn,".createStream(",Ar,");").else(vr,"=",fn,".getElements(",Ar,");");return y.optional(function(){Me.assert(un.else,"!"+Ar+"||"+vr,"invalid elements")}),Be.entry(un),Be.exit(Me.cond(kr).then(fn,".destroyStream(",vr,");")),Me.ELEMENTS=vr,vr})}else if(O)return new Tt(N.thisDep,N.contextDep,N.propDep,function(Me,Be){return Be.def(Me.shared.vao+".currentVAO?"+Me.shared.elements+".getElements("+Me.shared.vao+".currentVAO.elements):null")});return null}var x=A();function V(){if(on in P){var Pe=P[on];return B.primitive=Pe,y.commandParameter(Pe,Lr,"invalid primitve",m.commandStr),wt(function(W,Le){return Lr[Pe]})}else if(on in D){var ne=D[on];return Xt(ne,function(W,Le){var Me=W.constants.primTypes,Be=W.invoke(Le,ne);return y.optional(function(){W.assert(Le,Be+" in "+Me,"invalid primitive, must be one of "+Object.keys(Lr))}),Le.def(Me,"[",Be,"]")})}else{if(_)return Dr(x)?x.value?wt(function(W,Le){return Le.def(W.ELEMENTS,".primType")}):wt(function(){return Li}):new Tt(x.thisDep,x.contextDep,x.propDep,function(W,Le){var Me=W.ELEMENTS;return Le.def(Me,"?",Me,".primType:",Li)});if(O)return new Tt(N.thisDep,N.contextDep,N.propDep,function(W,Le){return Le.def(W.shared.vao+".currentVAO?"+W.shared.vao+".currentVAO.primitive:"+Li)})}return null}function I(Pe,ne){if(Pe in P){var W=P[Pe]|0;return ne?B.offset=W:B.instances=W,y.command(!ne||W>=0,"invalid "+Pe,m.commandStr),wt(function(Me,Be){return ne&&(Me.OFFSET=W),W})}else if(Pe in D){var Le=D[Pe];return Xt(Le,function(Me,Be){var it=Me.invoke(Be,Le);return ne&&(Me.OFFSET=it,y.optional(function(){Me.assert(Be,it+">=0","invalid "+Pe)})),it})}else if(ne){if(_)return wt(function(Me,Be){return Me.OFFSET=0,0});if(O)return new Tt(N.thisDep,N.contextDep,N.propDep,function(Me,Be){return Be.def(Me.shared.vao+".currentVAO?"+Me.shared.vao+".currentVAO.offset:0")})}else if(O)return new Tt(N.thisDep,N.contextDep,N.propDep,function(Me,Be){return Be.def(Me.shared.vao+".currentVAO?"+Me.shared.vao+".currentVAO.instances:-1")});return null}var Z=I(xo,!0);function re(){if(an in P){var Pe=P[an]|0;return B.count=Pe,y.command(typeof Pe=="number"&&Pe>=0,"invalid vertex count",m.commandStr),wt(function(){return Pe})}else if(an in D){var ne=D[an];return Xt(ne,function(Be,it){var Nt=Be.invoke(it,ne);return y.optional(function(){Be.assert(it,"typeof "+Nt+'==="number"&&'+Nt+">=0&&"+Nt+"===("+Nt+"|0)","invalid vertex count")}),Nt})}else if(_)if(Dr(x)){if(x)return Z?new Tt(Z.thisDep,Z.contextDep,Z.propDep,function(Be,it){var Nt=it.def(Be.ELEMENTS,".vertCount-",Be.OFFSET);return y.optional(function(){Be.assert(it,Nt+">=0","invalid vertex offset/element buffer too small")}),Nt}):wt(function(Be,it){return it.def(Be.ELEMENTS,".vertCount")});var W=wt(function(){return-1});return y.optional(function(){W.MISSING=!0}),W}else{var Le=new Tt(x.thisDep||Z.thisDep,x.contextDep||Z.contextDep,x.propDep||Z.propDep,function(Be,it){var Nt=Be.ELEMENTS;return Be.OFFSET?it.def(Nt,"?",Nt,".vertCount-",Be.OFFSET,":-1"):it.def(Nt,"?",Nt,".vertCount:-1")});return y.optional(function(){Le.DYNAMIC=!0}),Le}else if(O){var Me=new Tt(N.thisDep,N.contextDep,N.propDep,function(Be,it){return it.def(Be.shared.vao,".currentVAO?",Be.shared.vao,".currentVAO.count:-1")});return Me}return null}var ve=V(),Ve=re(),Fe=I(Eo,!1);return{elements:x,primitive:ve,count:Ve,instances:Fe,offset:Z,vao:N,vaoActive:O,elementsActive:_,static:B}}function mt(w,m){var P=w.static,D=w.dynamic,B={};return Ge.forEach(function(O){var C=Oe(O);function N(_,A){if(O in P){var x=_(P[O]);B[C]=wt(function(){return x})}else if(O in D){var V=D[O];B[C]=Xt(V,function(I,Z){return A(I,Z,I.invoke(Z,V))})}}switch(O){case c1:case r1:case t1:case h1:case s1:case p1:case f1:case u1:case d1:case i1:return N(function(_){return y.commandType(_,"boolean",O,m.commandStr),_},function(_,A,x){return y.optional(function(){_.assert(A,"typeof "+x+'==="boolean"',"invalid flag "+O,_.commandStr)}),x});case o1:return N(function(_){return y.commandParameter(_,Bn,"invalid "+O,m.commandStr),Bn[_]},function(_,A,x){var V=_.constants.compareFuncs;return y.optional(function(){_.assert(A,x+" in "+V,"invalid "+O+", must be one of "+Object.keys(Bn))}),A.def(V,"[",x,"]")});case a1:return N(function(_){return y.command(dt(_)&&_.length===2&&typeof _[0]=="number"&&typeof _[1]=="number"&&_[0]<=_[1],"depth range is 2d array",m.commandStr),_},function(_,A,x){y.optional(function(){_.assert(A,_.shared.isArrayLike+"("+x+")&&"+x+".length===2&&typeof "+x+'[0]==="number"&&typeof '+x+'[1]==="number"&&'+x+"[0]<="+x+"[1]","depth range must be a 2d array")});var V=A.def("+",x,"[0]"),I=A.def("+",x,"[1]");return[V,I]});case bi:return N(function(_){y.commandType(_,"object","blend.func",m.commandStr);var A="srcRGB"in _?_.srcRGB:_.src,x="srcAlpha"in _?_.srcAlpha:_.src,V="dstRGB"in _?_.dstRGB:_.dst,I="dstAlpha"in _?_.dstAlpha:_.dst;return y.commandParameter(A,mr,C+".srcRGB",m.commandStr),y.commandParameter(x,mr,C+".srcAlpha",m.commandStr),y.commandParameter(V,mr,C+".dstRGB",m.commandStr),y.commandParameter(I,mr,C+".dstAlpha",m.commandStr),y.command(A1.indexOf(A+", "+V)===-1,"unallowed blending combination (srcRGB, dstRGB) = ("+A+", "+V+")",m.commandStr),[mr[A],mr[V],mr[x],mr[I]]},function(_,A,x){var V=_.constants.blendFuncs;y.optional(function(){_.assert(A,x+"&&typeof "+x+'==="object"',"invalid blend func, must be an object")});function I(ne,W){var Le=A.def('"',ne,W,'" in ',x,"?",x,".",ne,W,":",x,".",ne);return y.optional(function(){_.assert(A,Le+" in "+V,"invalid "+O+"."+ne+W+", must be one of "+Object.keys(mr))}),Le}var Z=I("src","RGB"),re=I("dst","RGB");y.optional(function(){var ne=_.constants.invalidBlendCombinations;_.assert(A,ne+".indexOf("+Z+'+", "+'+re+") === -1 ","unallowed blending combination for (srcRGB, dstRGB)")});var ve=A.def(V,"[",Z,"]"),Ve=A.def(V,"[",I("src","Alpha"),"]"),Fe=A.def(V,"[",re,"]"),Pe=A.def(V,"[",I("dst","Alpha"),"]");return[ve,Fe,Ve,Pe]});case yi:return N(function(_){if(typeof _=="string")return y.commandParameter(_,H,"invalid "+O,m.commandStr),[H[_],H[_]];if(typeof _=="object")return y.commandParameter(_.rgb,H,O+".rgb",m.commandStr),y.commandParameter(_.alpha,H,O+".alpha",m.commandStr),[H[_.rgb],H[_.alpha]];y.commandRaise("invalid blend.equation",m.commandStr)},function(_,A,x){var V=_.constants.blendEquations,I=A.def(),Z=A.def(),re=_.cond("typeof ",x,'==="string"');return y.optional(function(){function ve(Ve,Fe,Pe){_.assert(Ve,Pe+" in "+V,"invalid "+Fe+", must be one of "+Object.keys(H))}ve(re.then,O,x),_.assert(re.else,x+"&&typeof "+x+'==="object"',"invalid "+O),ve(re.else,O+".rgb",x+".rgb"),ve(re.else,O+".alpha",x+".alpha")}),re.then(I,"=",Z,"=",V,"[",x,"];"),re.else(I,"=",V,"[",x,".rgb];",Z,"=",V,"[",x,".alpha];"),A(re),[I,Z]});case n1:return N(function(_){return y.command(dt(_)&&_.length===4,"blend.color must be a 4d array",m.commandStr),Kt(4,function(A){return+_[A]})},function(_,A,x){return y.optional(function(){_.assert(A,_.shared.isArrayLike+"("+x+")&&"+x+".length===4","blend.color must be a 4d array")}),Kt(4,function(V){return A.def("+",x,"[",V,"]")})});case m1:return N(function(_){return y.commandType(_,"number",C,m.commandStr),_|0},function(_,A,x){return y.optional(function(){_.assert(A,"typeof "+x+'==="number"',"invalid stencil.mask")}),A.def(x,"|0")});case Ai:return N(function(_){y.commandType(_,"object",C,m.commandStr);var A=_.cmp||"keep",x=_.ref||0,V="mask"in _?_.mask:-1;return y.commandParameter(A,Bn,O+".cmp",m.commandStr),y.commandType(x,"number",O+".ref",m.commandStr),y.commandType(V,"number",O+".mask",m.commandStr),[Bn[A],x,V]},function(_,A,x){var V=_.constants.compareFuncs;y.optional(function(){function ve(){_.assert(A,Array.prototype.join.call(arguments,""),"invalid stencil.func")}ve(x+"&&typeof ",x,'==="object"'),ve('!("cmp" in ',x,")||(",x,".cmp in ",V,")")});var I=A.def('"cmp" in ',x,"?",V,"[",x,".cmp]",":",Gr),Z=A.def(x,".ref|0"),re=A.def('"mask" in ',x,"?",x,".mask|0:-1");return[I,Z,re]});case Ti:case ps:return N(function(_){y.commandType(_,"object",C,m.commandStr);var A=_.fail||"keep",x=_.zfail||"keep",V=_.zpass||"keep";return y.commandParameter(A,Nr,O+".fail",m.commandStr),y.commandParameter(x,Nr,O+".zfail",m.commandStr),y.commandParameter(V,Nr,O+".zpass",m.commandStr),[O===ps?cn:As,Nr[A],Nr[x],Nr[V]]},function(_,A,x){var V=_.constants.stencilOps;y.optional(function(){_.assert(A,x+"&&typeof "+x+'==="object"',"invalid "+O)});function I(Z){return y.optional(function(){_.assert(A,'!("'+Z+'" in '+x+")||("+x+"."+Z+" in "+V+")","invalid "+O+"."+Z+", must be one of "+Object.keys(Nr))}),A.def('"',Z,'" in ',x,"?",V,"[",x,".",Z,"]:",Gr)}return[O===ps?cn:As,I("fail"),I("zfail"),I("zpass")]});case Ei:return N(function(_){y.commandType(_,"object",C,m.commandStr);var A=_.factor|0,x=_.units|0;return y.commandType(A,"number",C+".factor",m.commandStr),y.commandType(x,"number",C+".units",m.commandStr),[A,x]},function(_,A,x){y.optional(function(){_.assert(A,x+"&&typeof "+x+'==="object"',"invalid "+O)});var V=A.def(x,".factor|0"),I=A.def(x,".units|0");return[V,I]});case l1:return N(function(_){var A=0;return _==="front"?A=As:_==="back"&&(A=cn),y.command(!!A,C,m.commandStr),A},function(_,A,x){return y.optional(function(){_.assert(A,x+'==="front"||'+x+'==="back"',"invalid cull.face")}),A.def(x,'==="front"?',As,":",cn)});case xi:return N(function(_){return y.command(typeof _=="number"&&_>=X.lineWidthDims[0]&&_<=X.lineWidthDims[1],"invalid line width, must be a positive number between "+X.lineWidthDims[0]+" and "+X.lineWidthDims[1],m.commandStr),_},function(_,A,x){return y.optional(function(){_.assert(A,"typeof "+x+'==="number"&&'+x+">="+X.lineWidthDims[0]+"&&"+x+"<="+X.lineWidthDims[1],"invalid line width")}),x});case _i:return N(function(_){return y.commandParameter(_,Gi,C,m.commandStr),Gi[_]},function(_,A,x){return y.optional(function(){_.assert(A,x+'==="cw"||'+x+'==="ccw"',"invalid frontFace, must be one of cw,ccw")}),A.def(x+'==="cw"?'+w1+":"+Fi)});case wi:return N(function(_){return y.command(dt(_)&&_.length===4,"color.mask must be length 4 array",m.commandStr),_.map(function(A){return!!A})},function(_,A,x){return y.optional(function(){_.assert(A,_.shared.isArrayLike+"("+x+")&&"+x+".length===4","invalid color.mask")}),Kt(4,function(V){return"!!"+x+"["+V+"]"})});case $i:return N(function(_){y.command(typeof _=="object"&&_,C,m.commandStr);var A="value"in _?_.value:1,x=!!_.invert;return y.command(typeof A=="number"&&A>=0&&A<=1,"sample.coverage.value must be a number between 0 and 1",m.commandStr),[A,x]},function(_,A,x){y.optional(function(){_.assert(A,x+"&&typeof "+x+'==="object"',"invalid sample.coverage")});var V=A.def('"value" in ',x,"?+",x,".value:1"),I=A.def("!!",x,".invert");return[V,I]})}}),B}function tt(w,m){var P=w.static,D=w.dynamic,B={};return Object.keys(P).forEach(function(O){var C=P[O],N;if(typeof C=="number"||typeof C=="boolean")N=wt(function(){return C});else if(typeof C=="function"){var _=C._reglType;_==="texture2d"||_==="textureCube"?N=wt(function(A){return A.link(C)}):_==="framebuffer"||_==="framebufferCube"?(y.command(C.color.length>0,'missing color attachment for framebuffer sent to uniform "'+O+'"',m.commandStr),N=wt(function(A){return A.link(C.color[0])})):y.commandRaise('invalid data for uniform "'+O+'"',m.commandStr)}else dt(C)?N=wt(function(A){var x=A.global.def("[",Kt(C.length,function(V){return y.command(typeof C[V]=="number"||typeof C[V]=="boolean","invalid uniform "+O,A.commandStr),C[V]}),"]");return x}):y.commandRaise('invalid or missing data for uniform "'+O+'"',m.commandStr);N.value=C,B[O]=N}),Object.keys(D).forEach(function(O){var C=D[O];B[O]=Xt(C,function(N,_){return N.invoke(_,C)})}),B}function xt(w,m){var P=w.static,D=w.dynamic,B={};return Object.keys(P).forEach(function(O){var C=P[O],N=v.id(O),_=new k;if(Lo(C))_.state=Gn,_.buffer=J.getBuffer(J.create(C,kn,!1,!0)),_.type=0;else{var A=J.getBuffer(C);if(A)_.state=Gn,_.buffer=A,_.type=0;else if(y.command(typeof C=="object"&&C,"invalid data for attribute "+O,m.commandStr),"constant"in C){var x=C.constant;_.buffer="null",_.state=hi,typeof x=="number"?_.x=x:(y.command(dt(x)&&x.length>0&&x.length<=4,"invalid constant for attribute "+O,m.commandStr),Fn.forEach(function(Fe,Pe){Pe<x.length&&(_[Fe]=x[Pe])}))}else{Lo(C.buffer)?A=J.getBuffer(J.create(C.buffer,kn,!1,!0)):A=J.getBuffer(C.buffer),y.command(!!A,'missing buffer for attribute "'+O+'"',m.commandStr);var V=C.offset|0;y.command(V>=0,'invalid offset for attribute "'+O+'"',m.commandStr);var I=C.stride|0;y.command(I>=0&&I<256,'invalid stride for attribute "'+O+'", must be integer betweeen [0, 255]',m.commandStr);var Z=C.size|0;y.command(!("size"in C)||Z>0&&Z<=4,'invalid size for attribute "'+O+'", must be 1,2,3,4',m.commandStr);var re=!!C.normalized,ve=0;"type"in C&&(y.commandParameter(C.type,Kr,"invalid type for attribute "+O,m.commandStr),ve=Kr[C.type]);var Ve=C.divisor|0;y.optional(function(){"divisor"in C&&(y.command(Ve===0||fe,'cannot specify divisor for attribute "'+O+'", instancing not supported',m.commandStr),y.command(Ve>=0,'invalid divisor for attribute "'+O+'"',m.commandStr));var Fe=m.commandStr,Pe=["buffer","offset","divisor","normalized","type","size","stride"];Object.keys(C).forEach(function(ne){y.command(Pe.indexOf(ne)>=0,'unknown parameter "'+ne+'" for attribute pointer "'+O+'" (valid parameters are '+Pe+")",Fe)})}),_.buffer=A,_.state=Gn,_.size=Z,_.normalized=re,_.type=ve||A.dtype,_.offset=V,_.stride=I,_.divisor=Ve}}B[O]=wt(function(Fe,Pe){var ne=Fe.attribCache;if(N in ne)return ne[N];var W={isStream:!1};return Object.keys(_).forEach(function(Le){W[Le]=_[Le]}),_.buffer&&(W.buffer=Fe.link(_.buffer),W.type=W.type||W.buffer+".dtype"),ne[N]=W,W})}),Object.keys(D).forEach(function(O){var C=D[O];function N(_,A){var x=_.invoke(A,C),V=_.shared,I=_.constants,Z=V.isBufferArgs,re=V.buffer;y.optional(function(){_.assert(A,x+"&&(typeof "+x+'==="object"||typeof '+x+'==="function")&&('+Z+"("+x+")||"+re+".getBuffer("+x+")||"+re+".getBuffer("+x+".buffer)||"+Z+"("+x+'.buffer)||("constant" in '+x+"&&(typeof "+x+'.constant==="number"||'+V.isArrayLike+"("+x+".constant))))",'invalid dynamic attribute "'+O+'"')});var ve={isStream:A.def(!1)},Ve=new k;Ve.state=Gn,Object.keys(Ve).forEach(function(W){ve[W]=A.def(""+Ve[W])});var Fe=ve.buffer,Pe=ve.type;A("if(",Z,"(",x,")){",ve.isStream,"=true;",Fe,"=",re,".createStream(",kn,",",x,");",Pe,"=",Fe,".dtype;","}else{",Fe,"=",re,".getBuffer(",x,");","if(",Fe,"){",Pe,"=",Fe,".dtype;",'}else if("constant" in ',x,"){",ve.state,"=",hi,";","if(typeof "+x+'.constant === "number"){',ve[Fn[0]],"=",x,".constant;",Fn.slice(1).map(function(W){return ve[W]}).join("="),"=0;","}else{",Fn.map(function(W,Le){return ve[W]+"="+x+".constant.length>"+Le+"?"+x+".constant["+Le+"]:0;"}).join(""),"}}else{","if(",Z,"(",x,".buffer)){",Fe,"=",re,".createStream(",kn,",",x,".buffer);","}else{",Fe,"=",re,".getBuffer(",x,".buffer);","}",Pe,'="type" in ',x,"?",I.glTypes,"[",x,".type]:",Fe,".dtype;",ve.normalized,"=!!",x,".normalized;");function ne(W){A(ve[W],"=",x,".",W,"|0;")}return ne("size"),ne("offset"),ne("stride"),ne("divisor"),A("}}"),A.exit("if(",ve.isStream,"){",re,".destroyStream(",Fe,");","}"),ve}B[O]=Xt(C,N)}),B}function lt(w){var m=w.static,P=w.dynamic,D={};return Object.keys(m).forEach(function(B){var O=m[B];D[B]=wt(function(C,N){return typeof O=="number"||typeof O=="boolean"?""+O:C.link(O)})}),Object.keys(P).forEach(function(B){var O=P[B];D[B]=Xt(O,function(C,N){return C.invoke(N,O)})}),D}function _t(w,m,P,D,B){var O=w.static,C=w.dynamic;y.optional(function(){var ne=[nn,gs,ys,sn,on,xo,an,Eo,vs,bs].concat(Ge);function W(Le){Object.keys(Le).forEach(function(Me){y.command(ne.indexOf(Me)>=0,'unknown parameter "'+Me+'"',B.commandStr)})}W(O),W(C)});var N=He(w,m),_=Ae(w),A=ke(w,_,B),x=ht(w,B),V=mt(w,B),I=Je(w,B,N);function Z(ne){var W=A[ne];W&&(V[ne]=W)}Z($r),Z(Oe(_o));var re=Object.keys(V).length>0,ve={framebuffer:_,draw:x,shader:I,state:V,dirty:re,scopeVAO:null,drawVAO:null,useVAO:!1,attributes:{}};if(ve.profile=xe(w),ve.uniforms=tt(P,B),ve.drawVAO=ve.scopeVAO=x.vao,!ve.drawVAO&&I.program&&!N&&T.angle_instanced_arrays&&x.static.elements){var Ve=!0,Fe=I.program.attributes.map(function(ne){var W=m.static[ne];return Ve=Ve&&!!W,W});if(Ve&&Fe.length>0){var Pe=de.getVAO(de.createVAO({attributes:Fe,elements:x.static.elements}));ve.drawVAO=new Tt(null,null,null,function(ne,W){return ne.link(Pe)}),ve.useVAO=!0}}return N?ve.useVAO=!0:ve.attributes=xt(m,B),ve.context=lt(D),ve}function Et(w,m,P){var D=w.shared,B=D.context,O=w.scope();Object.keys(P).forEach(function(C){m.save(B,"."+C);var N=P[C],_=N.append(w,m);Array.isArray(_)?O(B,".",C,"=[",_.join(),"];"):O(B,".",C,"=",_,";")}),m(O)}function $t(w,m,P,D){var B=w.shared,O=B.gl,C=B.framebuffer,N;Te&&(N=m.def(B.extensions,".webgl_draw_buffers"));var _=w.constants,A=_.drawBuffer,x=_.backBuffer,V;P?V=P.append(w,m):V=m.def(C,".next"),D||m("if(",V,"!==",C,".cur){"),m("if(",V,"){",O,".bindFramebuffer(",$1,",",V,".framebuffer);"),Te&&m(N,".drawBuffersWEBGL(",A,"[",V,".colorAttachments.length]);"),m("}else{",O,".bindFramebuffer(",$1,",null);"),Te&&m(N,".drawBuffersWEBGL(",x,");"),m("}",C,".cur=",V,";"),D||m("}")}function Ot(w,m,P){var D=w.shared,B=D.gl,O=w.current,C=w.next,N=D.current,_=D.next,A=w.cond(N,".dirty");Ge.forEach(function(x){var V=Oe(x);if(!(V in P.state)){var I,Z;if(V in C){I=C[V],Z=O[V];var re=Kt(Ee[V].length,function(Ve){return A.def(I,"[",Ve,"]")});A(w.cond(re.map(function(Ve,Fe){return Ve+"!=="+Z+"["+Fe+"]"}).join("||")).then(B,".",K[V],"(",re,");",re.map(function(Ve,Fe){return Z+"["+Fe+"]="+Ve}).join(";"),";"))}else{I=A.def(_,".",V);var ve=w.cond(I,"!==",N,".",V);A(ve),V in te?ve(w.cond(I).then(B,".enable(",te[V],");").else(B,".disable(",te[V],");"),N,".",V,"=",I,";"):ve(B,".",K[V],"(",I,");",N,".",V,"=",I,";")}}}),Object.keys(P.state).length===0&&A(N,".dirty=false;"),m(A)}function Ft(w,m,P,D){var B=w.shared,O=w.current,C=B.current,N=B.gl;S1(Object.keys(P)).forEach(function(_){var A=P[_];if(!(D&&!D(A))){var x=A.append(w,m);if(te[_]){var V=te[_];Dr(A)?x?m(N,".enable(",V,");"):m(N,".disable(",V,");"):m(w.cond(x).then(N,".enable(",V,");").else(N,".disable(",V,");")),m(C,".",_,"=",x,";")}else if(dt(x)){var I=O[_];m(N,".",K[_],"(",x,");",x.map(function(Z,re){return I+"["+re+"]="+Z}).join(";"),";")}else m(N,".",K[_],"(",x,");",C,".",_,"=",x,";")}})}function vt(w,m){fe&&(w.instancing=m.def(w.shared.extensions,".angle_instanced_arrays"))}function Ye(w,m,P,D,B){var O=w.shared,C=w.stats,N=O.current,_=O.timer,A=P.profile;function x(){return typeof performance>"u"?"Date.now()":"performance.now()"}var V,I;function Z(ne){V=m.def(),ne(V,"=",x(),";"),typeof B=="string"?ne(C,".count+=",B,";"):ne(C,".count++;"),ce&&(D?(I=m.def(),ne(I,"=",_,".getNumPendingQueries();")):ne(_,".beginQuery(",C,");"))}function re(ne){ne(C,".cpuTime+=",x(),"-",V,";"),ce&&(D?ne(_,".pushScopeStats(",I,",",_,".getNumPendingQueries(),",C,");"):ne(_,".endQuery();"))}function ve(ne){var W=m.def(N,".profile");m(N,".profile=",ne,";"),m.exit(N,".profile=",W,";")}var Ve;if(A){if(Dr(A)){A.enable?(Z(m),re(m.exit),ve("true")):ve("false");return}Ve=A.append(w,m),ve(Ve)}else Ve=m.def(N,".profile");var Fe=w.block();Z(Fe),m("if(",Ve,"){",Fe,"}");var Pe=w.block();re(Pe),m.exit("if(",Ve,"){",Pe,"}")}function Gt(w,m,P,D,B){var O=w.shared;function C(_){switch(_){case $o:case So:case Oo:return 2;case Ao:case Po:case Mo:return 3;case To:case Co:case Ro:return 4;default:return 1}}function N(_,A,x){var V=O.gl,I=m.def(_,".location"),Z=m.def(O.attributes,"[",I,"]"),re=x.state,ve=x.buffer,Ve=[x.x,x.y,x.z,x.w],Fe=["buffer","normalized","offset","stride"];function Pe(){m("if(!",Z,".buffer){",V,".enableVertexAttribArray(",I,");}");var W=x.type,Le;if(x.size?Le=m.def(x.size,"||",A):Le=A,m("if(",Z,".type!==",W,"||",Z,".size!==",Le,"||",Fe.map(function(Be){return Z+"."+Be+"!=="+x[Be]}).join("||"),"){",V,".bindBuffer(",kn,",",ve,".buffer);",V,".vertexAttribPointer(",[I,Le,W,x.normalized,x.stride,x.offset],");",Z,".type=",W,";",Z,".size=",Le,";",Fe.map(function(Be){return Z+"."+Be+"="+x[Be]+";"}).join(""),"}"),fe){var Me=x.divisor;m("if(",Z,".divisor!==",Me,"){",w.instancing,".vertexAttribDivisorANGLE(",[I,Me],");",Z,".divisor=",Me,";}")}}function ne(){m("if(",Z,".buffer){",V,".disableVertexAttribArray(",I,");",Z,".buffer=null;","}if(",Fn.map(function(W,Le){return Z+"."+W+"!=="+Ve[Le]}).join("||"),"){",V,".vertexAttrib4f(",I,",",Ve,");",Fn.map(function(W,Le){return Z+"."+W+"="+Ve[Le]+";"}).join(""),"}")}re===Gn?Pe():re===hi?ne():(m("if(",re,"===",Gn,"){"),Pe(),m("}else{"),ne(),m("}"))}D.forEach(function(_){var A=_.name,x=P.attributes[A],V;if(x){if(!B(x))return;V=x.append(w,m)}else{if(!B(P1))return;var I=w.scopeAttrib(A);y.optional(function(){w.assert(m,I+".state","missing attribute "+A)}),V={},Object.keys(new k).forEach(function(Z){V[Z]=m.def(I,".",Z)})}N(w.link(_),C(_.info.type),V)})}function at(w,m,P,D,B,O){for(var C=w.shared,N=C.gl,_={},A,x=0;x<D.length;++x){var V=D[x],I=V.name,Z=V.info.type,re=V.info.size,ve=P.uniforms[I];if(re>1){if(!ve)continue;var Ve=I.replace("[0]","");if(_[Ve])continue;_[Ve]=1}var Fe=w.link(V),Pe=Fe+".location",ne;if(ve){if(!B(ve))continue;if(Dr(ve)){var W=ve.value;if(y.command(W!==null&&typeof W<"u",'missing uniform "'+I+'"',w.commandStr),Z===Es||Z===$s){y.command(typeof W=="function"&&(Z===Es&&(W._reglType==="texture2d"||W._reglType==="framebuffer")||Z===$s&&(W._reglType==="textureCube"||W._reglType==="framebufferCube")),"invalid texture for uniform "+I,w.commandStr);var Le=w.link(W._texture||W.color[0]._texture);m(N,".uniform1i(",Pe,",",Le+".bind());"),m.exit(Le,".unbind();")}else if(Z===ws||Z===_s||Z===xs){y.optional(function(){y.command(dt(W),"invalid matrix for uniform "+I,w.commandStr),y.command(Z===ws&&W.length===4||Z===_s&&W.length===9||Z===xs&&W.length===16,"invalid length for matrix uniform "+I,w.commandStr)});var Me=w.global.def("new Float32Array(["+Array.prototype.slice.call(W)+"])"),Be=2;Z===_s?Be=3:Z===xs&&(Be=4),m(N,".uniformMatrix",Be,"fv(",Pe,",false,",Me,");")}else{switch(Z){case Oi:re===1?y.commandType(W,"number","uniform "+I,w.commandStr):y.command(dt(W)&&W.length===re,"uniform "+I,w.commandStr),A="1f";break;case $o:y.command(dt(W)&&W.length&&W.length%2===0&&W.length<=re*2,"uniform "+I,w.commandStr),A="2f";break;case Ao:y.command(dt(W)&&W.length&&W.length%3===0&&W.length<=re*3,"uniform "+I,w.commandStr),A="3f";break;case To:y.command(dt(W)&&W.length&&W.length%4===0&&W.length<=re*4,"uniform "+I,w.commandStr),A="4f";break;case Ri:re===1?y.commandType(W,"boolean","uniform "+I,w.commandStr):y.command(dt(W)&&W.length===re,"uniform "+I,w.commandStr),A="1i";break;case Mi:re===1?y.commandType(W,"number","uniform "+I,w.commandStr):y.command(dt(W)&&W.length===re,"uniform "+I,w.commandStr),A="1i";break;case Oo:y.command(dt(W)&&W.length&&W.length%2===0&&W.length<=re*2,"uniform "+I,w.commandStr),A="2i";break;case So:y.command(dt(W)&&W.length&&W.length%2===0&&W.length<=re*2,"uniform "+I,w.commandStr),A="2i";break;case Mo:y.command(dt(W)&&W.length&&W.length%3===0&&W.length<=re*3,"uniform "+I,w.commandStr),A="3i";break;case Po:y.command(dt(W)&&W.length&&W.length%3===0&&W.length<=re*3,"uniform "+I,w.commandStr),A="3i";break;case Ro:y.command(dt(W)&&W.length&&W.length%4===0&&W.length<=re*4,"uniform "+I,w.commandStr),A="4i";break;case Co:y.command(dt(W)&&W.length&&W.length%4===0&&W.length<=re*4,"uniform "+I,w.commandStr),A="4i";break}re>1?(A+="v",W=w.global.def("["+Array.prototype.slice.call(W)+"]")):W=dt(W)?Array.prototype.slice.call(W):W,m(N,".uniform",A,"(",Pe,",",W,");")}continue}else ne=ve.append(w,m)}else{if(!B(P1))continue;ne=m.def(C.uniforms,"[",v.id(I),"]")}Z===Es?(y(!Array.isArray(ne),"must specify a scalar prop for textures"),m("if(",ne,"&&",ne,'._reglType==="framebuffer"){',ne,"=",ne,".color[0];","}")):Z===$s&&(y(!Array.isArray(ne),"must specify a scalar prop for cube maps"),m("if(",ne,"&&",ne,'._reglType==="framebufferCube"){',ne,"=",ne,".color[0];","}")),y.optional(function(){function er(jt,Fo){w.assert(m,jt,'bad data or missing for uniform "'+I+'".  '+Fo)}function dn(jt,Fo){Fo===1&&y(!Array.isArray(ne),"must not specify an array type for uniform"),er("Array.isArray("+ne+") && typeof "+ne+'[0]===" '+jt+'" || typeof '+ne+'==="'+jt+'"',"invalid type, expected "+jt)}function ar(jt,Fo,Go){Array.isArray(ne)?y(ne.length&&ne.length%jt===0&&ne.length<=jt*Go,"must have length of "+(Go===1?"":"n * ")+jt):er(C.isArrayLike+"("+ne+")&&"+ne+".length && "+ne+".length % "+jt+" === 0 && "+ne+".length<="+jt*Go,"invalid vector, should have length of "+(Go===1?"":"n * ")+jt,w.commandStr)}function G1(jt){y(!Array.isArray(ne),"must not specify a value type"),er("typeof "+ne+'==="function"&&'+ne+'._reglType==="texture'+(jt===b1?"2d":"Cube")+'"',"invalid texture type",w.commandStr)}switch(Z){case Mi:dn("number",re);break;case So:ar(2,"number",re);break;case Po:ar(3,"number",re);break;case Co:ar(4,"number",re);break;case Oi:dn("number",re);break;case $o:ar(2,"number",re);break;case Ao:ar(3,"number",re);break;case To:ar(4,"number",re);break;case Ri:dn("boolean",re);break;case Oo:ar(2,"boolean",re);break;case Mo:ar(3,"boolean",re);break;case Ro:ar(4,"boolean",re);break;case ws:ar(4,"number",re);break;case _s:ar(9,"number",re);break;case xs:ar(16,"number",re);break;case Es:G1(b1);break;case $s:G1(K2);break}});var it=1;switch(Z){case Es:case $s:var Nt=m.def(ne,"._texture");m(N,".uniform1i(",Pe,",",Nt,".bind());"),m.exit(Nt,".unbind();");continue;case Mi:case Ri:A="1i";break;case So:case Oo:A="2i",it=2;break;case Po:case Mo:A="3i",it=3;break;case Co:case Ro:A="4i",it=4;break;case Oi:A="1f";break;case $o:A="2f",it=2;break;case Ao:A="3f",it=3;break;case To:A="4f",it=4;break;case ws:A="Matrix2fv";break;case _s:A="Matrix3fv";break;case xs:A="Matrix4fv";break}if(A.indexOf("Matrix")===-1&&re>1&&(A+="v",it=1),A.charAt(0)==="M"){m(N,".uniform",A,"(",Pe,",");var fn=Math.pow(Z-ws+2,2),Ar=w.global.def("new Float32Array(",fn,")");Array.isArray(ne)?m("false,(",Kt(fn,function(er){return Ar+"["+er+"]="+ne[er]}),",",Ar,")"):m("false,(Array.isArray(",ne,")||",ne," instanceof Float32Array)?",ne,":(",Kt(fn,function(er){return Ar+"["+er+"]="+ne+"["+er+"]"}),",",Ar,")"),m(");")}else if(it>1){for(var vr=[],kr=[],un=0;un<it;++un)Array.isArray(ne)?kr.push(ne[un]):kr.push(m.def(ne+"["+un+"]")),O&&vr.push(m.def());O&&m("if(!",w.batchId,"||",vr.map(function(er,dn){return er+"!=="+kr[dn]}).join("||"),"){",vr.map(function(er,dn){return er+"="+kr[dn]+";"}).join("")),m(N,".uniform",A,"(",Pe,",",kr.join(","),");"),O&&m("}")}else{if(y(!Array.isArray(ne),"uniform value must not be an array"),O){var F1=m.def();m("if(!",w.batchId,"||",F1,"!==",ne,"){",F1,"=",ne,";")}m(N,".uniform",A,"(",Pe,",",ne,");"),O&&m("}")}}}function De(w,m,P,D){var B=w.shared,O=B.gl,C=B.draw,N=D.draw;function _(){var Le=N.elements,Me,Be=m;return Le?((Le.contextDep&&D.contextDynamic||Le.propDep)&&(Be=P),Me=Le.append(w,Be),N.elementsActive&&Be("if("+Me+")"+O+".bindBuffer("+Ci+","+Me+".buffer.buffer);")):(Me=Be.def(),Be(Me,"=",C,".",sn,";","if(",Me,"){",O,".bindBuffer(",Ci,",",Me,".buffer.buffer);}","else if(",B.vao,".currentVAO){",Me,"=",w.shared.elements+".getElements("+B.vao,".currentVAO.elements);",se?"":"if("+Me+")"+O+".bindBuffer("+Ci+","+Me+".buffer.buffer);","}")),Me}function A(){var Le=N.count,Me,Be=m;return Le?((Le.contextDep&&D.contextDynamic||Le.propDep)&&(Be=P),Me=Le.append(w,Be),y.optional(function(){Le.MISSING&&w.assert(m,"false","missing vertex count"),Le.DYNAMIC&&w.assert(Be,Me+">=0","missing vertex count")})):(Me=Be.def(C,".",an),y.optional(function(){w.assert(Be,Me+">=0","missing vertex count")})),Me}var x=_();function V(Le){var Me=N[Le];return Me?Me.contextDep&&D.contextDynamic||Me.propDep?Me.append(w,P):Me.append(w,m):m.def(C,".",Le)}var I=V(on),Z=V(xo),re=A();if(typeof re=="number"){if(re===0)return}else P("if(",re,"){"),P.exit("}");var ve,Ve;fe&&(ve=V(Eo),Ve=w.instancing);var Fe=x+".type",Pe=N.elements&&Dr(N.elements)&&!N.vaoActive;function ne(){function Le(){P(Ve,".drawElementsInstancedANGLE(",[I,re,Fe,Z+"<<(("+Fe+"-"+Kf+")>>1)",ve],");")}function Me(){P(Ve,".drawArraysInstancedANGLE(",[I,Z,re,ve],");")}x&&x!=="null"?Pe?Le():(P("if(",x,"){"),Le(),P("}else{"),Me(),P("}")):Me()}function W(){function Le(){P(O+".drawElements("+[I,re,Fe,Z+"<<(("+Fe+"-"+Kf+")>>1)"]+");")}function Me(){P(O+".drawArrays("+[I,Z,re]+");")}x&&x!=="null"?Pe?Le():(P("if(",x,"){"),Le(),P("}else{"),Me(),P("}")):Me()}fe&&(typeof ve!="number"||ve>=0)?typeof ve=="string"?(P("if(",ve,">0){"),ne(),P("}else if(",ve,"<0){"),W(),P("}")):ne():W()}function et(w,m,P,D,B){var O=Ue(),C=O.proc("body",B);return y.optional(function(){O.commandStr=m.commandStr,O.command=O.link(m.commandStr)}),fe&&(O.instancing=C.def(O.shared.extensions,".angle_instanced_arrays")),w(O,C,P,D),O.compile().body}function nt(w,m,P,D){vt(w,m),P.useVAO?P.drawVAO?m(w.shared.vao,".setVAO(",P.drawVAO.append(w,m),");"):m(w.shared.vao,".setVAO(",w.shared.vao,".targetVAO);"):(m(w.shared.vao,".setVAO(null);"),Gt(w,m,P,D.attributes,function(){return!0})),at(w,m,P,D.uniforms,function(){return!0},!1),De(w,m,m,P)}function gt(w,m){var P=w.proc("draw",1);vt(w,P),Et(w,P,m.context),$t(w,P,m.framebuffer),Ot(w,P,m),Ft(w,P,m.state),Ye(w,P,m,!1,!0);var D=m.shader.progVar.append(w,P);if(P(w.shared.gl,".useProgram(",D,".program);"),m.shader.program)nt(w,P,m,m.shader.program);else{P(w.shared.vao,".setVAO(null);");var B=w.global.def("{}"),O=P.def(D,".id"),C=P.def(B,"[",O,"]");P(w.cond(C).then(C,".call(this,a0);").else(C,"=",B,"[",O,"]=",w.link(function(N){return et(nt,w,m,N,1)}),"(",D,");",C,".call(this,a0);"))}Object.keys(m.state).length>0&&P(w.shared.current,".dirty=true;"),w.shared.vao&&P(w.shared.vao,".setVAO(null);")}function pr(w,m,P,D){w.batchId="a1",vt(w,m);function B(){return!0}Gt(w,m,P,D.attributes,B),at(w,m,P,D.uniforms,B,!1),De(w,m,m,P)}function ln(w,m,P,D){vt(w,m);var B=P.contextDep,O=m.def(),C="a0",N="a1",_=m.def();w.shared.props=_,w.batchId=O;var A=w.scope(),x=w.scope();m(A.entry,"for(",O,"=0;",O,"<",N,";++",O,"){",_,"=",C,"[",O,"];",x,"}",A.exit);function V(Fe){return Fe.contextDep&&B||Fe.propDep}function I(Fe){return!V(Fe)}if(P.needsContext&&Et(w,x,P.context),P.needsFramebuffer&&$t(w,x,P.framebuffer),Ft(w,x,P.state,V),P.profile&&V(P.profile)&&Ye(w,x,P,!1,!0),D)P.useVAO?P.drawVAO?V(P.drawVAO)?x(w.shared.vao,".setVAO(",P.drawVAO.append(w,x),");"):A(w.shared.vao,".setVAO(",P.drawVAO.append(w,A),");"):A(w.shared.vao,".setVAO(",w.shared.vao,".targetVAO);"):(A(w.shared.vao,".setVAO(null);"),Gt(w,A,P,D.attributes,I),Gt(w,x,P,D.attributes,V)),at(w,A,P,D.uniforms,I,!1),at(w,x,P,D.uniforms,V,!0),De(w,A,x,P);else{var Z=w.global.def("{}"),re=P.shader.progVar.append(w,x),ve=x.def(re,".id"),Ve=x.def(Z,"[",ve,"]");x(w.shared.gl,".useProgram(",re,".program);","if(!",Ve,"){",Ve,"=",Z,"[",ve,"]=",w.link(function(Fe){return et(pr,w,P,Fe,2)}),"(",re,");}",Ve,".call(this,a0[",O,"],",O,");")}}function $(w,m){var P=w.proc("batch",2);w.batchId="0",vt(w,P);var D=!1,B=!0;Object.keys(m.context).forEach(function(Z){D=D||m.context[Z].propDep}),D||(Et(w,P,m.context),B=!1);var O=m.framebuffer,C=!1;O?(O.propDep?D=C=!0:O.contextDep&&D&&(C=!0),C||$t(w,P,O)):$t(w,P,null),m.state.viewport&&m.state.viewport.propDep&&(D=!0);function N(Z){return Z.contextDep&&D||Z.propDep}Ot(w,P,m),Ft(w,P,m.state,function(Z){return!N(Z)}),(!m.profile||!N(m.profile))&&Ye(w,P,m,!1,"a1"),m.contextDep=D,m.needsContext=B,m.needsFramebuffer=C;var _=m.shader.progVar;if(_.contextDep&&D||_.propDep)ln(w,P,m,null);else{var A=_.append(w,P);if(P(w.shared.gl,".useProgram(",A,".program);"),m.shader.program)ln(w,P,m,m.shader.program);else{P(w.shared.vao,".setVAO(null);");var x=w.global.def("{}"),V=P.def(A,".id"),I=P.def(x,"[",V,"]");P(w.cond(I).then(I,".call(this,a0,a1);").else(I,"=",x,"[",V,"]=",w.link(function(Z){return et(ln,w,m,Z,2)}),"(",A,");",I,".call(this,a0,a1);"))}}Object.keys(m.state).length>0&&P(w.shared.current,".dirty=true;"),w.shared.vao&&P(w.shared.vao,".setVAO(null);")}function j(w,m){var P=w.proc("scope",3);w.batchId="a2";var D=w.shared,B=D.current;Et(w,P,m.context),m.framebuffer&&m.framebuffer.append(w,P),S1(Object.keys(m.state)).forEach(function(C){var N=m.state[C],_=N.append(w,P);dt(_)?_.forEach(function(A,x){P.set(w.next[C],"["+x+"]",A)}):P.set(D.next,"."+C,_)}),Ye(w,P,m,!0,!0),[sn,xo,an,Eo,on].forEach(function(C){var N=m.draw[C];N&&P.set(D.draw,"."+C,""+N.append(w,P))}),Object.keys(m.uniforms).forEach(function(C){var N=m.uniforms[C].append(w,P);Array.isArray(N)&&(N="["+N.join()+"]"),P.set(D.uniforms,"["+v.id(C)+"]",N)}),Object.keys(m.attributes).forEach(function(C){var N=m.attributes[C].append(w,P),_=w.scopeAttrib(C);Object.keys(new k).forEach(function(A){P.set(_,"."+A,N[A])})}),m.scopeVAO&&P.set(D.vao,".targetVAO",m.scopeVAO.append(w,P));function O(C){var N=m.shader[C];N&&P.set(D.shader,"."+C,N.append(w,P))}O(gs),O(ys),Object.keys(m.state).length>0&&(P(B,".dirty=true;"),P.exit(B,".dirty=true;")),P("a1(",w.shared.context,",a0,",w.batchId,");")}function z(w){if(!(typeof w!="object"||dt(w))){for(var m=Object.keys(w),P=0;P<m.length;++P)if(Qt.isDynamic(w[m[P]]))return!0;return!1}}function Ce(w,m,P){var D=m.static[P];if(!D||!z(D))return;var B=w.global,O=Object.keys(D),C=!1,N=!1,_=!1,A=w.global.def("{}");O.forEach(function(V){var I=D[V];if(Qt.isDynamic(I)){typeof I=="function"&&(I=D[V]=Qt.unbox(I));var Z=Xt(I,null);C=C||Z.thisDep,_=_||Z.propDep,N=N||Z.contextDep}else{switch(B(A,".",V,"="),typeof I){case"number":B(I);break;case"string":B('"',I,'"');break;case"object":Array.isArray(I)&&B("[",I.join(),"]");break;default:B(w.link(I));break}B(";")}});function x(V,I){O.forEach(function(Z){var re=D[Z];if(Qt.isDynamic(re)){var ve=V.invoke(I,re);I(A,".",Z,"=",ve,";")}})}m.dynamic[P]=new Qt.DynamicVariable(wo,{thisDep:C,contextDep:N,propDep:_,ref:A,append:x}),delete m.static[P]}function Ze(w,m,P,D,B){var O=Ue();O.stats=O.link(B),Object.keys(m.static).forEach(function(N){Ce(O,m,N)}),W2.forEach(function(N){Ce(O,w,N)});var C=_t(w,m,P,D,O);return gt(O,C),j(O,C),$(O,C),n(O.compile(),{destroy:function(){C.shader.program.destroy()}})}return{next:_e,current:Ee,procs:function(){var w=Ue(),m=w.proc("poll"),P=w.proc("refresh"),D=w.block();m(D),P(D);var B=w.shared,O=B.gl,C=B.next,N=B.current;D(N,".dirty=false;"),$t(w,m),$t(w,P,null,!0);var _;fe&&(_=w.link(fe)),T.oes_vertex_array_object&&P(w.link(T.oes_vertex_array_object),".bindVertexArrayOES(null);");for(var A=0;A<X.maxAttributes;++A){var x=P.def(B.attributes,"[",A,"]"),V=w.cond(x,".buffer");V.then(O,".enableVertexAttribArray(",A,");",O,".bindBuffer(",kn,",",x,".buffer.buffer);",O,".vertexAttribPointer(",A,",",x,".size,",x,".type,",x,".normalized,",x,".stride,",x,".offset);").else(O,".disableVertexAttribArray(",A,");",O,".vertexAttrib4f(",A,",",x,".x,",x,".y,",x,".z,",x,".w);",x,".buffer=null;"),P(V),fe&&P(_,".vertexAttribDivisorANGLE(",A,",",x,".divisor);")}return P(w.shared.vao,".currentVAO=null;",w.shared.vao,".setVAO(",w.shared.vao,".targetVAO);"),Object.keys(te).forEach(function(I){var Z=te[I],re=D.def(C,".",I),ve=w.block();ve("if(",re,"){",O,".enable(",Z,")}else{",O,".disable(",Z,")}",N,".",I,"=",re,";"),P(ve),m("if(",re,"!==",N,".",I,"){",ve,"}")}),Object.keys(K).forEach(function(I){var Z=K[I],re=Ee[I],ve,Ve,Fe=w.block();if(Fe(O,".",Z,"("),dt(re)){var Pe=re.length;ve=w.global.def(C,".",I),Ve=w.global.def(N,".",I),Fe(Kt(Pe,function(ne){return ve+"["+ne+"]"}),");",Kt(Pe,function(ne){return Ve+"["+ne+"]="+ve+"["+ne+"];"}).join("")),m("if(",Kt(Pe,function(ne){return ve+"["+ne+"]!=="+Ve+"["+ne+"]"}).join("||"),"){",Fe,"}")}else ve=D.def(C,".",I),Ve=D.def(N,".",I),Fe(ve,");",N,".",I,"=",ve,";"),m("if(",ve,"!==",Ve,"){",Fe,"}");P(Fe)}),w.compile()}(),compile:Ze}}function mg(){return{vaoCount:0,bufferCount:0,elementsCount:0,framebufferCount:0,shaderCount:0,textureCount:0,cubeCount:0,renderbufferCount:0,maxTextureUnits:0}}var pg=34918,vg=34919,C1=35007,gg=function(f,v){if(!v.ext_disjoint_timer_query)return null;var T=[];function X(){return T.pop()||v.ext_disjoint_timer_query.createQueryEXT()}function J(fe){T.push(fe)}var q=[];function Y(fe){var Te=X();v.ext_disjoint_timer_query.beginQueryEXT(C1,Te),q.push(Te),ce(q.length-1,q.length,fe)}function ie(){v.ext_disjoint_timer_query.endQueryEXT(C1)}function ae(){this.startQueryIndex=-1,this.endQueryIndex=-1,this.sum=0,this.stats=null}var de=[];function me(){return de.pop()||new ae}function he(fe){de.push(fe)}var ge=[];function ce(fe,Te,se){var Ee=me();Ee.startQueryIndex=fe,Ee.endQueryIndex=Te,Ee.sum=0,Ee.stats=se,ge.push(Ee)}var ue=[],k=[];function H(){var fe,Te,se=q.length;if(se!==0){k.length=Math.max(k.length,se+1),ue.length=Math.max(ue.length,se+1),ue[0]=0,k[0]=0;var Ee=0;for(fe=0,Te=0;Te<q.length;++Te){var _e=q[Te];v.ext_disjoint_timer_query.getQueryObjectEXT(_e,vg)?(Ee+=v.ext_disjoint_timer_query.getQueryObjectEXT(_e,pg),J(_e)):q[fe++]=_e,ue[Te+1]=Ee,k[Te+1]=fe}for(q.length=fe,fe=0,Te=0;Te<ge.length;++Te){var Ge=ge[Te],te=Ge.startQueryIndex,K=Ge.endQueryIndex;Ge.sum+=ue[K]-ue[te];var Oe=k[te],ye=k[K];ye===Oe?(Ge.stats.gpuTime+=Ge.sum/1e6,he(Ge)):(Ge.startQueryIndex=Oe,Ge.endQueryIndex=ye,ge[fe++]=Ge)}ge.length=fe}}return{beginQuery:Y,endQuery:ie,pushScopeStats:ce,update:H,getNumPendingQueries:function(){return q.length},clear:function(){T.push.apply(T,q);for(var fe=0;fe<T.length;fe++)v.ext_disjoint_timer_query.deleteQueryEXT(T[fe]);q.length=0,T.length=0},restore:function(){q.length=0,T.length=0}}},yg=16384,bg=256,wg=1024,_g=34962,O1="webglcontextlost",M1="webglcontextrestored",R1=1,xg=2,Eg=3;function L1(f,v){for(var T=0;T<f.length;++T)if(f[T]===v)return T;return-1}function $g(f){var v=xp(f);if(!v)return null;var T=v.gl,X=T.getContextAttributes(),J=T.isContextLost(),q=Ep(T,v);if(!q)return null;var Y=gp(),ie=mg(),ae=q.extensions,de=gg(T,ae),me=Il(),he=T.drawingBufferWidth,ge=T.drawingBufferHeight,ce={tick:0,time:0,viewportWidth:he,viewportHeight:ge,framebufferWidth:he,framebufferHeight:ge,drawingBufferWidth:he,drawingBufferHeight:ge,pixelRatio:v.pixelRatio},ue={},k={elements:null,primitive:4,count:-1,offset:0,instances:-1},H=fv(T,ae),fe=Tv(T,ie,v,Ee),Te=kv(T,ae,fe,ie),se=k2(T,ae,H,ie,fe,Te,k);function Ee(De){return se.destroyBuffer(De)}var _e=z2(T,Y,ie,v),Ge=p2(T,ae,H,function(){Oe.procs.poll()},ce,ie,v),te=v2(T,ae,H,ie,v),K=N2(T,ae,H,Ge,te,ie),Oe=hg(T,Y,ae,H,fe,Te,Ge,K,ue,se,_e,k,ce,de,v),ye=X2(T,K,Oe.procs.poll,ce,X,ae,H),le=Oe.next,be=T.canvas,we=[],je=[],Ue=[],xe=[v.onDestroy],Ae=null;function ke(){if(we.length===0){de&&de.update(),Ae=null;return}Ae=Ba.next(ke),Ft();for(var De=we.length-1;De>=0;--De){var et=we[De];et&&et(ce,null,0)}T.flush(),de&&de.update()}function He(){!Ae&&we.length>0&&(Ae=Ba.next(ke))}function Je(){Ae&&(Ba.cancel(ke),Ae=null)}function ht(De){De.preventDefault(),J=!0,Je(),je.forEach(function(et){et()})}function mt(De){T.getError(),J=!1,q.restore(),_e.restore(),fe.restore(),Ge.restore(),te.restore(),K.restore(),se.restore(),de&&de.restore(),Oe.procs.refresh(),He(),Ue.forEach(function(et){et()})}be&&(be.addEventListener(O1,ht,!1),be.addEventListener(M1,mt,!1));function tt(){we.length=0,Je(),be&&(be.removeEventListener(O1,ht),be.removeEventListener(M1,mt)),_e.clear(),K.clear(),te.clear(),se.clear(),Ge.clear(),Te.clear(),fe.clear(),de&&de.clear(),xe.forEach(function(De){De()})}function xt(De){y(!!De,"invalid args to regl({...})"),y.type(De,"object","invalid args to regl({...})");function et(B){var O=n({},B);delete O.uniforms,delete O.attributes,delete O.context,delete O.vao,"stencil"in O&&O.stencil.op&&(O.stencil.opBack=O.stencil.opFront=O.stencil.op,delete O.stencil.op);function C(N){if(N in O){var _=O[N];delete O[N],Object.keys(_).forEach(function(A){O[N+"."+A]=_[A]})}}return C("blend"),C("depth"),C("cull"),C("stencil"),C("polygonOffset"),C("scissor"),C("sample"),"vao"in B&&(O.vao=B.vao),O}function nt(B,O){var C={},N={};return Object.keys(B).forEach(function(_){var A=B[_];if(Qt.isDynamic(A)){N[_]=Qt.unbox(A,_);return}else if(O&&Array.isArray(A)){for(var x=0;x<A.length;++x)if(Qt.isDynamic(A[x])){N[_]=Qt.unbox(A,_);return}}C[_]=A}),{dynamic:N,static:C}}var gt=nt(De.context||{},!0),pr=nt(De.uniforms||{},!0),ln=nt(De.attributes||{},!1),$=nt(et(De),!1),j={gpuTime:0,cpuTime:0,count:0},z=Oe.compile($,ln,pr,gt,j),Ce=z.draw,Ze=z.batch,w=z.scope,m=[];function P(B){for(;m.length<B;)m.push(null);return m}function D(B,O){var C;if(J&&y.raise("context lost"),typeof B=="function")return w.call(this,null,B,0);if(typeof O=="function")if(typeof B=="number")for(C=0;C<B;++C)w.call(this,null,O,C);else if(Array.isArray(B))for(C=0;C<B.length;++C)w.call(this,B[C],O,C);else return w.call(this,B,O,0);else if(typeof B=="number"){if(B>0)return Ze.call(this,P(B|0),B|0)}else if(Array.isArray(B)){if(B.length)return Ze.call(this,B,B.length)}else return Ce.call(this,B)}return n(D,{stats:j,destroy:function(){z.destroy()}})}var lt=K.setFBO=xt({framebuffer:Qt.define.call(null,R1,"framebuffer")});function _t(De,et){var nt=0;Oe.procs.poll();var gt=et.color;gt&&(T.clearColor(+gt[0]||0,+gt[1]||0,+gt[2]||0,+gt[3]||0),nt|=yg),"depth"in et&&(T.clearDepth(+et.depth),nt|=bg),"stencil"in et&&(T.clearStencil(et.stencil|0),nt|=wg),y(!!nt,"called regl.clear with no buffer specified"),T.clear(nt)}function Et(De){if(y(typeof De=="object"&&De,"regl.clear() takes an object as input"),"framebuffer"in De)if(De.framebuffer&&De.framebuffer_reglType==="framebufferCube")for(var et=0;et<6;++et)lt(n({framebuffer:De.framebuffer.faces[et]},De),_t);else lt(De,_t);else _t(null,De)}function $t(De){y.type(De,"function","regl.frame() callback must be a function"),we.push(De);function et(){var nt=L1(we,De);y(nt>=0,"cannot cancel a frame twice");function gt(){var pr=L1(we,gt);we[pr]=we[we.length-1],we.length-=1,we.length<=0&&Je()}we[nt]=gt}return He(),{cancel:et}}function Ot(){var De=le.viewport,et=le.scissor_box;De[0]=De[1]=et[0]=et[1]=0,ce.viewportWidth=ce.framebufferWidth=ce.drawingBufferWidth=De[2]=et[2]=T.drawingBufferWidth,ce.viewportHeight=ce.framebufferHeight=ce.drawingBufferHeight=De[3]=et[3]=T.drawingBufferHeight}function Ft(){ce.tick+=1,ce.time=Ye(),Ot(),Oe.procs.poll()}function vt(){Ge.refresh(),Ot(),Oe.procs.refresh(),de&&de.update()}function Ye(){return(Il()-me)/1e3}vt();function Gt(De,et){y.type(et,"function","listener callback must be a function");var nt;switch(De){case"frame":return $t(et);case"lost":nt=je;break;case"restore":nt=Ue;break;case"destroy":nt=xe;break;default:y.raise("invalid event, must be one of frame,lost,restore,destroy")}return nt.push(et),{cancel:function(){for(var gt=0;gt<nt.length;++gt)if(nt[gt]===et){nt[gt]=nt[nt.length-1],nt.pop();return}}}}var at=n(xt,{clear:Et,prop:Qt.define.bind(null,R1),context:Qt.define.bind(null,xg),this:Qt.define.bind(null,Eg),draw:xt({}),buffer:function(De){return fe.create(De,_g,!1,!1)},elements:function(De){return Te.create(De,!1)},texture:Ge.create2D,cube:Ge.createCube,renderbuffer:te.create,framebuffer:K.create,framebufferCube:K.createCube,vao:se.createVAO,attributes:X,frame:$t,on:Gt,limits:H,hasExtension:function(De){return H.extensions.indexOf(De.toLowerCase())>=0},read:ye,destroy:tt,_gl:T,_refresh:vt,poll:function(){Ft(),de&&de.update()},now:Ye,stats:ie});return v.onDone(null,at),at}return $g})}(Pc)),Pc.exports}const EN=_N,$N=ka,AN=e=>{const r=Object.assign({},{},e.glOptions,{onDone:(a,i)=>{if(a)throw a}}),n=xN()(r),s=new Map,o=a=>{a.rendering=Object.assign({},$N,a.rendering),EN(n)(a,i=>{n.clear({color:a.rendering.background,depth:1}),a.entities&&a.entities.sort((c,l)=>{const u="transparent"in c.visuals?c.visuals.transparent:!1,d="transparent"in l.visuals?l.visuals.transparent:!1;return u===d?0:u?1:-1}).forEach(c=>{const{visuals:l}=c;if(("show"in l?l.show:!0)&&l.drawCmd&&a.drawCommands[l.drawCmd]){let d;l.cacheId?d=s.get(l.cacheId):(l.cacheId=s.size,d=a.drawCommands[l.drawCmd](n,c),s.set(l.cacheId,d));const h={...c,...l,camera:a.camera};d(h)}})})};return function(i){n.poll(),o(i)}};var TN=AN,Cc,bd;function wd(){if(bd)return Cc;bd=1;const e=ir;return Cc=(r,n={})=>{const s=[],o={visuals:{color:[0,0,1,1],fadeOut:!1},ticks:1,size:[16,16],centered:!1,lineWidth:2},a=Object.assign({},o.visuals,n.visuals||{}),{fadeOut:i,color:c}=a,{size:l,ticks:u,centered:d,lineWidth:h}=Object.assign({},o,n),p=l[0],E=l[1];if(d){const g=p*.5,b=E*.5,S=g%u,G=-g+S,R=-G,M=b%u,F=-b+M,L=-F,U=0;for(let ee=G,oe=0;ee<=R;ee+=u,oe+=1)oe%U!==0&&(s.push(F,ee,0),s.push(L,ee,0),s.push(F,ee,0));for(let ee=F,oe=0;ee<=L;ee+=u,oe+=1)oe%U!==0&&(s.push(ee,G,0),s.push(ee,R,0),s.push(ee,G,0))}else{for(let g=-p*.5;g<=p*.5;g+=u)s.push(-E*.5,g,0),s.push(E*.5,g,0),s.push(-E*.5,g,0);for(let g=-E*.5;g<=E*.5;g+=u)s.push(g,-p*.5,0),s.push(g,p*.5,0),s.push(g,-p*.5,0)}return r({vert:`precision mediump float;

    uniform float camNear, camFar;
    uniform mat4 model, view, projection;

    attribute vec3 position;
    varying vec3 fragNormal, fragPosition;
    varying vec4 worldPosition;

    void main() {
      fragPosition = position;
      worldPosition = model * vec4(position, 1);
      vec4 glPosition = projection * view * worldPosition;
      gl_Position = glPosition;
    }`,frag:`precision mediump float;
    uniform vec4 color;
    varying vec3 fragNormal, fragPosition;
    varying vec4 worldPosition;

    uniform vec4 fogColor;
    uniform bool fadeOut;
    void main() {
      float dist = .5;
      if(fadeOut){
        dist = distance( vec2(0.,0.), vec2(worldPosition.x, worldPosition.y));
        dist *= 0.0025;
        dist = sqrt(dist);
      }

      gl_FragColor = mix(color, fogColor, dist);
    }
    `,attributes:{position:r.buffer(s)},count:s.length/3,uniforms:{model:(g,b)=>b&&b.model?b.model:e.identity([]),color:(g,b)=>b&&b.color?b.color:c,fogColor:(g,b)=>b&&b.color?[b.color[0],b.color[1],b.color[2],0]:[c[0],c[1],c[2],0],fadeOut:(g,b)=>b&&b.fadeOut!==void 0?b.fadeOut:i},lineWidth:(g,b)=>Math.min(b&&b.lineWidth?b.lineWidth:h,r.limits.lineWidthDims[1]),primitive:"lines",cull:{enable:!0,face:"front"},polygonOffset:{enable:!0,offset:{factor:1,units:Math.random()*10}},blend:{enable:!0,func:{src:"src alpha",dst:"one minus src alpha"}}})},Cc}const SN=(e,t)=>{const r={size:[50,50],ticks:[10,1]},{size:n,ticks:s}=Object.assign({},r,t),o=wd()(e,{size:n,ticks:s[0]}),a=wd()(e,{size:n,ticks:s[1]});return c=>{o(c),a({color:c.subColor,fadeOut:c.fadeOut})}};var PN=SN;const zt=ir,CN=(e,t)=>{const r={xColor:[1,0,0,1],yColor:[0,1,0,1],zColor:[0,0,1,1],size:10,lineWidth:3,alwaysVisible:!0};let{size:n,xColor:s,yColor:o,zColor:a,lineWidth:i,alwaysVisible:c}=Object.assign({},r,t);i>e.limits.lineWidthDims[1]&&(i=e.limits.lineWidthDims[1]);const l=[0,0,0,n,0,0],u={frag:`precision mediump float;
    uniform vec4 color;
    void main() {
      gl_FragColor = color;
    }`,vert:`
    precision mediump float;
    attribute vec3 position;
    uniform mat4 model, view, projection;
    void main() {
      gl_Position = projection * view * model * vec4(position, 1);
    }`,uniforms:{model:(g,b)=>b&&b.model?b.model:zt.identity([]),color:(g,b)=>b.color,angle:(g,b)=>b.angle},attributes:{position:l},count:l.length/3,primitive:"line loop",lineWidth:i,depth:{enable:!c}},d=zt.identity([]),h=zt.rotateZ(zt.create(),zt.identity([]),Math.PI/2),p=zt.rotateY(zt.create(),zt.identity([]),-Math.PI/2),E=e(u);return g=>{const b={model:zt.identity([])};return g=Object.assign({},b,g),E([{color:s,model:zt.multiply(zt.create(),g.model,d)},{color:o,model:zt.multiply(zt.create(),g.model,h)},{color:a,model:zt.multiply(zt.create(),g.model,p)}])}};var ON=CN,Oc,_d;function xd(){return _d||(_d=1,Oc={vert:`
precision mediump float;

uniform float camNear, camFar;
uniform mat4 model, view, projection;

attribute vec3 position, normal;

varying vec3 surfaceNormal, surfacePosition;
varying vec4 _worldSpacePosition;

void main() {
  surfacePosition = position;
  surfaceNormal = normal;
  vec4 worldSpacePosition = model * vec4(position, 1);
  _worldSpacePosition = worldSpacePosition;

  vec4 glPosition = projection * view * model * vec4(position, 1);
  gl_Position = glPosition;
}
`,frag:`
precision mediump float;
varying vec3 surfaceNormal;
uniform float ambientLightAmount;
uniform float diffuseLightAmount;
uniform vec4 ucolor;
uniform vec3 lightDirection;
uniform vec3 opacity;

varying vec4 _worldSpacePosition;

uniform vec2 printableArea;

vec4 errorColor = vec4(0.15, 0.15, 0.15, 0.3);

void main () {
  vec4 depth = gl_FragCoord;

  float v = 0.8; // shadow value
  vec4 endColor = ucolor;

  vec3 ambient = ambientLightAmount * endColor.rgb;
  float cosTheta = dot(surfaceNormal, lightDirection);
  vec3 diffuse = diffuseLightAmount * endColor.rgb * clamp(cosTheta , 0.0, 1.0 );

  float cosTheta2 = dot(surfaceNormal, vec3(-lightDirection.x, -lightDirection.y, lightDirection.z));
  vec3 diffuse2 = diffuseLightAmount * endColor.rgb * clamp(cosTheta2 , 0.0, 1.0 );

  gl_FragColor = vec4((ambient + diffuse + diffuse2 * v), endColor.a);
}`}),Oc}var Mc,Ed;function $d(){return Ed||(Ed=1,Mc={frag:`
precision mediump float;
varying vec3 surfaceNormal, surfacePosition;

uniform float ambientLightAmount;
uniform float diffuseLightAmount;
uniform float specularLightAmount;

uniform vec3 lightDirection;
uniform vec4 lightColor;
uniform vec3 opacity;
uniform float uMaterialShininess;

varying vec4 vColor;
uniform vec4 ucolor;
uniform float vColorToggler;

uniform vec2 printableArea;
vec4 errorColor = vec4(0.15, 0.15, 0.15, 0.3);//vec4(0.15, 0.15, 0.15, 0.3);
varying vec4 _worldSpacePosition;
varying float ambientAo;

void main () {
  vec4 depth = gl_FragCoord;
  vec4 endColor = vColor * vColorToggler + ucolor * (1.0 - vColorToggler);

  vec3 ambient = ambientLightAmount * endColor.rgb ; //ambientAo * 

  float diffuseWeight = dot(surfaceNormal, lightDirection);
  vec3 diffuse = diffuseLightAmount * endColor.rgb * clamp(diffuseWeight , 0.0, 1.0 );

  //specular
  
  vec4 specularColor = vec4(lightColor);
  vec3 eyeDirection = normalize(surfacePosition.xyz);
  vec3 reflectionDirection = reflect(-lightDirection, -surfaceNormal);
  float specularLightWeight = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
  vec3 specular = specularColor.rgb * specularLightWeight * specularLightAmount;

  gl_FragColor = vec4((ambient + diffuse + specular), endColor.a);
}
`,vert:`
precision mediump float;

uniform float camNear, camFar;
uniform mat4 model, view, projection, unormal;

attribute vec3 position, normal;
attribute vec4 color;

attribute float ao;
varying float ambientAo;

varying vec3 surfaceNormal, surfacePosition;
varying vec4 _worldSpacePosition;
varying vec4 vColor;

void main() {
  surfacePosition = (unormal * vec4(position, 1.0)).xyz;
  surfaceNormal = normalize((unormal * vec4(normal, 1.0)).xyz); //vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0);
  vec4 worldSpacePosition = model * vec4(position, 1);
  _worldSpacePosition = worldSpacePosition;
  //gl_Position = projection * view * worldSpacePosition;

  vColor = color;

  //ambientAo = (1. - ao) * (0.5 * max(normal.x, 0.) + 0.5);

  vec4 glPosition = projection * view * model * vec4(position, 1);
  gl_Position = glPosition;
  //gl_Position = zBufferAdjust(glPosition, camNear, camFar);
}
`}),Mc}const Xr=ir,{meshColor:MN}=ka,RN=(e,t={extras:{}})=>{const r={useVertexColors:!0,dynamicCulling:!0,geometry:void 0,color:MN,visuals:{}},{geometry:n,dynamicCulling:s,useVertexColors:o,color:a,visuals:i}=Object.assign({},r,t),c=e.buffer([]),l=!!(n.indices&&n.indices.length>0),u=!!(n.normals&&n.normals.length>0),d="transparent"in i?i.transparent:!1,h=!!(o&&n.colors&&n.colors.length>0),p=n.transforms||Xr.create(),E=Xr.determinant(p)<0,g=s&&E?"front":"back",b=h?$d().vert:xd().vert,S=h?$d().frag:xd().frag,G=Xr.invert(Xr.create(),p);let R={primitive:"triangles",vert:b,frag:S,uniforms:{model:(M,F)=>p,ucolor:(M,F)=>F&&F.color?F.color:a,vColorToggler:(M,F)=>F&&F.useVertexColors&&F.useVertexColors===!0?1:0,unormal:(M,F)=>{const L=Xr.invert(Xr.create(),F.camera.view);return Xr.multiply(L,G,L),Xr.transpose(L,L),L}},attributes:{position:e.buffer({usage:"static",type:"float",data:n.positions}),ao:c},cull:{enable:!0,face:g}};return d&&(R.blend={enable:!0,func:{src:"src alpha",dst:"one minus src alpha"}}),n.cells?R.elements=n.cells:l?R.elements=e.elements({usage:"static",type:"uint16",data:n.indices}):n.triangles?R.elements=n.triangles:R.count=n.positions.length/3,u&&(R.attributes.normal=e.buffer({usage:"static",type:"float",data:n.normals})),h&&(R.attributes.color=e.buffer({usage:"static",type:"float",data:n.colors})),R=Object.assign({},R,t.extras),e(R)};var LN=RN,Rc,Ad;function FN(){return Ad||(Ad=1,Rc={vert:`
precision mediump float;

uniform float camNear, camFar;
uniform mat4 model, view, projection;

attribute vec3 position, normal;


varying vec3 surfaceNormal, surfacePosition;
varying vec4 _worldSpacePosition;


void main() {


  surfacePosition = position;
  surfaceNormal = normal;
  vec4 worldSpacePosition = model * vec4(position, 1);
  _worldSpacePosition = worldSpacePosition;

  vec4 glPosition = projection * view * model * vec4(position, 1);
  gl_Position = glPosition;
}
`,frag:`
precision mediump float;
varying vec3 surfaceNormal;
uniform float ambientLightAmount;
uniform float diffuseLightAmount;
uniform vec4 ucolor;
uniform vec3 lightDirection;
uniform vec3 opacity;

varying vec4 _worldSpacePosition;

uniform vec2 printableArea;

vec4 errorColor = vec4(0.15, 0.15, 0.15, 0.3);

void main () {
  vec4 depth = gl_FragCoord;

  float v = 0.8; // shadow value
  vec4 endColor = ucolor;

  vec3 ambient = ambientLightAmount * endColor.rgb;
  float cosTheta = dot(surfaceNormal, lightDirection);
  vec3 diffuse = diffuseLightAmount * endColor.rgb * clamp(cosTheta , 0.0, 1.0 );

  float cosTheta2 = dot(surfaceNormal, vec3(-lightDirection.x, -lightDirection.y, lightDirection.z));
  vec3 diffuse2 = diffuseLightAmount * endColor.rgb * clamp(cosTheta2 , 0.0, 1.0 );

  gl_FragColor = vec4((ambient + diffuse + diffuse2 * v), endColor.a);
}`}),Rc}var Lc,Td;function Sd(){return Td||(Td=1,Lc={frag:`
precision mediump float;
varying vec4 vColor;

void main () {
  gl_FragColor = vColor;
}
`,vert:`
precision mediump float;

uniform float camNear, camFar;
uniform mat4 model, view, projection;

attribute vec3 position, normal;
attribute vec4 color;

varying vec3 surfaceNormal, surfacePosition;
varying vec4 _worldSpacePosition;
varying vec4 vColor;

void main() {
  vColor = color;

  surfacePosition = position;
  surfaceNormal = normal;
  vec4 worldSpacePosition = model * vec4(position, 1);
  _worldSpacePosition = worldSpacePosition;

  vec4 glPosition = projection * view * model * vec4(position, 1);
  gl_Position = glPosition;
}
`}),Lc}var Fc,Pd;function GN(){return Pd||(Pd=1,Fc={frag:`
precision mediump float;
uniform vec4 ucolor;

void main () {
  gl_FragColor = ucolor;
}
`}),Fc}const NN=ir,{meshColor:DN}=ka,kN=(e,t={})=>{const r={color:DN,geometry:void 0};let{geometry:n,color:s,transparent:o}=Object.assign({},r,t);"color"in n&&(s=n.color);const a=!!(n.indices&&n.indices.length>0),i=!!(n.normals&&n.normals.length>0),c=!!(n.colors&&n.colors.length>0),l=c?Sd().vert:FN().vert,u=c?Sd().frag:GN().frag,d={primitive:"lines",vert:l,frag:u,uniforms:{model:(h,p)=>p.model||n.transforms||NN.create(),ucolor:(h,p)=>p&&p.color?p.color:s},attributes:{position:e.buffer({usage:"static",type:"float",data:n.positions})}};return o&&(d.blend={enable:!0,func:{src:"src alpha",dst:"one minus src alpha"}}),c&&(d.attributes.color=e.buffer({usage:"static",type:"float",data:n.colors})),a&&(d.elements=e.elements({usage:"static",type:"uint16",data:n.indices})),i&&(d.attributes.normal=e.buffer({usage:"static",type:"float",data:n.normals})),e(d)};var BN=kN,Dm=1e-6,km=IN;function IN(){var e=new Float32Array(3);return e[0]=0,e[1]=0,e[2]=0,e}var VN=zN;function zN(e){var t=new Float32Array(3);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t}var Bm=UN;function UN(e,t,r){var n=new Float32Array(3);return n[0]=e,n[1]=t,n[2]=r,n}var Im=qN;function qN(e,t){var r=t[0],n=t[1],s=t[2],o=r*r+n*n+s*s;return o>0&&(o=1/Math.sqrt(o),e[0]=t[0]*o,e[1]=t[1]*o,e[2]=t[2]*o),e}var Vm=XN;function XN(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}var jN=YN,Cd=Bm,Od=Im,HN=Vm;function YN(e,t){var r=Cd(e[0],e[1],e[2]),n=Cd(t[0],t[1],t[2]);Od(r,r),Od(n,n);var s=HN(r,n);return s>1?0:Math.acos(s)}var WN=ZN;function ZN(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}var QN=KN;function KN(e,t,r,n){return e[0]=t,e[1]=r,e[2]=n,e}var JN=eD,Gc=Dm;function eD(e,t){var r=e[0],n=e[1],s=e[2],o=t[0],a=t[1],i=t[2];return Math.abs(r-o)<=Gc*Math.max(1,Math.abs(r),Math.abs(o))&&Math.abs(n-a)<=Gc*Math.max(1,Math.abs(n),Math.abs(a))&&Math.abs(s-i)<=Gc*Math.max(1,Math.abs(s),Math.abs(i))}var tD=rD;function rD(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}var nD=sD;function sD(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e}var zm=oD;function oD(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e}var aD=zm,Um=iD;function iD(e,t,r){return e[0]=t[0]*r[0],e[1]=t[1]*r[1],e[2]=t[2]*r[2],e}var cD=Um,qm=lD;function lD(e,t,r){return e[0]=t[0]/r[0],e[1]=t[1]/r[1],e[2]=t[2]/r[2],e}var fD=qm,uD=dD;function dD(e,t,r){return e[0]=Math.min(t[0],r[0]),e[1]=Math.min(t[1],r[1]),e[2]=Math.min(t[2],r[2]),e}var hD=mD;function mD(e,t,r){return e[0]=Math.max(t[0],r[0]),e[1]=Math.max(t[1],r[1]),e[2]=Math.max(t[2],r[2]),e}var pD=vD;function vD(e,t){return e[0]=Math.floor(t[0]),e[1]=Math.floor(t[1]),e[2]=Math.floor(t[2]),e}var gD=yD;function yD(e,t){return e[0]=Math.ceil(t[0]),e[1]=Math.ceil(t[1]),e[2]=Math.ceil(t[2]),e}var bD=wD;function wD(e,t){return e[0]=Math.round(t[0]),e[1]=Math.round(t[1]),e[2]=Math.round(t[2]),e}var _D=xD;function xD(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e}var ED=$D;function $D(e,t,r,n){return e[0]=t[0]+r[0]*n,e[1]=t[1]+r[1]*n,e[2]=t[2]+r[2]*n,e}var Xm=AD;function AD(e,t){var r=t[0]-e[0],n=t[1]-e[1],s=t[2]-e[2];return Math.sqrt(r*r+n*n+s*s)}var TD=Xm,jm=SD;function SD(e,t){var r=t[0]-e[0],n=t[1]-e[1],s=t[2]-e[2];return r*r+n*n+s*s}var PD=jm,Hm=CD;function CD(e){var t=e[0],r=e[1],n=e[2];return Math.sqrt(t*t+r*r+n*n)}var OD=Hm,Ym=MD;function MD(e){var t=e[0],r=e[1],n=e[2];return t*t+r*r+n*n}var RD=Ym,LD=FD;function FD(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e}var GD=ND;function ND(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}var DD=kD;function kD(e,t,r){var n=t[0],s=t[1],o=t[2],a=r[0],i=r[1],c=r[2];return e[0]=s*c-o*i,e[1]=o*a-n*c,e[2]=n*i-s*a,e}var BD=ID;function ID(e,t,r,n){var s=t[0],o=t[1],a=t[2];return e[0]=s+n*(r[0]-s),e[1]=o+n*(r[1]-o),e[2]=a+n*(r[2]-a),e}var VD=zD;function zD(e,t){t=t||1;var r=Math.random()*2*Math.PI,n=Math.random()*2-1,s=Math.sqrt(1-n*n)*t;return e[0]=Math.cos(r)*s,e[1]=Math.sin(r)*s,e[2]=n*t,e}var UD=qD;function qD(e,t,r){var n=t[0],s=t[1],o=t[2],a=r[3]*n+r[7]*s+r[11]*o+r[15];return a=a||1,e[0]=(r[0]*n+r[4]*s+r[8]*o+r[12])/a,e[1]=(r[1]*n+r[5]*s+r[9]*o+r[13])/a,e[2]=(r[2]*n+r[6]*s+r[10]*o+r[14])/a,e}var XD=jD;function jD(e,t,r){var n=t[0],s=t[1],o=t[2];return e[0]=n*r[0]+s*r[3]+o*r[6],e[1]=n*r[1]+s*r[4]+o*r[7],e[2]=n*r[2]+s*r[5]+o*r[8],e}var HD=YD;function YD(e,t,r){var n=t[0],s=t[1],o=t[2],a=r[0],i=r[1],c=r[2],l=r[3],u=l*n+i*o-c*s,d=l*s+c*n-a*o,h=l*o+a*s-i*n,p=-a*n-i*s-c*o;return e[0]=u*l+p*-a+d*-c-h*-i,e[1]=d*l+p*-i+h*-a-u*-c,e[2]=h*l+p*-c+u*-i-d*-a,e}var WD=ZD;function ZD(e,t,r,n){var s=r[1],o=r[2],a=t[1]-s,i=t[2]-o,c=Math.sin(n),l=Math.cos(n);return e[0]=t[0],e[1]=s+a*l-i*c,e[2]=o+a*c+i*l,e}var QD=KD;function KD(e,t,r,n){var s=r[0],o=r[2],a=t[0]-s,i=t[2]-o,c=Math.sin(n),l=Math.cos(n);return e[0]=s+i*c+a*l,e[1]=t[1],e[2]=o+i*l-a*c,e}var JD=e7;function e7(e,t,r,n){var s=r[0],o=r[1],a=t[0]-s,i=t[1]-o,c=Math.sin(n),l=Math.cos(n);return e[0]=s+a*l-i*c,e[1]=o+a*c+i*l,e[2]=t[2],e}var t7=r7,jr=km();function r7(e,t,r,n,s,o){var a,i;for(t||(t=3),r||(r=0),n?i=Math.min(n*t+r,e.length):i=e.length,a=r;a<i;a+=t)jr[0]=e[a],jr[1]=e[a+1],jr[2]=e[a+2],s(jr,jr,o),e[a]=jr[0],e[a+1]=jr[1],e[a+2]=jr[2];return e}var to={EPSILON:Dm,create:km,clone:VN,angle:jN,fromValues:Bm,copy:WN,set:QN,equals:JN,exactEquals:tD,add:nD,subtract:zm,sub:aD,multiply:Um,mul:cD,divide:qm,div:fD,min:uD,max:hD,floor:pD,ceil:gD,round:bD,scale:_D,scaleAndAdd:ED,distance:Xm,dist:TD,squaredDistance:jm,sqrDist:PD,length:Hm,len:OD,squaredLength:Ym,sqrLen:RD,negate:LD,inverse:GD,normalize:Im,dot:Vm,cross:DD,lerp:BD,random:VD,transformMat4:UD,transformMat3:XD,transformQuat:HD,rotateX:WD,rotateY:QD,rotateZ:JD,forEach:t7};const _n=ir,Nc=to,Wm={view:_n.identity(new Float32Array(16)),projection:_n.identity(new Float32Array(16)),matrix:_n.identity(new Float32Array(16)),near:1,far:18e3,up:[0,0,1],eye:new Float32Array(3),position:[450,550,700],target:[0,0,0],fov:Math.PI/4,aspect:1,viewport:[0,0,0,0],projectionType:"perspective"},Zm={},n7=Object.assign({},Wm,Zm),s7=(e,t,r)=>{const n=r.width/r.height,s=_n.perspective(_n.identity([]),t.fov,n,t.near,t.far),o=[0,0,r.width,r.height],a=e||{};return a.projection=s,a.aspect=n,a.viewport=o,a},o7=(e,t)=>{t||(t=e);const{position:r,target:n,up:s}=t,o=Nc.subtract([],r,n),a=Nc.add(Nc.create(),n,o),i=_n.lookAt(_n.create(),a,n,s),c=e||{};return c.position=a,c.view=i,c};var el={cameraState:Wm,cameraProps:Zm,defaults:n7,setProjection:s7,update:o7};const fa=ir,a7={view:fa.identity(new Float32Array(16)),projection:fa.identity(new Float32Array(16)),matrix:fa.identity(new Float32Array(16)),near:1,far:1300,up:[0,0,1],eye:new Float32Array(3),position:[150,250,200],target:[0,0,0],fov:Math.PI/4,aspect:1,viewport:[0,0,0,0],zoom:1,projectionType:"orthographic"},i7={},c7=(e,t)=>{const{width:r,height:n}=t,s=r/n,o=[0,0,r,n],a=e.zoom,i=-r*a,c=r*a,l=-n*a,u=n*a;return{projection:fa.ortho([],i,c,l,u,e.near,e.far),aspect:s,viewport:o}};var va={cameraState:a7,cameraProps:i7,setProjection:c7};const Jn=to,ga=ir,l7=e=>{const{near:t,far:r,fov:n,zoom:s}=e,{viewport:o}=e,a=el.setProjection(e,{width:o[2],height:o[3]}),{projectionType:i}=el.cameraState;return Object.assign({},e,a,{projectionType:i},{near:t,far:r,fov:n})},f7=e=>{const{fov:t,aspect:r}=e,n=Jn.length(Jn.subtract([],e.position,e.target))*.3,s=Math.tan(t)*n*r,o=Math.tan(t)*n,{near:a,far:i,viewport:c}=e,l={zoom:1,near:a,far:i},u=va.cameraState,d=va.setProjection(l,{width:s,height:o});return Object.assign({},u,e,d,{projectionType:u.projectionType,viewport:c})},u7=({camera:e})=>{const r=Jn.distance(e.position,e.target),n=[r,r,r];return{view:ga.lookAt(ga.create(),n,e.target,e.up),position:n}},d7=(e,{camera:t})=>{const r={top:[0,-1e-6,1],bottom:[0,0,-1],front:[0,1,0],back:[0,-1,0],left:[-1,0,0],right:[1,0,0],undefined:[0,0,0]},n=Jn.distance(t.position,t.target),s=Jn.add(Jn.create(),r[e].map(a=>a*n),t.target);return{view:ga.lookAt(ga.create(),s,t.target,t.up),position:s}};var h7={toPerspectiveView:u7,toPresetView:d7,fromOrthographicToPerspective:l7,fromPerspectiveToOrthographic:f7};const m7=e=>{if(e.length===0)return[[0,0,0],[0,0,0]];const t=Array.isArray(e)&&Array.isArray(e[0]),r=t?e[0].length:3,n=new Array(r),s=new Array(r);for(let o=0;o<r;o+=1)n[o]=1/0,s[o]=-1/0;if(t)e.forEach(o=>{for(let a=0;a<r;a+=1){const i=t?o[a]:o;s[a]=i>s[a]?i:s[a],n[a]=i<n[a]?i:n[a]}});else for(let o=0;o<e.length;o+=r)for(let a=0;a<r;a+=1){const i=e[a+o];s[a]=i>s[a]?i:s[a],n[a]=i<n[a]?i:n[a]}return[n,s]};var p7=m7;const sr=to,{flatten:v7}=Cl,g7=p7,y7=(...e)=>{e=v7(e);let t;e.forEach(c=>{let l=g7(c.positions);l=l.map(u=>sr.transformMat4(u,u,c.transforms)),t?(sr.min(t[0],t[0],l[0]),sr.max(t[1],t[1],l[1])):t=l});const r=sr.min(sr.create(),t[1],t[0]),n=sr.max(sr.create(),t[1],t[0]),s=sr.subtract(sr.create(),n,r);let o=sr.scale(sr.create(),s,.5);return o=sr.add(o,r,o),{dia:sr.distance(o,n),center:[...o],min:[...r],max:[...n],size:[...s]}};var b7=y7,Dc,Md;function w7(){if(Md)return Dc;Md=1,Dc=e;function e(t,r,n){var s=r[0],o=r[1],a=r[2],i=n[0],c=n[1],l=n[2],u=n[3],d=n[4],h=n[5],p=n[6],E=n[7],g=n[8],b=n[9],S=n[10],G=n[11],R=n[12],M=n[13],F=n[14],L=n[15],U=1/(s*u+o*E+a*G+L);return t[0]=(s*i+o*d+a*g+R)*U,t[1]=(s*c+o*h+a*b+M)*U,t[2]=(s*l+o*p+a*S+F)*U,t}return Dc}var kc,Rd;function _7(){if(Rd)return kc;Rd=1;var e=w7();kc=t;function t(r,n,s,o){var a=s[0],i=s[1],c=s[2],l=s[3],u=n[0],d=n[1],h=n[2];return u=u-a,d=l-d-1,d=d-i,r[0]=2*u/c-1,r[1]=2*d/l-1,r[2]=2*h-1,e(r,r,o)}return kc}const qt=to,Hs=ir,{max:Bc,min:Ic,sqrt:Ld,PI:x7,sin:Wn,cos:sa,atan2:oa}=Math,E7=b7,Ol={limits:{minDistance:.01,maxDistance:1e4},drag:.27,EPS:1e-6,zoomToFit:{auto:!0,targets:"all",tightness:1.5},userControl:{zoom:!0,zoomSpeed:1,rotate:!0,rotateSpeed:1,pan:!0,panSpeed:1},autoRotate:{enabled:!1,speed:1},autoAdjustPlanes:!0},Qm={thetaDelta:0,phiDelta:0,scale:1},$7=Object.assign({},Qm,Ol),A7=({controls:e,camera:t},r)=>{const{EPS:n,drag:s}=e,{position:o,target:a}=t,i=e.up?e.up:t.up;let c=e.thetaDelta;const l=e.phiDelta,u=e.scale,d=qt.subtract([],o,a);let h,p;i[2]===1?(h=oa(d[0],d[1]),p=oa(Ld(d[0]*d[0]+d[1]*d[1]),d[2])):(h=oa(d[0],d[2]),p=oa(Ld(d[0]*d[0]+d[2]*d[2]),d[1])),e.autoRotate.enabled&&e.userControl.rotate&&(c+=2*Math.PI/60/60*e.autoRotate.speed),h+=c,p+=l,p=Bc(n,Ic(x7-n,p));const E=Bc(e.limits.minDistance,Ic(e.limits.maxDistance,qt.length(d)*u));i[2]===1?(d[0]=E*Wn(p)*Wn(h),d[2]=E*sa(p),d[1]=E*Wn(p)*sa(h)):(d[0]=E*Wn(p)*Wn(h),d[1]=E*sa(p),d[2]=E*Wn(p)*sa(h));const g=qt.add(qt.create(),a,d),b=Hs.lookAt(Hs.create(),g,a,i),S=1-Bc(Ic(s,1),.01),G=qt.distance(o,g)>.001;return{controls:{thetaDelta:c*S,phiDelta:l*S,scale:1,changed:G},camera:{position:g,view:b}}},T7=({controls:e,camera:t,speed:r=1},n)=>{let{thetaDelta:s,phiDelta:o}=e;return e.userControl.rotate&&(s+=n[0]*r,o+=n[1]*r),{controls:{thetaDelta:s,phiDelta:o},camera:t}},S7=({controls:e,camera:t,speed:r=1},n=0)=>{let{scale:s}=e;if(e.userControl.zoom&&t&&n!==void 0&&n!==0&&!isNaN(n)){const o=Math.sign(n)===0?1:Math.sign(n);n=n/n*o*r;const a=n+e.scale,i=qt.distance(t.position,t.target)*a;if(i>e.limits.minDistance&&i<e.limits.maxDistance&&(s+=n),t.projectionType==="orthographic"){const c=qt.length(qt.subtract([],t.position,t.target))*.3,l=Math.tan(t.fov)*c*t.aspect,u=Math.tan(t.fov)*c;t=va.setProjection(t,{width:l,height:u})}}return{controls:{scale:s},camera:t}},P7=({controls:e,camera:t,speed:r=1},n)=>{const s=_7(),{projection:o,view:a,viewport:i}=t,c=Hs.multiply([],o,a),l=Hs.invert([],c),u=[i[2],i[3],0],d=[i[2]-n[0],i[3]+n[1],0],h=s([],u,i,l),p=s([],d,i,l),E=qt.distance(t.position,t.eye),g=qt.subtract([],h,p).map(b=>b*r*E*e.scale);return{controls:e,camera:{position:qt.add(qt.create(),t.position,g),target:qt.add(qt.create(),t.target,g)}}},C7=({controls:e,camera:t,entities:r})=>{const{zoomToFit:n}=e;if(n.targets!=="all")return{controls:e,camera:t};if(r.length===0)return{controls:e,camera:t};const s=r.map(p=>p.geometry),o=E7(s),{fov:a,target:i,position:c}=t,{tightness:l}=Object.assign({},n,Ol.zoomToFit),u=o.dia*l/Math.tan(a/2),d=qt.distance(i,c),h=u/d;return{camera:{target:o.center},controls:{scale:h}}},O7=({controls:e,camera:t},r)=>({camera:{position:r.camera.position,target:r.camera.target,projection:Hs.perspective([],t.fov,t.aspect,t.near,t.far),view:r.camera.view},controls:{thetaDelta:r.controls.thetaDelta,phiDelta:r.controls.phiDelta,scale:r.controls.scale}});var M7={controlsProps:Ol,controlsState:Qm,defaults:$7,update:A7,rotate:T7,zoom:S7,pan:P7,zoomToFit:C7,reset:O7};const Fd=ir,Vc=Math.floor(65535/2),R7=(e,t)=>{let{color:r}=e;const n=t.sides;if(n.length===0)return[];"color"in t&&(r=t.color);const s=r[3]<1,o=[],a=Math.floor(n.length/Vc)+1,i=(l,u)=>{o.push(l,u||l)},c=[];for(let l=0;l<a;l++){const u=l*Vc,d=Math.min(u+Vc,n.length),h=[];for(let b=u;b<d;b++){const S=n[b];if(S.color){if(o.length===0&&h.length>0){const G=h.length;for(let R=0;R<G;R++)o.push(r)}i(S.color,S.endColor)}else o.length&&i(r);h.push([S[0][0],S[0][1],0]),h.push([S[1][0],S[1][1],0])}const p=h.map(b=>[0,0,-1]),E=h.map((b,S)=>S),g=t.transforms?Fd.clone(t.transforms):Fd.create();c.push({type:"2d",positions:h,normals:p,indices:E,transforms:g,color:r,colors:o,isTransparent:s})}return c};var L7=R7;const Hr=to,Gd=ir,F7=65535,G7=(e,t)=>{let{color:r,smoothLighting:n}=e;"color"in t&&(r=t.color);const s=t.polygons,o=t.transforms?Gd.clone(t.transforms):Gd.create(),a=[];let i=0;for(;i<s.length;){let c=0,l=i;for(let b=i;b<s.length&&(c+=s[b].vertices.length,!(c>F7));b++)l++;const u=[],d=[],h=[],p=[],E=r[3]<1;for(let b=i;b<l;b++){const S=s[b],G=S.vertices,R=D7(S),M=N7(S,r),F=[];for(let L=0;L<G.length;L++){const U=G[L];u.push(U),d.push(R),p.push(M);const ee=u.length-1;F.push(ee)}for(let L=2;L<F.length;L++)h.push([F[0],F[L-1],F[L]])}const g={type:"3d",positions:u,normals:d,indices:h,colors:p,transforms:o,isTransparent:E};a.push(g),i=l}return a},N7=(e,t)=>{let r=t;return e.color&&(r=e.color),r&&r.length<4&&r.push(1),r},D7=e=>{if(e.plane)return Hr.clone(e.plane);const t=e.vertices,r=Hr.create();Hr.subtract(r,t[1],t[0]);const n=Hr.create();Hr.subtract(n,t[2],t[0]);const s=Hr.create();return Hr.cross(s,r,n),Hr.normalize(s,s),s};var k7=G7;const Nd=ir,zc=Math.floor(65535/2)-2,B7=(e,t)=>{let{color:r}=e;const n=t.points;if(n.length===0)return[];"color"in t&&(r=t.color);const s=r[3]<1,o=Math.floor(n.length/zc)+1,a=[];for(let i=0;i<o;i++){const c=i*zc,l=Math.min(c+zc,n.length),u=[];let d;for(let g=c;g<l;g++){const b=n[g];d&&(u.push([d[0],d[1],0]),u.push([b[0],b[1],0])),d=b}if(i+1===o&&t.isClosed&&d){const g=n[0];u.push([d[0],d[1],0]),u.push([g[0],g[1],0])}const h=u.map(g=>[0,0,-1]),p=u.map((g,b)=>b),E=t.transforms?Nd.clone(t.transforms):Nd.create();a.push({type:"2d",positions:u,normals:h,indices:p,transforms:E,color:r,isTransparent:s})}return a};var I7=B7;const{flatten:V7,toArray:z7}=Cl,{meshColor:U7}=ka,q7=L7,X7=k7,j7=I7,H7=e=>e.map(r=>{const n={drawCmd:r.type==="2d"?"drawLines":"drawMesh",show:!0,transparent:r.isTransparent,useVertexColors:!0};return{geometry:r,visuals:n}}),Y7=(e,...t)=>{const r={color:U7,smoothNormals:!0},{color:n,smoothNormals:s}=Object.assign({},r,e);t=V7(z7(t)),t=t.filter(a=>a&&a instanceof Object);const o=[];return t.forEach(a=>{let i=[];"sides"in a?i=q7({color:n},a):"points"in a?i=j7({color:n},a):"polygons"in a&&(i=X7({smoothLighting:s,normalThreshold:.3,color:n},a)),o.push(...H7(i))}),o};var W7=Y7,Yr={prepareRender:TN,drawCommands:{drawGrid:PN,drawAxis:ON,drawMesh:LN,drawLines:BN},cameras:{camera:h7,orthographic:va,perspective:el},controls:{orbit:M7},entitiesFromSolids:W7};const aa=Yr.cameras.perspective,ks=Yr.controls.orbit,Z7=({containerElement:e,model:t})=>{const r=e.clientWidth,n=e.clientHeight,s={};s.camera=Object.assign({},aa.defaults,{position:[1500,2e3,2e3],fov:Math.PI/32}),aa.setProjection(s.camera,s.camera,{width:r,height:n}),aa.update(s.camera,s.camera),s.controls=ks.defaults;const o={glOptions:{container:e}},a=Yr.prepareRender(o),i={visuals:{drawCmd:"drawGrid",show:!0},size:[500,500],ticks:[10,1],color:[0,0,1,1],subColor:[0,0,1,.5]},c={visuals:{drawCmd:"drawAxis",show:!0},size:300},l=Yr.entitiesFromSolids({},t),u={camera:s.camera,drawCommands:{drawAxis:Yr.drawCommands.drawAxis,drawGrid:Yr.drawCommands.drawGrid,drawLines:Yr.drawCommands.drawLines,drawMesh:Yr.drawCommands.drawMesh},entities:[i,c,...l]};let d=!0;const h=()=>{if(R[0]||R[1]){const Q=ks.rotate({controls:s.controls,camera:s.camera,speed:b},R);s.controls={...s.controls,...Q.controls},d=!0,R=[0,0]}if(M[0]||M[1]){const Q=ks.pan({controls:s.controls,camera:s.camera,speed:S},M);s.controls={...s.controls,...Q.controls},M=[0,0],s.camera.position=Q.camera.position,s.camera.target=Q.camera.target,d=!0}if(F){const Q=ks.zoom({controls:s.controls,camera:s.camera,speed:G},F);s.controls={...s.controls,...Q.controls},F=0,d=!0}},p=Q=>{if(h(),d){const Se=ks.update({controls:s.controls,camera:s.camera});s.controls={...s.controls,...Se.controls},d=s.controls.changed,s.camera.position=Se.camera.position,aa.update(s.camera),a(u)}window.requestAnimationFrame(p)};window.requestAnimationFrame(p);let E=0,g=0;const b=.002,S=1,G=.08;let R=[0,0],M=[0,0],F=0,L=!1;const U=Q=>{if(!L)return;const Se=E-Q.pageX,qe=Q.pageY-g;Q.shiftKey===!0||Q.touches!==void 0&&Q.touches.length>2?(M[0]+=Se,M[1]+=qe):(R[0]-=Se,R[1]-=qe),E=Q.pageX,g=Q.pageY,Q.preventDefault()},ee=Q=>{L=!0,E=Q.pageX,g=Q.pageY,e.setPointerCapture(Q.pointerId)},oe=Q=>{L=!1,e.releasePointerCapture(Q.pointerId)},pe=Q=>{F+=Q.deltaY,Q.preventDefault()};e.onpointermove=U,e.onpointerdown=ee,e.onpointerup=oe,e.onwheel=pe},Dd=document.getElementById("jscad"),Km=pG();Dd!==null&&Z7({containerElement:Dd,model:Km});const Q7=async e=>{const t=new File([await e.arrayBuffer()],"model.stl"),r=document.createElement("a");r.style.display="none",r.href=URL.createObjectURL(t),r.download=t.name,document.body.appendChild(r),r.click(),setTimeout(()=>{var n;URL.revokeObjectURL(r.href),(n=r.parentNode)==null||n.removeChild(r)},0)};window.startDownload=()=>{const e=hG.serialize({binary:!0},Km),t=new Blob(e);Q7(t).catch(console.error)};
